<!-- THIS IS AUTO GENERATED, DO NOT MODIFY BY HAND -->

import DiscussionComment from '@site/src/components/DiscussionComment';

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-04-02T05:45:54Z" retrieveTime="2022-10-17T11:45:49.046468">

### [Proposal]Let Flutter run animations at 60fps even if there are heavy widgets, possibly using React Fiber-like or suspend-like algorithm?

EDIT: Design proposal https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?usp=sharing

---

Below (folded) are the initial proposal. However, I have realized the initial proposal has many drawbacks, and have raised new proposals. For example, [the dual isolate](https://github.com/flutter/flutter/issues/101227#issuecomment-1249005541) (click to view that comment).

<details>

Hi thanks for the framework! As we all know, React Fiber improves the performance and smoothness of React. Currently I am also observing some jank for Flutter app even after optimizing it using the tooltips in official doc, and I do hope there can be something similar to Fiber in Flutter side.

p.s. Some doc about react fiber: https://github.com/acdlite/react-fiber-architecture

I am interested in making contribution when having time as well.

</details>

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-04-02T08:22:05Z" retrieveTime="2022-10-17T11:45:49.046468">

> if I understand correctly you compare reconciling DOMs to rebuilding the elements in a widget tree
and you are proposing to rebuild only certain elements the same way react-fiber prioritize

Possibly not only Widget build, but also layout, paint, etc. Since it is often the case that the layout/paint cost time.

> give the developer the ability to set a widgets to low rendering priority

Sounds reasonable.

</DiscussionComment>

<DiscussionComment author="maheshmnj" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-04-04T07:48:34Z" retrieveTime="2022-10-17T11:45:49.046468">

Hi @fzyzcjy, Thanks for filing the issue. I am quite not sure about the algorithm and its effectiveness. Labeling this issue for further insights from the team.

cc: @dnfield  

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-04-04T08:07:41Z" retrieveTime="2022-10-17T11:45:49.046468">

@maheshmnj Hi thanks for the reply.

I have made an attempt about doing async rendering *without modifying* Flutter framework: https://github.com/fzyzcjy/flutter_smooth_render But the result is not very interesting - seems that we really need to dig into the framework itself instead of making a wrapper layer around it.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-04-04T14:56:51Z" retrieveTime="2022-10-17T11:45:49.046468">

I've been talking about something somewhat like this on the #hackers-framework channel in the past, but it's not a trivial problem to solve. I'd be interested in seeing more details about your designproposal and/or discussing on discord.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-04-04T16:37:22Z" retrieveTime="2022-10-17T11:45:49.046468">

And FWIW, this is likely a pretty significant amount of work to do, but there are some people who have already started looking at parts of it @hixie @goderbauer 

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-04-05T00:31:09Z" retrieveTime="2022-10-17T11:45:49.046468">

@dnfield Hi thanks for the reply! 

> but there are some people who have already started looking at parts of it @Hixie @goderbauer

To avoid reinventing the wheel, I hope to listen to the parts before thinking about what to do next

</DiscussionComment>

<DiscussionComment author="wangying3426" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-08T02:57:10Z" retrieveTime="2022-10-17T11:45:49.046468">

@fzyzcjy Any update please? We are also interested in this feature.



</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-08T03:06:09Z" retrieveTime="2022-10-17T11:45:49.046468">

@wangying3426 Well, no updates from me since I want to firstly listen to the "who have already started looking at parts of it @Hixie @goderbauer"

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-14T07:04:33Z" retrieveTime="2022-10-17T11:45:49.046468">

@Hixie @goderbauer @dnfield How do you think about this fiber proposal?

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-14T16:21:36Z" retrieveTime="2022-10-17T11:45:49.046468">

No one has come up with a workable proposal at this point in time. I think it's worth doing but it's not my top priority at the moment.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-14T23:11:50Z" retrieveTime="2022-10-17T11:45:49.046468">

> but it's not my top priority at the moment.

As mentioned earlier, I am willing to PR and contribute. But surely need some suggestions and discussions prior to start implementing :)

Btw I am not thinking about strictly implementing Fiber, since web model is not the same as Flutter model, but something inspired by it that can make our animations smoother.

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T02:56:03Z" retrieveTime="2022-10-17T11:45:49.046468">

> > but it's not my top priority at the moment.
> 
> 
> 
> As mentioned earlier, I am willing to PR and contribute. But surely need some suggestions and discussions prior to start implementing :)
> 
> 
> 
> Btw I am not thinking about strictly implementing Fiber, since web model is not the same as Flutter model, but something inspired by it that can make our animations smoother.

I think so. Maybe we can create a document and then a detailed description
- the fiber node archive and it can be interrupted by reconciler
- how does the Fiber reconciler work
- how does the flutter framework need to do and how to design

How do you think about it? @fzyzcjy 

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:01:06Z" retrieveTime="2022-10-17T11:45:49.046468">

> @JsouLiang Maybe we can create a document and then a detailed description

Sure! Maybe we can firstly discuss about it (maybe just here? - just like how I have seen many Dart/Flutter design discussions happen) and a detailed doc after we draw a (draft) conclusion

> how does the flutter framework need to do and how to design

Btw, fiber can make animations smoother, but if I understand correctly, the smoothness is because that specific animation is driven by css, not js. This is contrary to flutter. For example, a CircularProgressIndicator, or even a scrolling of ListView, is driven by Dart code. Thus, we cannot easily say "let's give control to flutter engine / android / ios / whatever once in a while when we are doing build/layout/paint/whatever". If we simply do so, we will not get a smooth animation automatically. Instead, we may need to find out a more sophisticated approach.

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:27:32Z" retrieveTime="2022-10-17T11:45:49.046468">

> but if I understand correctly, the smoothness is because that specific animation is driven by css, not js.

Yes, the CSS animation is driven by css, not through js
That mean, the CSS associated with the HTML element can calculate the animation difference directly, without going through JS. @fzyzcjy 



</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:28:45Z" retrieveTime="2022-10-17T11:45:49.046468">

Yes, that is why fiber is so useful. Indeed it is like, the web ui is driven by two things - the JS and CSS. Fiber pause JS once in a while so CSS things can come in and animate.

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:28:53Z" retrieveTime="2022-10-17T11:45:49.046468">

> @fzyzcjy Btw, fiber can make animations smoother, but if I understand correctly, the smoothness is because that specific animation is driven by css, not js. This is contrary to flutter. For example, a CircularProgressIndicator, or even a scrolling of ListView, is driven by Dart code. Thus, we cannot easily say "let's give control to flutter engine / android / ios / whatever once in a while when we are doing build/layout/paint/whatever". If we simply do so, we will not get a smooth animation automatically. Instead, we may need to find out a more sophisticated approach.

As you say, Web animation like css animate, Android ViewPropertyAnimator (maybe iOS also has similar animate mechanism), they all are driven by browser/system, but in Flutter it is driven by ourselves with all other business logic.

for more, Android's window transition animation is driven by WindowService seperately

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:38:50Z" retrieveTime="2022-10-17T11:45:49.046468">

@JsouLiang @xanahopper 

So, it is possible we come up with something slightly different?

For example, if we want to make some animations faster, like CircularProgressIndicator and ListView-scrolling, is it possible to do the following: We give CircularProgressIndicator high priority, and it must be layout/paint at 60fps. In the meanwhile, all other widgets will run one layout/paint across multiple frames with suspending just like what Fiber does. In other words, when vsync comes, CircularProgressIndicator will do all the layout/paint job, while other widgets will continue working on its layout/paint but will pause once it is near 16ms. Then, we can see CircularProgressIndicator smooth at 60fps, while other widgets having similar rendering speed as before.

Btw, some side remarks that is less like Fiber: Here is a tool that defers Widgets from being built https://github.com/LianjiaTech/keframe. But I guess we can make it more fine-grained and with more improvements since we are going to modify the flutter framework itself. For example, (very rough draft idea), can we modify the layout phase (or paint, or others), such that it pauses layouting the remainder (and will do it in the next frame), and let painting and other phases go first?

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:44:07Z" retrieveTime="2022-10-17T11:45:49.046468">

The hard part of all of this is to figure out how to do it without breaking existing Framework code.

I think it's probably possible, but it's not easy.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:44:58Z" retrieveTime="2022-10-17T11:45:49.046468">

> @dnfield without breaking existing Framework code

We are allowed to modify anything in Flutter, don't we :) Just not allowed to break existing API that is used by flutter users.

Then, maybe we can have a feature flag?

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:45:53Z" retrieveTime="2022-10-17T11:45:49.046468">

@fzyzcjy Yes, we all farmilar with KeFrame and has already applied some optimize like it.
> I guess we can make it more fine-grained and with more improvements since we are going to modify the flutter framework itself.

I think this may the point we are going to discuss.


> The hard part of all of this is to figure out how to do it without breaking existing Framework code.
> 
> I think it's probably possible, but it's not easy.
@dnfield we cannot just stop because is not easy. if it is a right way to improve it.


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:46:35Z" retrieveTime="2022-10-17T11:45:49.046468">

> we cannot just stop because is not easy. if it is a right way to improve it.

Same here :) I like challenging, i.e. exciting, work!

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:50:41Z" retrieveTime="2022-10-17T11:45:49.046468">

@fzyzcjy I'm interested in this topic and have been trying to go in a direction where Keframe can make the best use of each 16.7ms, since now each item will take the full 16.7ms (even though it may only take 1ms on some good devices). I'm trying to count the time taken by individual items to determine how many items should be rendered in the next frame.


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:52:19Z" retrieveTime="2022-10-17T11:45:49.046468">

Continue from the animation proposal above, with @dnfield's "without breaking existing Framework code":

Maybe we can have a global flag, say, `bool enableFiber = false`. By default it is false, so users can use existing API freely without any change. When user manually set it to true, our new feature runs.

The API may be as simple as a Widget, say, `HighPrioritySubTree(builder: (context, child) => build_your_subtree_here, child: put_static_child_here)`, just like animation builder widgets. That builder should wrap the CircularProgressIndicator in the example above. We may also add a `CancelHighPrioritySubTree` if needed. For example, when scrolling ListView, we may want the scrolling animation be at 60fps, while we have to accept that a big widget in ListView is slow to build. Then, we may wrap ListView with HighPrioritySubTree, and each child of ListView with CancelHighPrioritySubTree. By doing so, our ListView will be forcefully built at each frame, while its contents will be stale for a few frames.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T03:54:47Z" retrieveTime="2022-10-17T11:45:49.046468">

@Nayuta403 I have had similar thoughts before. The problem is, `build` phase is not the most costly one. There are `layout` and `paint` phase, etc, as well. What's worse, Flutter has C++ engine code which rasterizes and flush to the screen. That one can take a long time in some cases (for example, in my own app, when there is a ton of bezier curves). A widget may, for example, have very short `build` phase time but very long C++ rasterize time.

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T04:00:38Z" retrieveTime="2022-10-17T11:45:49.046468">

> The API may be as simple as a Widget, say, `HighPrioritySubTree(builder: (context, child) => build_your_subtree_here, child: put_static_child_here)`, just like animation builder widgets. That builder should wrap the CircularProgressIndicator in the example above. We may also add a `CancelHighPrioritySubTree` if needed. For example, when scrolling ListView, we may want the scrolling animation be at 60fps, while we have to accept that a big widget in ListView is slow to build. Then, we may wrap ListView with HighPrioritySubTree, and each child of ListView with CancelHighPrioritySubTree. By doing so, our ListView will be forcefully built at each frame, while its contents will be stale for a few frames.

@fzyzcjy I agree with switch flag, but some individual widget may still look verbose. I'd rather like to add a optional parameter to base class `Widget` to specify it's build/layout/render priority.
Than change default page transition widget, scrollable container to high priority and wrap its content to low priority.


</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T04:06:56Z" retrieveTime="2022-10-17T11:45:49.046468">

And here is another case may need to be consider: the list.
 in general container such as page, content size has no effect with container and other siblings, but things are different in list.
if we have different size of different item, we cannot just show placeholder with same size, scrolling when and after content item is building/layouting may cause a sudden change in list.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T04:09:32Z" retrieveTime="2022-10-17T11:45:49.046468">

>  I'd rather like to add a optional parameter to base class Widget to specify it's build/layout/render priority.

That sounds good to me. With that flag, we can also very easily create the widgets I mention. Just like the repaintBoundary is a flag and we create a widget to set it.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T04:12:13Z" retrieveTime="2022-10-17T11:45:49.046468">

> if we have different size of different item, we cannot just show placeholder with same size, scrolling when and after content item is building/layouting may cause a sudden change in list.

That's true. `keframe` workaround by letting the developer specify a placeholder size *manually*. But surely, for complex list items, we can never predict the size in advance so it still "jumps" when real content loads.

Maybe this is inevitable, and we have to live with it? Or, maybe we just place background color on those non-built entries?

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T04:25:56Z" retrieveTime="2022-10-17T11:45:49.046468">

we have to live with it, but we can give some different solutions, such like allow jumps, background color or some other...

I remember that iOS has very high priority with scrolling. If we can get item's size before build, this may not be a problem.

pre-measure for many things is possible but we have two considerations:
- it cannot block UI/main thread otherwise it means nothing
- it should has slice cost for developer to do that

this may conflict with principle of Flutter for single pass measure……but I think it has already has many cases in practice against that, it may not be a big deal.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T05:20:21Z" retrieveTime="2022-10-17T11:45:49.046468">

@xanahopper I am not sure whether that is another isolated problem, or we can directly solve it within our proposal about this issue. For example, if we are to add a pre-measure phase, we may add computeSomething in addition to existing computeLayout, computeDryLayout etc, and that may be orthogonal to this issue.

Btw, I suspect whether pre-measure can happen before `build` phase, since we even do not know the widget tree then. Maybe it can happen before `layout` phase?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T05:47:02Z" retrieveTime="2022-10-17T11:45:49.046468">

> @fzyzcjy reply to @Nayuta403  I have had similar thoughts before. The problem is, build phase is not the most costly one. There are layout and paint phase, etc, as well. What's worse, Flutter has C++ engine code which rasterizes and flush to the screen. That one can take a long time in some cases (for example, in my own app, when there is a ton of bezier curves). A widget may, for example, have very short build phase time but very long C++ rasterize time.

Just to make it a little bit more detailed: On the contrary, if my proposal above works, the following may happen -

1. Animations are in perfect 60fps, since low-priority job auto pause when near timeout. If we use keframe or similar solution, and give too many widgets in one frame, our animation will stuck.
2. No cpu cycles are wasted, because we will never early-pause but will only pause when near timeout. For example, suppose widget A needs 160ms to build+layout+paint+raster, then it will be done in (roughly) 10 frames. If we use keframe or similar solution, and give too little widgets in one frame, we are wasting cpu cycles.
3. It avoids our need to measure, or guess, the time needed for a widget in build/layout/paint/raster phase. Just as I mentioned above, I personally find it hard to guess how long a widget will need in those phases, especially raster phase which is C++ and varies greatly on different CPU/GPUs (different phones).
4. It is OK to have a non-separable widget that is heavy in one phase.
5. It is automatic and declarative. Programmers only need to specify priorities and that's all.

Btw I also like your (@Nayuta403) keframe solution :) Just trying to propose something that we can make flutter even better

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:09:38Z" retrieveTime="2022-10-17T11:45:49.046468">

@fzyzcjy  Thank you, I think we all want to make Flutter better. ❤️

So I think of a few problems we might have to solve: 
1. How to get the current UI cost, I think we still need to know this information even if we put the animation in the high priority queue, so that we can determine when the low priority task should end. 
2. How does the ListVIew item handle sliding when there is no width and height information 
3. How Fiber builds interruptible. It might be a little easier for a ListVIew, because its items are siblings. But what about parent-child nodes like Container?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:10:03Z" retrieveTime="2022-10-17T11:45:49.046468">

More thoughts here.

#### 1. For CircularProgressIndicator, or high-priority widgets without low-priority children

A very draft idea:

We may have multiple sub-trees, i.e. have a forest, in flutter. In this example, CircularProgressIndicator may be subtree 1, and everything else may be subtree 2. The subtree 1 goes through build/layout/paint/raster etc for each frame, and subtree 2 may go slowly, i.e. suspend.

Suppose it needs 10 frames for subtree 2 to finish the whole build/layout/paint/raster process. Then, we just allow all inconsistent and dirty states to exist during that 10 frames. For example, a node may have several layouted children and several un-layouted children. Same goes for rasterizing etc. We also need to ensure nobody can mutate the state accidentally when they are dirty.

In addition, I think we may not need to add this suspend feature to the `build` phase, but only add to layout/paint/raster if possible, contrary to React. This is because, if the time-consuming operation is only at build phase, keframe or similar solutions should already work. It may be deep in the rendering pipeline that makes this proposed method more interesting.

Surely this is just a draft and brainstorm, and I am willing to hear any thoughts!

#### 2. For ListView scrolling problem, or high-priority widgets with low-priority children

The problem is, those big low-priority children may need a lot of frames (say 10 frames) to build/layout/paint/rasterize, and during those 10 frames, their internal data structure are not ready for use. For example, we cannot let it to paint at 5th frame, because its layout tree (or layer tree or something like that) may have a child that has been layouted and another child that has not yet been layouted.

However, we are doing nothing but scrolling. Then what about simply *raster cache* the screen, and scrolling is nothing but shifting this `ui.Image`. More details can mimic this PR: https://github.com/flutter/flutter/pull/106621 In that PR, during a "zoom page transition", no real widgets are built in each frame. Instead, a `ui.Image` snapshot is taken in the first frame, and during the whole transition we are just zooming that Image. Our solution is different from #106621, though. In that PR, no work is done during the whole page transition, but in our case, we can perform useful build/layout/paint/raster in the remaining time of each frame.

This solution also has some spirit similar to React Fiber: In Fiber, our JS-driven DOM elements are freezed indeed, and it is the CSS animation that still works. In our case, the "scrolling ui.Image" is a bit mimic a scrolling CSS animation.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:13:41Z" retrieveTime="2022-10-17T11:45:49.046468">

> How to get the current UI cost, I think we still need to know this information even if we put the animation in the high priority queue, so that we can determine when the low priority task should end.

Seems we do not need? We just blindly run whatever should be done next, and suspend when we are near 16ms.

We do need to let the the high priority job (say CircularProgressIndicator or ListView-scrolling) finish within the totally 16ms though.

My first thought is that, it would be best if we execute *all phases* of *this subtree* first, and then execute (and suspend when timeout) all phases of the second subtree in whatever time remain. Then we never need to get the cost.

If that is impossible, I wonder whether we can use some heuristics. We all know a CircularProgressIndicator should be very lightweight, so is a ListView-scrolling (if using the ui.Image approach above). We may also learn from the history.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:15:32Z" retrieveTime="2022-10-17T11:45:49.046468">

> How does the ListVIew item handle sliding when there is no width and height information

If using the approach mentioned above, it will just be blank. But not blank whenever there is a scrolling! Because we know Flutter has some cache extent for ListViews, we can also capture those cached extents in our `ui.Image` snapshot. Then, only if the following happens, we will see blank:

1. The user scrolls so much that all cache extent are used up
2. Our heavy widgets are so heavy that it even does not finish one frame up to now

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:18:41Z" retrieveTime="2022-10-17T11:45:49.046468">

> How Fiber builds interruptible. It might be a little easier for a ListVIew, because its items are siblings. But what about parent-child nodes like Container?

As a very rough draft, I am considering `yield`. For example:

```dart
Iterable<void> performLayout() sync* {
  yield* myFirstChild.layout();
  some_computation_here;
  yield* mySecondChild.layout();
}
```

Each yield point is suspendable.

IIRC, Redux Saga https://redux-saga.js.org/docs/introduction/BeginnerTutorial/ uses something similar to this.

Have not digged into React Fiber's source code yet. Have you checked it, how does it implement it?

But as I am not an expert in Dart compiler implementation, I am not sure about the performance penalty. (Hope it to be tiny!)

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:31:44Z" retrieveTime="2022-10-17T11:45:49.046468">

A few pointers:

- We cannot use sync generators, they create code that is large and slow. 
- A good canonical case here would be something like https://github.com/flutter/flutter/blob/master/dev/benchmarks/macrobenchmarks/lib/src/list_text_layout.dart. This ends up being janky because layout gets expensive for all that text (on a lower end phone it can easily take 20-30+ms just to layout all the text there, and the ListTile is a little deceptive because Material introduces expense - this is the kind of thing we want to figure out how to break up "automatically").
- We should probably worry about prioritization of jobs until after we figure out how to sensibly budget and interrupt layout/painting/compositing. It doesn't matter what priority we'd want to give things if we can't do that, and it will probably be hard to come up with a good/fair prioritization scheme.


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:40:01Z" retrieveTime="2022-10-17T11:45:49.046468">

@dnfield Thanks for the ideas!

> how to sensibly budget and interrupt layout/painting/compositing.

Quick answer to budget: As suggested in my comments above, we may not need to budget things (unlike the keframe-like solution). We just run the high-priority subtree (one with animation) until it finishes, and then run low-priority heavy subtree until whenever timeouts.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:42:05Z" retrieveTime="2022-10-17T11:45:49.046468">

Animations might not ever finish.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:42:34Z" retrieveTime="2022-10-17T11:45:49.046468">

And you might be animating the entire screen, e.g. for a route transition

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:43:27Z" retrieveTime="2022-10-17T11:45:49.046468">

> Animations might not ever finish.

Well, I mean, run its build+layout+paint+raster fully instead of partially, not wait until there is no animations at all. For a CircularProgressIndicator it may take, say, <1ms. The rest 16.66-1=15.66ms will be given to low-priority subtree.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:44:23Z" retrieveTime="2022-10-17T11:45:49.046468">

> And you might be animating the entire screen, e.g. for a route transition

That sounds similar to the "a scrolling ListView" example above in https://github.com/flutter/flutter/issues/101227#issuecomment-1247625317. Just as mentioned there (and a little bit similar to https://github.com/flutter/flutter/pull/106621), we may take a snapshot of the heavy children, when the heavy widgets are rebuilding.

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:52:42Z" retrieveTime="2022-10-17T11:45:49.046468">

> Seems we do not need? We just blindly run whatever should be done next, and suspend when we are near 16ms.

Well, I think there should be a timer for how long the UI is currently built, since you also mentioned `near 16ms`, and the `remaining time`. I think it's easier (and that's what I'm going to try) if I just count the time spent on the framework. But as you say, the problem becomes more complicated when you consider the Raster thread.





</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T06:55:41Z" retrieveTime="2022-10-17T11:45:49.046468">

> Well, I think there should be a timer for how long the UI is currently built

I guess that is easy :) Maybe as simple as `DateTime.now()`, but probably there are something with higher precision etc.

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T07:08:13Z" retrieveTime="2022-10-17T11:45:49.046468">

> @Nayuta403 I have had similar thoughts before. The problem is, build phase is not the most costly one. There are layout and paint phase, etc, as well. What's worse, Flutter has C++ engine code which rasterizes and flush to the screen. That one can take a long time in some cases (for example, in my own app, when there is a ton of bezier curves). A widget may, for example, have very short build phase time but very long C++ rasterize time.

Yes, the timing of the statistical framework is not complicated, so I'm just trying to perform more tasks in a frame based on that time, regardless of Raster


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T07:10:21Z" retrieveTime="2022-10-17T11:45:49.046468">

> @Nayuta403 Yes, the timing of the statistical framework is not complicated, so I'm just trying to perform more tasks in a frame based on that time, regardless of Raster

Sorry I do not quite get it. Are you using history timing information to estimate future timing?

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T07:38:31Z" retrieveTime="2022-10-17T11:45:49.046468">

It's Keframe. I'm trying to count the time it takes to `build/layout/paint` item widgets so that each frame can be rendered as many times as possible (currently only one item per frame is rendered). 
(Am I making myself clear? (*￣︶￣))


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T07:43:51Z" retrieveTime="2022-10-17T11:45:49.046468">

@Nayuta403 Clear :)

So seems that it is based on history. Then what if different items have (very) different time needed? That happens frequently IMHO. For example, suppose we have a ListView of posts. Post 1 may be a simple sentence so it is fast. Post 2 may be a long rich text paragraph and complex Paths etc, so it is slow.

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T07:57:05Z" retrieveTime="2022-10-17T11:45:49.046468">

Yes, you are absolutely right, because now every task is setState() and only goes back to rendering the real widget on the next frame. One idea I have now is to make this task a real rendering task, similar to marking it as dirty and then executing drawFrame() to get the real time.

I can create an issue later to describe my thinking in detail and make the issue clearer  :>

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T08:00:57Z" retrieveTime="2022-10-17T11:45:49.046468">


> I can create an issue later to describe my thinking in detail and make the issue clearer :>

Looking forward to it :)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T09:39:44Z" retrieveTime="2022-10-17T11:45:49.046468">

#### More about "how to build suspendable/interruptable", given that sync generators are slow

Is it possible we create a `RenderSuspendable` RenderObject (and corresponding Suspendable widget) which does the following:

1. Users need to insert this widget into tree whenever they want suspendable. This may be reasonable given this spirit is similar to RepaintBoundary. And users will not need to insert too much, just insert at coarse subtrees. 
2. It behaves like a most naive proxy render box in normal cases.
3. When time is near used up, and when RenderSuspendable.layout is called, it will *not* call child.layout, but instead set a flag (say `needsLayoutLaterWhenPossible`) and directly return. As for the return value, it may return the last layout size or user-defined default size (similar to what keframe does in widget-build level). By doing this, ancestor render objects will be happy and finish its layout function very fast.
4. For a `RenderSuspendable` with `needsLayoutLaterWhenPossible=true`, when a new frame comes in, it will `this.markNeedsLayout()`, and thus get a chance to execute its `layout` method again in this new frame. If time is enough, it is done normally as in "2.", and the needsLayoutLaterWhenPossible is cleared; otherwise, it is done as in "3.".

Remark: May need a tweak a bit about `layout`'s caching mechanism.

Remark: RenderSuspendable's sub-tree will *not* be redundantly layouted more than once. For example, say we have a `Column` with two `Suspendable` children, the first one has done layout, and the second one does not because of timeout. Then, when the next frame comes, Suspendable 2 calls markNeedsLayout, and Column starts performLayout. Then Suspendable 1 *does* have layout() called. However, we should recognize it (possibly flutter caching already does so?), and no need to layout its child at all.

**Features**

* Solves the problem of "how to build suspendable/interruptable", without sync generators
* No need to modify existing render objects, only need to add a new one

**Potential problem**

Unnecessary (i.e. redundant) relayout will happen for ancestors of Suspendable, until meeting a relayout-boundary.

Not sure how large the penalty is. If we can give near enough relayout boundary, looks like it is no problem? In addition, if we wrap *all* expensive subtrees into Suspendables, then the rest may be quite cheap.

**How is layout / paint / rasterize related?**

Done one by one. Layout of *everything* will be firstly finished. Only after that, we start doing painting of everything. And then rasterizing.

**What about paint tree? layer tree? engine(c++) rasterizer?**

TBD, I guess will be similar to above. Looking forward to hearing some feedbacks about the approach for layout first!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T09:57:10Z" retrieveTime="2022-10-17T11:45:49.046468">

#### How can we paint UI onto screen, if we are in half-way of layout/paint/rasterize, and many nodes are dirty / half-way updated?

Basically I have two draft ideas:

Firstly, we may hack the Flutter engine. Let it keep the old content available until the new content is *fully* available.

Secondly, we may be able to solve it without big modifications to engine. We may just "take a screenshot" before starting the journey of heavy updating. For example, suppose we need 10 frames to fully build/layout/paint/rasterize this widget subtree. Then, we use the new `toImageSync()` to take a photo of it. Then, during the 10 frames, we can do anything to the render/layer/engineLayer trees, and whenever the parents let us to paint, we just canvas.drawImage() using that. After 10 frames when we are done, we will finally paint the new thing.

By the way, this also has a bonus about *predictable time consumption*. IMHO, the time of drawing (paint+rasterize+...) a `ui.Image` may be easily computed, given it is nothing but a rasterized image.

---

@dnfield Given that you implemented this great new `toImageSync` feature (https://github.com/flutter/engine/pull/33736), I have a question about its performance: 

In the solution above, instead of painting normally, we may have to convert child into `ui.Image` for each and every `paint` call.

In other words, in pseudo code:

```dart
class OurRenderObject {
  void paint() {
    // child.paint(); // cannot do this

    if (everything_is_not_dirty) {
      image = toImageSync(child_render_tree); // save a screenshot
    }

    // ...do some expensive work here if time is sufficient...

    canvas.drawImage(image);
  }
}
```

So, will this have performance penalty or not?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-15T14:41:50Z" retrieveTime="2022-10-17T11:45:49.046468">

Looking forward to some early feedbacks about the proposal :)

Maybe /cc @dnfield @JsouLiang @Nayuta403 @xanahopper (based on today's activity)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T00:57:12Z" retrieveTime="2022-10-17T11:45:49.046468">

P.S. I am starting to work on a prototype about smoothing the "layout" phase. Will report any progress I make :)

Code: https://github.com/fzyzcjy/flutter/tree/feat-smooth

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T04:06:27Z" retrieveTime="2022-10-17T11:45:49.046468">

### Progress: 62ms -> 22ms for 99th build time of `list_text_layout`, and its limitations

(Limitations is discussed in the last section of this comment)

The `list_text_layout` is still too fast on my old android, so I enlarged its scale (have more items in column, more text in each item, etc) a little bit. Code is seen in https://github.com/fzyzcjy/flutter/commit/857210213531e76b3eb5c256a8ef3599ed434703. This yields:

```
{
  "average_frame_build_time_millis": 2.8446626506024097,
  "90th_percentile_frame_build_time_millis": 1.213,
  "99th_percentile_frame_build_time_millis": 62.531,
  "worst_frame_build_time_millis": 63.101,
  "missed_frame_build_budget_count": 14,
  "average_frame_rasterizer_time_millis": 3.296915662650604,
  "90th_percentile_frame_rasterizer_time_millis": 8.09,
  "99th_percentile_frame_rasterizer_time_millis": 13.82,
  "worst_frame_rasterizer_time_millis": 15.178,
  "missed_frame_rasterizer_budget_count": 0,
  "frame_count": 249,
  "frame_rasterizer_count": 249,
  "new_gen_gc_count": 34,
  "old_gen_gc_count": 4,
  "frame_build_times": [
```

![image](https://user-images.githubusercontent.com/5236035/190553671-b44adef7-3cab-49db-95bc-45cfc15ad5a9.png)

Then, I implement a proof-of-concept Suspendable. Code is at https://github.com/fzyzcjy/flutter/commit/0babd5b6856bc799c9f369bce75aada7c10fcd0b. Code diff can be found in https://github.com/flutter/flutter/compare/master...fzyzcjy:flutter:feat-smooth?expand=1.

It yields:

```
{
  "average_frame_build_time_millis": 4.24028,
  "90th_percentile_frame_build_time_millis": 17.769,
  "99th_percentile_frame_build_time_millis": 22.235,
  "worst_frame_build_time_millis": 23.829,
  "missed_frame_build_budget_count": 41,
  "average_frame_rasterizer_time_millis": 3.9516548672566385,
  "90th_percentile_frame_rasterizer_time_millis": 8.949,
  "99th_percentile_frame_rasterizer_time_millis": 11.202,
  "worst_frame_rasterizer_time_millis": 11.604,
  "missed_frame_rasterizer_budget_count": 0,
  "frame_count": 225,
  "frame_rasterizer_count": 226,
  "new_gen_gc_count": 17,
  "old_gen_gc_count": 4,
```

![image](https://user-images.githubusercontent.com/5236035/190553863-5a373dcb-75ba-468d-8118-66e7a393070b.png)

---

### Limitations

This is just proof-of-concept and is very naive.

* It only suspends the layout and build phase. (The build phase is wrapped inside layout phase by adding a LayoutBuilder.) Indeed, it does not suspend the paint or raster phase, which should be done in future work.
* It paints nothing (i.e. do not call child.paint) if a Suspendable is suspending. This will destroy the layer tree and C++ engine layer trees, making performance much worse. We should address this problem later, possibly by keeping the layer tree not used but not removed.
* It lets the whole ancestors (up until relayout-boundary) to relayout in each frame.
* Overhead will become non-neglectable, if we want it to run in 60fps. In other words, if we want each frame to be under 16ms, looks like we will only have <10ms for handling the suspendable widgets (rough estimate, but anyway numbers differ on different phones). Then, the price of 60fps smooth animation is that, the suspendable needs longer time to be loaded.
* The current implementation does not run suspendable layouts *last*. Instead, they are run inside non-suspendable layout. Thus, we have to set a "earlier" deadline (e.g. 12ms, instead of 16.6ms in the example above), and hope that the remaining job will finish quick enough.
* [Element.performLayout](https://api.flutter.dev/flutter/rendering/RenderSliverScrollingPersistentHeader/performLayout.html) says, "In implementing this function, you must call layout on each of your children". But, when implementing Suspendable, we have to violate this. We will face troubles, or just minor changes are enough?
* If a child under Suspendable mark itself as needed to relayout/rebuild, and there is relayout boundary between that child and Suspendable, then the suspending mechanism will not work at all.
* Originally all code (implicitly) assume that, when a frame ends, build/didUpdateWidget has been called. But now this no longer holds. That will make a ton of widget fail to work, including those inside flutter framework, and many external packages. For example, those who assume this inside their addPostFrameCallback.
* The demo does not yet provide any animations (e.g. a CircularProgressIndicator), so by merely looking at the screen, we cannot see it becomes much smoother ;)

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T06:49:08Z" retrieveTime="2022-10-17T11:45:49.046468">

Furthermore, I think should we able to break the Build call if the Widget is complex and the Widget Build call is too deep and stalling?

@fzyzcjy 


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T07:15:11Z" retrieveTime="2022-10-17T11:45:49.046468">

### New idea: Dual isolates

(This comment is updated)

#### Advantages

The main goal is similar: No matter how heavy your widget build/layout/... is, animations/gestures should be 60fps.

It does not require existing Flutter/Dart code to accept new assumptions. For example, in the old proposal, the `layout` may *not* be called within a frame, and thus `build` will also not be called. This may violate many existing code. For example, `addPostFrameCallback` may assume build is done when post-frame.

On the contrary, the "Dual isolates" solution will not have those assumptions at all. It seems **not to break existing explicit or implicit assumptions about the code**. Except that it will make Dart isolate "freeze" once in a while - but that should not be a problem, since we are all happy with stop-the-world GC and OS's suspending a thread.

In addition, it should have much lower overhead, indeed almost zero. No wasted build/layout happens (unlike RenderSuspendable approach). No unnecessary tree destory and recreate happens.

#### Background

The approach above, with the minimal sample in https://github.com/flutter/flutter/issues/101227#issuecomment-1248894781, has many known problems which I am not sure whether can all be overcome. I will probably also experiment further on that path as well. At the same time, I find out a new approach without most problems above.

I am not an expert in `flutter/engine`, so please correct me if I am wrong!

#### Design

Originally, IMHO we have a UI thread, which runs both C++ code and Dart main isolate code. Now, we have three (but no worries, they will not be parallel most of the time!):

* C++ UI thread.
* Dart main isolate: Run everything you know, i.e. the heavy build/layout/paint/.... Say it takes 2 frames to finish.
* Dart sidecar isolate: Run CircularProgressIndicator, or ShiftTheChild(for scrolling ListView, to be explained below).

An UML diagram is attached below (best read with text explanations here).

Here is what happens when a vsync comes in:

* C++ ui thread receives the vsync. In the old days, it will call dart's DrawFrame. But now, it will set up a timer for a bit less than ~16.67ms (say 15ms), pause self thread, and call Dart main isolate's DrawFrame.
* Dart main isolate's DrawFrame starts running. It runs build/layout happily.
* At 15ms, timer wakes up C++ ui thread. C++ ui thread then immediately "pause" the dart main isolate. This is done by "safepoints". In other words, we insert `safepoint()` call to `layout()` function of Dart RenderObjects. And that function is a native function reading, say, a mutex lock. When C++ ui thread wants to pause the dart main isolate, it simply acquire the mutex. When Dart goes to the next safepoint() call, it will simply be pause there forever waiting to acquire the mutex (until next frame indeed).
* C++ ui thread calls sidecar isolate to compute the whole build/layout/paint procedure. This is done serially now for simplicity, but should be easily parallizable with some locks.
* Sidecar Dart code is a bit different from the traditional widget/renderobject/layers. Instead, it knows which EngineLayer it owns, and only mutates it. For example, for a CircularProgressIndicator in sidecar, it will know it owns a DisplayListLayer, and only modify pictures in it, without touching other layers. For a ShiftTheChild, it owns a OffsetLayer and modifies its offset.
* Now go back to our C++ ui thread. We will simply utilize the current engine layer tree in C++, and the rest is the same, such as giving data to rasterizer thread and render to the screen.

This is not the end of story - notice our main isolate is still computing some layout and is hanging. Now suppose 2nd vsync comes in.

* Again, C++ ui thread receives vsync. It notices there is still remaining job in main isolate. Then it just resume the main isolate, without telling it anything about the second frame. Thus, in the eyes of main isolate, it will think the whole phone just "freezed" for a few milliseconds without other problems, and will happily continue build/layout/etc.
* Suppose the heavy job of the main isolate is finally finished in this frame. Then, it will do painting. In other words, it will mutate the Layer tree in C++ code. We deliberately put no safepoint() during painting, so the C++ layer tree will either be non-mutated or fully-mutated without intermediate case.
* The rest is similar to the first frame, except that our engine layer tree is updated to the new one.

#### Further improvements

* sidecar isolate should be executed concurrently
* main isolate should also be executed concurrently, with locks protecting critical regions such as mutating the engine layer tree. But otherwise, it should run freely. By doing this, we are guaranteed that, we can let main isolate run using almost a full cpu core. On the contrary, the "RenderSuspendable" approach above will only give, say, 10.67ms out of 16.67ms for heavy widget build/layout, because it need (say) 6ms to paint/rasterize existing things.

#### What is `ShiftTheChild`

I want to solve the problem of "ListView scrolling". In other words, when scrolling a ListView, the widget build/layout may be arbitrary heavy, while we should get 60fps.

Thus, let us do the following:

```dart
ParentWidgets(
  child: ShiftTheChild(
    child: ListView.builder( ... )
  )
)
```

Suppose ListView subtree takes 10 frames to rebuild/layout/etc, and suppose the user is scrolling it. Then, during the 10 frames, ShiftTheChild will receive data packets about user dragging and perform a shift (i.e. OffsetLayer's offset) to its child content. ShiftTheChild will be in the sidecar isolate.

P.S. It may not even be a widget or RenderObject, but may be built on some other lower level primitives mutating corresponding C++ engine Layer. But surely we can wrap those primitives and maybe create a RenderSidecar or something new, that should not be a problem.

#### Minimal example

I plan not to implement sidecar isolate in the minimal example. Instead, just create a C++ function that shifts an OffsetLayer in each frame, as if a sidecar isolate is doing so. This is because the sidecar isolate is nontrivial engineering work but is not the core problem.

---

#### UML Diagram

![UML](https://user-images.githubusercontent.com/5236035/190575625-cac7fa73-0b80-4808-8414-130446ad8884.png)


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T07:15:58Z" retrieveTime="2022-10-17T11:45:49.046468">

@JsouLiang For the "RenderSuspendable" proposal, I guess we can have nested ones. For the "Isolates" proposal just now, I guess we do not have this problem - the main isolate will be paused at *any* safepoint, i.e. *any* layout function.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T07:20:48Z" retrieveTime="2022-10-17T11:45:49.046468">

@dnfield @JsouLiang @Nayuta403 (and other engine masters)

For the new proposal, I hope to see some feedback... Since I am not an expert in `flutter/engine` (and few materials are about it on the internet). Thus:

1. Is there any suggested materials (docs/articles/...) to understand the engine? How do you learn the engine?
2. Does my proposal above looks OK?

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T09:23:36Z" retrieveTime="2022-10-17T11:45:49.046468">

> @JsouLiang For the "RenderSuspendable" proposal, I guess we can have nested ones. For the "Isolates" proposal just now, I guess we do not have this problem - the main isolate will be paused at _any_ safepoint, i.e. _any_ layout function.

multiple isolates is one of my optimize and working in progress, the key to this is some build/layout callback function/method should not be called in non-main isolate, or just serialize/deseralize build/layout request and response to another isolate like a local RPC service.
But! Multiple isolates may agains Flutter's principle, I don't sure whether it can be merged.

(Dude, you are really high-producing and I'm reading your new comments try to catch up

And for more, I may offer you some complex card widget case for benchmark.

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T09:59:40Z" retrieveTime="2022-10-17T11:45:49.046468">

For this Suspendable render, we may introduce structure like Fiber, I think it is [Threaded tree](https://en.wikipedia.org/wiki/Threaded_binary_tree).

First thing to drawing a frame including heavy/suspendable part is transform tree to a list (or just a threaded tree)

![image](https://user-images.githubusercontent.com/2241197/190613080-dfaa31f1-82ca-4c8e-8fb1-ac68fc4cada2.png)

Render task 5 and 6 should and can be suspended at any place in it. (What if a widget/node cost timeout?)

we can tell from figure that suspendable is contagious, content in suspendable cannot be non-suspendable.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T10:27:32Z" retrieveTime="2022-10-17T11:45:49.046468">

@xanahopper 

> multiple isolates is one of my optimize and working in progress

Looks interesting, could you please share the link? I have checked your github but seems cannot find anything. (All my Flutter work are done open-source and can be found at my github).

> the key to this is some build/layout callback function/method should not be called in non-main isolate, or just serialize/deseralize build/layout request and response to another isolate like a local RPC service.

Could you please provide an example? Thanks

Btw, my solution does not use non-main isolate with callbacks :) Indeed, I only put CircularProgressIndicator and ShiftTheChild and things like that there. No normal user code should be done in the sidecar isolate, because otherwise it is quite unfriendly to the users (the sidecar isolate has no memory sharing w/ the main isolate).

So I hope it is not a blocker!

> But! Multiple isolates may agains Flutter's principle, I don't sure whether it can be merged.

Could you please elaborate a little bit more?

My solution is still mainly single-isolate, and the sidecar isolate (as mentioned above) is just used very limitedly to support animations.

In addition, my multi-thread is still mostly serialized instead of parallel running. There are multiple threads, simply because I want to suspend/pause one thread easily.

> Dude, you are really high-producing and I'm reading your new comments try to catch up

Haha take your time! It takes me a day thinking and trying all these things :)

> And for more, I may offer you some complex card widget case for benchmark.

Sure, looking forward to that. Btw I also have very complex cases for my own app, but I decide to start from the simple - you know, one of the fundamental rules in software engineering.



</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T10:35:09Z" retrieveTime="2022-10-17T11:45:49.046468">

> @xanahopper's comment in https://github.com/flutter/flutter/issues/101227#issuecomment-1249172293

If I understand correctly, the figure is a bit like a extended version of my prototype https://github.com/flutter/flutter/issues/101227#issuecomment-1248894781 above.

The question is, how are you going to transform a tree to a (suspendable) list - In other words, for example, how to make subtree rooted at 5 become a list that *can be paused*?

I have proposed using `yield` in `performLayout` but @dnfield mentioned it is very slow. Given that your suspendable widgets are contagious, we cannot use yield at all (otherwise we will be using it in a big subtree).

Then in my prototype above I decide to let a Suspendable return zero size when it is near timeout (note: different from your figure, but the problem to solve is similar). But such approach seems not possible for your proposal.

This is solved very easily with my "Dual isolates" proposal. It just call `safepoint()` in every RenderObject's `layout()`. Then, whenever the C++ code wants to suspend Dart, C++ will just let `safepoint()` hang (probably by occupying a mutex). Then Dart code is just hang there, without doing anything, without feeling anything. In Dart code's view it is like a stop-the-world GC indeed.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T10:43:25Z" retrieveTime="2022-10-17T11:45:49.046468">

@wangying3426 https://github.com/flutter/flutter/issues/101227#issuecomment-1240156979

> Any update please? We are also interested in this feature.

Btw I forget to mention you (too above in the comments). Yes, now I have many updates :)

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T11:08:52Z" retrieveTime="2022-10-17T11:45:49.046468">

Multiple isolates and optimize with it is before the specification phase, just for you known that we both have the same idea that I and my colleagues are working on it. for very early part we think that this way may need modify engine or even the Dart VM.

Last time we coming with a issue [#110063](https://github.com/flutter/flutter/issues/110063) and got a refuse with tough attitude.

## Transform

When we need _build_ a Widget, we must already got a widget or state(element), that means we have a _factory_ for children widgets.
All Flutter's build (as long as other declaration UI) is a function call, just like

> UI = f(g(h(state)))

We just change this to 

> ui1 = h(state)
> ui2 = g(ui1)
> UI = f(ui2)

wrap ever build into a node/task and change all that to a chain list. In practice, we can use a deque to collect deeper call.

### Widget tree build:
1. Got a node to build from queue, we dont know whether it will be a leaf node.
2. Execute node's build, add all children to queue.
3. Add executed node to a deque tail.
4. Repeat goto 1

### Element & RO tree build
Because elements generally need children to be ready, so we have to produce it from leaf.
1. Take a node from tail of executed node deque(this will like a stack)
2. Produce Element/RenderObject
3. repeat

It just like traversal a tree without recursion, so we can suspend and resume at any iteration of traversal.
this is a prototype of pseudo code, hope it help.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T11:42:29Z" retrieveTime="2022-10-17T11:45:49.046468">

@xanahopper 

> Multiple isolates and optimize with it is before the specification phase, just for you known that we both have the same idea that I and my colleagues are working on it. for very early part we think that this way may need modify engine or even the Dart VM.
Last time we coming with a issue https://github.com/flutter/flutter/issues/110063 and got a refuse with tough attitude.

I see. Willing to collaborate to make it into reality as soon as possible!

I looked at #110063 now. If I understand correctly, seems that @jonahwilliams refuses because "Splitting the UI thread work into multiple theads is infeasible for several reasons", such as "a single thread means that newspace allocations don't need any locking". However, my proposal above deliberately avoids these problem. In my case, the c++ ui thread is sleeping while dart main isolate is running, and (if flutter does not like multi concurrent isolates) the thread and main isolate can also be sleeping while dart sidecar isolate is running. So, we are still running single isolate, and no lock is needed at all!

In short, I am not using multi threading. Instead, all threads are there only to implement suspending.

> or even the Dart VM.

This inspire me of something: If we can implement a suspend mechanism in Dart VM, maybe we do not need that safepoint + one extra thread approach.

> Widget tree build

Fully understand now :) That should be very workable, just like React Fiber does.

> Element & RO tree build
so we have to produce it from leaf
Produce Element/RenderObject

Sorry I do not get it. We are not going to produce RenderObjects, but (most of the time) *modify* (update) them. For example, say you have a RenderPadding. Then we will only modify its padding field and markNeedsRelayout, instead of throwing away the old padding and create a new one.

Most importantly, how can we get the BoxConstraints (suppose we are dealing with RenderBox)? For example, when we are `layout()` for a leaf, we must know the BoxConstraints its parent wants to give it. But the parent is not yet `layout`ed.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-16T11:46:14Z" retrieveTime="2022-10-17T11:45:49.046468">

@xanahopper In addition, I have mentioned many limitations of the suspendable tree traversal in https://github.com/flutter/flutter/issues/101227#issuecomment-1248894781 (see last section there). Looking forward to see some solutions about it!

For example, a big problem: Originally all code (implicitly) assume that, when a frame ends, build/didUpdateWidget has been called. But now this no longer holds. That will make a ton of widget fail to work, including those inside flutter framework, and many external packages. For example, those who assume this inside their addPostFrameCallback.

---

**Update**: More problems are added to that comment. For example, "If a child under Suspendable mark itself as needed to relayout/rebuild, and there is relayout boundary between that child and Suspendable, then the suspending mechanism will not work at all."

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-17T00:41:55Z" retrieveTime="2022-10-17T11:45:49.046468">

**Update**: I am thinking whether we can remove the need of new threads in https://github.com/flutter/flutter/issues/101227#issuecomment-1249005541. If we can pause a Dart isolate without needing new threads, we can remove those threads.

Details can be found in:

* https://github.com/dart-lang/sdk/issues/49981

---

**Update**: I am trying to use the spirit of stackful coroutines to implement it.

I do get stuck. We have a ton of callbacks from C++ calling into Dart, such as when the image data has been loaded successfully. If the dart main isolate is freezed (either by stackful coroutine, or by a normal thread with mutex), C++ code cannot call Dart at all. Delaying those calls also seem very troublesome because of resource deallocation problems.

---

**Update**: Search a bit on Discord history and here is a summary.

* [cannot find earlier discussions]
* 20220111-20220114, hackers-framework, mentioned in [20220520](https://discord.com/channels/608014603317936148/608014603317936150/976924283685199902) by hixie, https://discord.com/channels/608014603317936148/608021234516754444/930241489374683157
* [not found] "Hixie tried an experiment that didn't seem to get to a working point", [said here](https://discord.com/channels/608014603317936148/613398126367211520/977090864813846548), but I cannot find the experiment code
* 20220520, "general" https://discord.com/channels/608014603317936148/608014603317936150/977074969542553600
* 20220520, "hackers-performance-", with a pointer to "general" as previous discussions, https://discord.com/channels/608014603317936148/613398126367211520/977109431408009317

Well I see some parts of my experiment above has already been discussed there

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-17T08:02:13Z" retrieveTime="2022-10-17T11:45:49.046468">

### Rethinking (overcoming) the shortcomings of [the `Suspendable` "62ms->22ms" experiment](https://github.com/flutter/flutter/issues/101227#issuecomment-1248894781)

The quoted text are the shortcomings mentioned in the experiment, and black text are my re-thoughts.

> It only suspends the layout and build phase. (The build phase is wrapped inside layout phase by adding a LayoutBuilder.) Indeed, it does not suspend the paint or raster phase, which should be done in future work.

Given the [discord discussions](https://github.com/flutter/flutter/issues/101227#issuecomment-1249961627) among @Hixie and @dnfield etc, seems build/layout is mostly the expensive one. So paint or raster may not needed to be considered at the highest priority, at least not implemented in this issue and may defer to future work.

> It paints nothing (i.e. do not call child.paint) if a Suspendable is suspending. This will destroy the layer tree and C++ engine layer trees, making performance much worse. We should address this problem later, possibly by keeping the layer tree not used but not removed.

This is not a problem if we only consider the jank caused by widget creation/deletion (like going to a new page or ListView scroll to make a new widget visible).

> It lets the whole ancestors (up until relayout-boundary) to relayout in each frame.

But I guess this should not be a big problem in real world, because we should keep the heavy things in Suspendable subtrees and keep the ancestors simple.

> Overhead will become non-neglectable, if we want it to run in 60fps. In other words, if we want each frame to be under 16ms, looks like we will only have <10ms for handling the suspendable widgets (rough estimate, but anyway numbers differ on different phones). Then, the price of 60fps smooth animation is that, the suspendable needs longer time to be loaded.

However, if we want to keep it single-threaded (single isolate), as #110063 (multi isolate) is refused, this is the price we have to pay.

> If a child under Suspendable mark itself as needed to relayout/rebuild, and there is relayout boundary between that child and Suspendable, then the suspending mechanism will not work at all.

We should add more Suspendables if we observe such situation. More specifically, we should add a Suspendable (or, if using `keframe`-like solution, the FrameSeparateWidget) near that specific widget. Then, this is no longer a problem.

p.s. This is not a problem if we only consider the jank caused by widget creation/deletion (like going to a new page or ListView scroll to make a new widget visible).

> The current implementation does not run suspendable layouts *last*. Instead, they are run inside non-suspendable layout. Thus, we have to set a "earlier" deadline (e.g. 12ms, instead of 16.6ms in the example above), and hope that the remaining job will finish quick enough.

Not a critical problem indeed.

> [Element.performLayout](https://api.flutter.dev/flutter/rendering/RenderSliverScrollingPersistentHeader/performLayout.html) says, "In implementing this function, you must call layout on each of your children". But, when implementing Suspendable, we have to violate this. We will face troubles, or just minor changes are enough?

Will see whether it is a problem after doing more experiments.

> Originally all code (implicitly) assume that, when a frame ends, build/didUpdateWidget has been called. But now this no longer holds. That will make a ton of widget fail to work, including those inside flutter framework, and many external packages. For example, those who assume this inside their addPostFrameCallback.

Since this feature is completely opt-in (you have to manually put the Suspendable widget into your tree), users may be able to migrate their widgets when they decide to use Suspendable.

The problem is, it may take efforts to migrate each and every widget, and it also takes time to migrate all inside flutter framework itself. Luckily, it is opt-in, so we can do it steadily and slowly, just like how we migrate to `Material 3` theme (it has been months but still not finished).

Many code may migrate smoothly without any problem. (For example, I personally used MobX for my Flutter app, which has reactive states and automatic rebuild, so I seldom touch the raw frame callbacks. For many widgets in flutter framework we can reason about it in our heads and they seem ok as well.)

We may need to provide some information to the users, indeed `State`s or `BulidContext`s, telling them they have been suspended. A simple method may be adding a field to `State/BuildContext`, or use a `InheritedWidget`. I may defer this work after seeing what info a real widget wants when migrating real widgets.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-17T11:46:14Z" retrieveTime="2022-10-17T11:45:49.046468">

### Enhance `keframe`: Now seems it can build/layout as many items as possible until time is up, i.e. have strategy similar to the ["layout" proposal](https://github.com/flutter/flutter/issues/101227#issuecomment-1248894781) above

@Nayuta403 

#### The problem

As is discussed in https://github.com/LianjiaTech/keframe/issues/12#issuecomment-1238873216 and (IIRC) earlier comments, `keframe` now blindly builds one widget per frame, even if it can build (for example) 5 widgets. This makes the UI need much longer time to display fully. In addition, it always lag by one frame, because it uses setState in a addPostFrameCallback to update its widget.

#### The solution

IMHO, the following suggestion can avoid the problems above. Now it can build/layout as many items as possible until time is up, i.e. have strategy similar to the "layout" proposal above. Please correct me if I am wrong!

As can be seen in the code example below, the key point is a `LayoutBuilder` wrapped as parent of `FrameSeparateWidget`. By doing so, we ensure that the build *and layout* phase of widgets prior to the current widget has already been done. Now, FrameSeparateWidget can do a simple decision in its `build` method - if time is sufficient just return new child, otherwise return the old one and rebuild in the next frame.

By the way, this is partially equivalent to the "layout" proposal because of the following: IMHO, the `builder` callback inside a `LayoutBuilder` is called within `performLayout`. Therefore, the `build` of the child widget is strongly related to the `layout` of the LayoutBuilder render object. Then, I can partially migrate the idea in the "layout" proposal (where I hacked the performLayout) to this case (where I hack the build).

#### Full code example and output

The dummy `timeRemain` simulates the real world where we may have (e.g.) 16ms for each frame.

<details>

```dart

// ignore_for_file: avoid_print, no_runtimetype_tostring

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter_test/flutter_test.dart';

late int timeRemain;

void main() {
  testWidgets('example', (tester) async {
    print('frame #1');
    timeRemain = 3;
    await tester.pumpWidget(MaterialApp(
      home: Column(
        children: [
          for (var i = 0; i < 5; ++i)
            LayoutBuilder(
              builder: (_, __) => FrameSeparateWidget(
                name: '$i',
                child: i.isOdd ? SlowBuildWidget(name: '$i') : SlowLayoutWidget(name: '$i'),
              ),
            ),
        ],
      ),
    ));

    print('frame #2');
    timeRemain = 3;
    await tester.pump();

    print('frame #3');
    timeRemain = 3;
    await tester.pump();
  });
}

// the `keframe` one
class FrameSeparateWidget extends StatefulWidget {
  final String name;
  final Widget child;

  const FrameSeparateWidget({super.key, required this.child, required this.name});

  @override
  State<FrameSeparateWidget> createState() => _FrameSeparateWidgetState();
}

class _FrameSeparateWidgetState extends State<FrameSeparateWidget> {
  @override
  Widget build(BuildContext context) {
    if (timeRemain > 0) {
      print('$runtimeType#${widget.name} build: time is ok, give normal child');
      return widget.child;
    } else {
      print('$runtimeType#${widget.name} build: time is up, give dummy');
      SchedulerBinding.instance.addPostFrameCallback((_) => setState(() {}));
      return Container();
    }
  }
}

class SlowBuildWidget extends StatelessWidget {
  final String name;

  const SlowBuildWidget({super.key, required this.name});

  @override
  Widget build(BuildContext context) {
    print('$runtimeType#$name simulates slow build (timeRemain: $timeRemain -> ${timeRemain - 1})');
    timeRemain--;
    return Container();
  }
}

class SlowLayoutWidget extends SingleChildRenderObjectWidget {
  final String name;

  const SlowLayoutWidget({super.key, super.child, required this.name});

  @override
  RenderSlowLayout createRenderObject(BuildContext context) => RenderSlowLayout(name: name);

  @override
  void updateRenderObject(BuildContext context, RenderSlowLayout renderObject) => renderObject.name = name;
}

class RenderSlowLayout extends RenderProxyBox {
  RenderSlowLayout({RenderBox? child, required this.name}) : super(child);

  String name;

  @override
  void performLayout() {
    super.performLayout();
    print('$runtimeType#$name simulates slow layout (timeRemain: $timeRemain -> ${timeRemain - 1})');
    timeRemain--;
  }
}
```

outputs

```shell
frame #1
_FrameSeparateWidgetState#0 build: time is ok, give normal child
RenderSlowLayout#0 simulates slow layout (timeRemain: 3 -> 2)
_FrameSeparateWidgetState#1 build: time is ok, give normal child
SlowBuildWidget#1 simulates slow build (timeRemain: 2 -> 1)
_FrameSeparateWidgetState#2 build: time is ok, give normal child
RenderSlowLayout#2 simulates slow layout (timeRemain: 1 -> 0)
_FrameSeparateWidgetState#3 build: time is up, give dummy
_FrameSeparateWidgetState#4 build: time is up, give dummy
frame #2
_FrameSeparateWidgetState#3 build: time is ok, give normal child
SlowBuildWidget#3 simulates slow build (timeRemain: 3 -> 2)
_FrameSeparateWidgetState#4 build: time is ok, give normal child
RenderSlowLayout#4 simulates slow layout (timeRemain: 2 -> 1)
frame #3
```

</details>

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-17T14:35:35Z" retrieveTime="2022-10-17T11:45:49.046468">

@Nayuta403 If you are interested, I can try to make it a full library. Given that it is based on keframe's idea (hack widget build), but at the same time it is quite different from the existing implementation (do not use addPostFrameCallback and use the LayoutBuilder hack), I am not sure whether I should make a PR to keframe, or I should create a separate lib by myself (and mention keframe)?

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-17T16:22:11Z" retrieveTime="2022-10-17T11:45:49.046468">

@fzyzcjy  Hi man, you are very thoughtful and full of passion, thank you for your thoughts. Recently I have been busy with work.I want to first communicate with you about Keframe idea and then follow up your discussion.

>As can be seen in the code example below, the key point is a LayoutBuilder wrapped as parent of FrameSeparateWidget.  By doing so, we ensure that the build and layout phase of widgets prior to the current widget has already been done.

👍 👍   Your idea is great, we can hit the timer at the beginning of a frame and it seems to calculate the `timeRemian`. If you don't mind, I think you can create a branch/PR in KeFrame for discussion (I've given you a Write access) because there's some basic mechanics in there and a ready-made example in there.

> In addition, it always lag by one frame, because it uses setState in a addPostFrameCallback to update its widget.

I think this will not happen, because KeFrame calls `addPostTimeCallBack` during initState (i.e.https://github.com/flutter/flutter/blob/5816d20b86b95205c40921fa91ee3434b9c97ac6/packages/flutter/lib/src/scheduler/binding.dart#L1197-L1201) and _postFrameCallbacks call after `_persistentCallbacks` is finished (i.e.
https://github.com/flutter/flutter/blob/5816d20b86b95205c40921fa91ee3434b9c97ac6/packages/flutter/lib/src/scheduler/binding.dart#L1203-L1210), They're both in the `handleDrawFrame` method, so I think they're still in the same frame.

Ps: I actually think Fiber and Keframe will end up with similar results, but Keframe will work within the existing framework and won't require a lot of changes to the framework and engine. I think we can contribute it to the flutter after we've optimized it, like nested in a ListView or a Column or something, and open it with flags, like a RepaintBoundary.







 




</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-17T23:12:10Z" retrieveTime="2022-10-17T11:45:49.046468">

@Nayuta403 You are welcome!

> we can hit the timer at the beginning of a frame and it seems to calculate the timeRemian

Yes, just like my "layout" demo, which I recorded when the frame begins.

> In addition, it always lag by one frame, ... I think this will not happen

Well yes the function call is in the same frame; but indeed, if I understand correctly, the *build* will lag one frame. Consider the simplest example, where we are building a new widget tree (thus initState) with a child. Then, in frame 1, FrameSeparateWidget has initState and build called. But it is only at the post-frame callback phase that FrameSeparateWidget.result is filled with the real child. So it is only at frame 2 that FrameSeparateWidget really renders the child onto the screen.

> Ps: I actually think Fiber and Keframe will end up with similar results, but Keframe will work within the existing framework and won't require a lot of changes to the framework and engine. I think we can contribute it to the flutter after we've optimized it, like nested in a ListView or a Column or something, and open it with flags, like a RepaintBoundary.

That looks interesting, and I love to contribute to Flutter :) But I am worried whether Flutter will accept such widgets that can live in thirdparty packages. On the contrary, if we need to modify the framework and it has to be integrated with the framework, then surely we need to put it into flutter framework.

> create a branch/PR in KeFrame for discussion (I've given you a Write access) 

Thanks for your invitation (I see it). However, I realize keframe is under `LianJia`, a commercial company. It is not a person (e.g. you), a nonprofit organization (e.g. the flutter organization, the llvm org, the mobx org), a company known to have a ton of open source contributions (e.g. google), or something like that. So I am very sorry I cannot join it. But anyway, all my work will be open-sourced, and under license like MIT, so everyone can use it!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-17T23:33:32Z" retrieveTime="2022-10-17T11:45:49.046468">

@Nayuta403 A bit more explanation: Why we do not need to worry about "the child subtree build&layout for a FrameSeparateWidget is so long that it makes everything slow"?

Because if that is the case, we can wrap several FrameSeparateWidget in the heavy parts of that subtree. Then, because each (new version I proposed yesterday) FrameSeparateWidget builds normally if not timeout, it will behave normally if time is ok; on the contrary, as long as time is up, subtree will pause to build. By doing this, we can ensure every FrameSeparateWidget takes moderate time length (say, 1ms), and there is no such case as one FrameSeparateWidget taking (e.g.) 100ms so everything is jank.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-18T04:11:00Z" retrieveTime="2022-10-17T11:45:49.046468">

**Update:** Some experiments here using the new implementation ([proposed here](https://github.com/flutter/flutter/issues/101227#issuecomment-1250056634)).

https://github.com/fzyzcjy/flutter_smooth

Btw I find that performance boost varies a lot when considering different experiments.

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-18T16:05:22Z" retrieveTime="2022-10-17T11:45:49.046468">

> But anyway, all my work will be open-sourced, and under license like MIT, so everyone can use it!

Yes, I was negligent. `Lianjia` is the company I used to work for. Just because this project is completed by me and has a certain number of users, I am still maintaining it personally. You are absolutely right, I also wish we had some open-sourced work available to everyone.  We can work on your project https://github.com/fzyzcjy/flutter_smooth

> A bit more explanation: Why we do not need to worry about "the child subtree build&layout for a FrameSeparateWidget is so long that it makes everything slow"?

Yes, I can understand that. For the subtree to time out, we can delay the build again by nesting the FrameSeparateWidget, which I've used before. I think from this point of view, all widget builds are interruptible, this Fiber-like mechanism.  I have a crazy idea that if we add a `placholder` property to all widget(Not all, we can add this property to some base class), we will build the `placholder` if the frame `timeRemain` time is 0. Then the jank will never happen ! HHHHH

> Update: Some experiments here using the new implementation.

I like your new implementation, which seems to have solved the problem we mentioned earlier by laying out as many widgets as possible in each frame. I think there may be some details that need to be added ：
* Whether other lifecycle states should be considered for `_SmoothState`, such as `didUpdateWidget` or `onDispose`. For example, I encountered an error in keframe when setState was called from outside because `result` was cached in State. If the `widget.child` is changed externally so that it does not work (It doesn't look like it's going to happen because you're using widget.child directly in build, but I think you might need to think about it when using State, I can add a https://github.com/LianjiaTech/keframe/blob/master/example/lib/page/complex_list_example.dart in your example)
* In your example, the height of the item is 24. But for the list, many times we don't know the width and height at code time, and jitter will occur when the placeholder and the actual list are not the same width and height.(because placeholder becomes item, Causing sibling layout changes). like this [example](https://github.com/LianjiaTech/keframe/blob/master/example/lib/page/opt/list_opt_example2.dart) in keframe. I did this by using `SizeCacheWidget` to cache the width and height of the item and force it to the placeholder so that it would not shake the second time the item was displayed. (You can't avoid it the first time, because the Item doesn't have a layout.) Do you have any other ideas?


> On the contrary, if we need to modify the framework and it has to be integrated with the framework, then surely we need to put it into flutter framework.

Yes, I think if we do it well enough, we can communicate with the Flutter Team and submit it to the Flutter Framework.  I communicated with @dnfield  a long time ago and he was also interested in it. [discord](https://discord.com/channels/608014603317936148/613398126367211520/977268943238602782)
 If we want to commit to Flutter Framework , what is the value of `kTimeThreshold`? Since we are only counting the build/layout time now, using 16.7 doesn't seem particularly appropriate, and for 120HZ devices, this value should be 16.7/2 ms

How do you think about it?







</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-18T23:03:56Z" retrieveTime="2022-10-17T11:45:49.046468">

> Yes, I was negligent. Lianjia is the company I used to work for. Just because this project is completed by me and has a certain number of users, I am still maintaining it personally. You are absolutely right, I also wish we had some open-sourced work available to everyone. We can work on your project https://github.com/fzyzcjy/flutter_smooth

Sure! Looking forward to collaborations :)

>  I have a crazy idea that if we add a placholder property to all widget(Not all, we can add this property to some base class), we will build the placholder if the frame timeRemain time is 0. Then the jank will never happen ! HHHHH

Haha that is really a crazy idea! The problem is overhead will be very big though :)

> Whether other lifecycle states should be considered for _SmoothState, such as...

Agree! At least we should add a test in our code, asserting its correctness

> I did this by using SizeCacheWidget

I think that is a pretty smart idea, and has not found other solutions yet. If you approve I will add things similar to that into the codebase. The idea will be the same, while implementation will differ slightly (e.g. use a InheritedWidget + StatefulWidget + controller).

> Yes, I think if we do it well enough, we can communicate with the Flutter Team and submit it to the Flutter Framework. I communicated with @dnfield a long time ago and he was also interested in it. [discord](https://discord.com/channels/608014603317936148/613398126367211520/977268943238602782)

Totally agree. (Btw I have searched through the history a few days ago: https://github.com/flutter/flutter/issues/101227#issuecomment-1249961627)

> If we want to commit to Flutter Framework , what is the value of kTimeThreshold? Since we are only counting the build/layout time now, using 16.7 doesn't seem particularly appropriate, and for 120HZ devices, this value should be 16.7/2 ms

The 120hz should be simple since we can detect what frequency we are under.

The problem is "we are only counting the build/layout time now". 

Btw, I realized that, for a scrolling list, the "finalizing" phase also takes time. Let alone the paint/compositing phase we all have known.

They (paint/compositing/finalizing) each take a little of time, but when accumulated, it is non-neglectible for that 16ms.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-18T23:09:40Z" retrieveTime="2022-10-17T11:45:49.046468">

Btw, recent ideas:

* I am considering halting the `paint` phase as well: Maybe we can directly reuse the old Layer, so we can get the same UI and at the same time do not call paint on subtree. This is just very naive idea and I will make an experiment later.
* "for a scrolling list, the "finalizing" phase also takes time" - Maybe we can hack ListView itself, and control when it disposes its widgets.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-20T13:46:34Z" retrieveTime="2022-10-17T11:45:49.046468">

### New idea: Preemption

#### Advantages

It can nearly achieve my goal: 60fps, no matter how heavy your build/layout are. Without limitations of other approaches, such as the ones in flutter_smooth, or the ones in "layout" proposal where the widget subtree has to allow their build/layout not called in some frames.

It also *has zero overhead about re-layouting*, i.e. it will *never* need to pay any extra cost to layout, compared to the widget/layout based approaches. It also solves the problem of "how to suspend a layout". I can explain more advantages and comparisons if needed.

Compared with the "dual isolate" proposal above, that one seems very hard to implement as it requires threads or coroutines, but this proposal is not. In addition, this proposal eliminate the second "sidecar" isolate, and everything is in main isolate, so we can run any code with all data in main isolate memory visible.

#### Details

Continue and modified from https://github.com/flutter/flutter/issues/101227#issuecomment-1249005541 (the "dual isolates" idea, but without the need of adding new threads (very troublesome to do syncing), or c++ coroutines (troublesome when c++ wants to call dart callback).

Notice that, the c++ code, main isolate, and sidecar isolate all run on "ui thread". No new threads, no coroutines, etc. So this time, the diagram draws nothing but very normal function calls.

Description of the figure:

* vsync comes.
* As normal, C++ calls Dart's drawFrame.
* Suppose Dart has 3 widgets to build/layout. It build/layout the 1st, then 2nd.
* Then it realizes time has up (say, 15ms has come), when `layout()` the 2nd widget. Then it calls `preemptRaster()` (a dart function).
* In `preemptRaster`, we firstly call `preemptModifyLayerTree` to modify the layer tree a bit, like CircularProgressIndicator or the scrolling ListView wrapper widget case, described in "dual isolate" proposal above. For simplicity, imagine this `preemptModifyLayerTree` is implemented via very low level API, such as `containerLayer.offset = Offset(10,20)`.
* In `preemptRaster`, we then call a probably modified version of FlutterView.render. In other words, we provide layer tree to C++ code, and c++ code provide it to raster thread. *Notice what layer tree we provide here*: Because `preemptRaster` is called within a `layout()`, the `paint` phase has not started, so the layer tree is completely old (instead of mixed). ThusIn addition, `preemptModifyLayerTree` will modify the layer tree a bit. That's all. We will send this to raster.
* Raster thread renders that layer tree as usual, so we see beautiful things on screen. 
* UI thread C++/Dart goes on, because `preemptRaster` function returns. The Dart code will continue from where `preemptRaster` is called (you know, just very plain function calls; but this solves the "how to suspend a layout call" implicitly indeed). In Dart's view, it thinks it is still the 1st frame. Let's say it continues layouting the 2nd widget. Then 3rd widget. Then paint, flush compositing bits, semantics, etc.
* Then finally, as a normal pipeline stage, dart provides the new layer tree and let c++ to throw it to the raster thread.
* Raster thread renders it to screen in the background.
* Then, just like what will be done normally in frame 1, call post frame callbacks, c++ calls dart for some callbacks, etc.
* Now ui thread is idle. When next vsync comes, the same loop will go.

---


![UML时序图 (2)](https://user-images.githubusercontent.com/5236035/191271636-f4b8dc2d-8b35-42f5-87b4-42851eb5ef85.png)



</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-20T13:47:17Z" retrieveTime="2022-10-17T11:45:49.046468">

>  I think that is a pretty smart idea, and has not found other solutions yet. If you approve I will add things similar to that into the codebase. The idea will be the same, while implementation will differ slightly (e.g. use a InheritedWidget + StatefulWidget + controller).

Yeah, I think the code willn't be much different, or I can directly PR to your repo? This jitter usually occurs in ListView, which needs to be nested with SizeCacheWidget in KeFrame, and LayoutInfoNotification is emitted in FrameSpeWidget. So the user has to specify SizeCacheWidget if they want to user ListView.  if it's in Flutter framework, we can add it directly, or do you have other ideas?

>  The 120hz should be simple since we can detect what frequency we are under.

Yes, we can get it directly from the engine, but I have to see how to get it in the framework. It may be necessary to add an API

>  "for a scrolling list, the "finalizing" phase also takes time" - Maybe we can hack ListView itself, and control when it disposes its widgets.

Yes, I think we can ignore this factor for now as I understand it is not particularly time consuming. Or we can directly change the "finalizing" timing of the ListView.



> I am considering halting the paint phase as well: Maybe we can directly reuse the old Layer, so we can get the same UI and at the same time do not call paint on subtree. This is just very naive idea and I will make an experiment later.

I agree with that, I think you just need to nest `RepaintBoundary` on the subtree, right? Just like ListView item, avoid subtree paint causing pain in other widgets.


@fzyzcjy 

I got a bad cold yesterday, so I was late in answering the message


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-20T13:48:45Z" retrieveTime="2022-10-17T11:45:49.046468">

@dnfield @Nayuta403 @JsouLiang (and other experts) I have made a "preemption" proposal, which is like a easy-to-implement version of "dual isolate". Looking forward to any feedbacks! I am going to implement a prototype tomorrow :)

---

Same thing in discord: https://discord.com/channels/608014603317936148/608021234516754444/1021783497112821861

There are some discussions going on there as well. For completeness, a reader of this github thread may need to go to this link and view comments there.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-20T13:53:17Z" retrieveTime="2022-10-17T11:45:49.046468">

@Nayuta403 

> or I can directly PR to your repo?

Sure! But I am hesitate whether going on flutter_smooth now, as the "preemption" proposal seems quite appealing and addresses many problems of flutter_smooth, the layout proposal, and the keframe.

Could you please have a look at "preemption" proposal :) I want to implement a prototype tomorrow (UTC+8 timezone).

> This jitter usually occurs in ListView, which needs to be nested with SizeCacheWidget in KeFrame, and LayoutInfoNotification is emitted in FrameSpeWidget. So the user has to specify SizeCacheWidget if they want to user ListView. if it's in Flutter framework, we can add it directly, or do you have other ideas?

That LGTM. Indeed I will do something like: The `SizeCacheWidget` (I may call it `SmoothParent`) has some inherited widget to provide a controller to its child subtree. Then child can save anything they want to that controller. Anyway, those are simple things, and I can also do it if you like (just need e.g. 15 minutes).

> Yes, we can get it directly from the engine, but I have to see how to get it in the framework. It may be necessary to add an API

I remembered I did that via calling java/swift. Anyway this is minor problem :)

> I agree with that, I think you just need to nest RepaintBoundary on the subtree, right? Just like ListView item, avoid subtree paint causing pain in other widgets.

Yes, but I hope not too many RepaintBoundary in the meanwhile. IIRC during some testing they add overheads. Btw the "preemption" proposal does not have this problem.

> I got a bad cold yesterday, so I was late in answering the message

Sorry to hear that, and hope you are getting well!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021783497112821861" source="discord" createTime="2022-09-20T14:02:49.531+00:00" retrieveTime="2022-10-17T11:34:59.766783">

Hi, I have proposed an approach for 60fps smooth animation no matter how heavy widget tree build and layout is, without paying extra cost (such as redundant re-layout). https://github.com/flutter/flutter/issues/101227#issuecomment-1252379787

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021783945697837066" source="discord" createTime="2022-09-20T14:04:36.482+00:00" retrieveTime="2022-10-17T11:34:59.766783">

@Hixie @dnfield (since @dnfield mentioned that layout suspending has been discussed between them; this one does suspend layout and render first)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021784169891758091" source="discord" createTime="2022-09-20T14:05:29.934+00:00" retrieveTime="2022-10-17T11:34:59.766783">

I am planning to start working on a prototype ~9hr later, but want to hear some hints from you experts, since I have not quite hacked the engine before

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1021786735652376626" source="discord" createTime="2022-09-20T14:15:41.659+00:00" retrieveTime="2022-10-17T11:34:59.766783">

I'm curious about how preemtRaster would modify the layer tree and how it would know where to resume. Those are the more difficult bits.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021788915583156284" source="discord" createTime="2022-09-20T14:24:21.395+00:00" retrieveTime="2022-10-17T11:34:59.766783">

Let's say, for simplicity as a demo, just modify a layer directly via lowest level api. - But we can definitely wrap it to some higher level. And with future thinking maybe we can also do something with existing widget framework.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021789054594977842" source="discord" createTime="2022-09-20T14:24:54.538+00:00" retrieveTime="2022-10-17T11:34:59.766783">

how it would know where to resume: Just call function and it returns! Example:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021789201718579314" source="discord" createTime="2022-09-20T14:25:29.615+00:00" retrieveTime="2022-10-17T11:34:59.766783">

```dart
class RenderObject {
  void layout() {
    if (time_is_nearly_out) preemptRaster();
    normal_layout_things;
  }
}

void preemptRaster() {
  modify_layer_tree_for_animation();
  FlutterView.render(the_layer_tree);
}
```

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021789403288436778" source="discord" createTime="2022-09-20T14:26:17.673+00:00" retrieveTime="2022-10-17T11:34:59.766783">

@dnfield

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-20T14:27:41Z" retrieveTime="2022-10-17T11:45:49.046468">

>  Anyway, those are simple things, and I can also do it if you like (just need e.g. 15 minutes).

Haha OK, you do it 👍🏻  If I do I think it will probably take more than 15 minutes to communicate. hhhh


>  Could you please have a look at "preemption" proposal :) I want to implement a prototype tomorrow (UTC+8 timezone).

I wonder how this Frame1 is generated, now there are only two widgets with build/layout and neither of them have paint/comp etc. If you use the LayerTree from the previous frame that It looks the same as it does now. (A jank happened) 
Am I getting it wrong?  I'm looking forward to seeing your prototype : )

![image](https://user-images.githubusercontent.com/40540394/191283147-dc43f524-fa0d-4681-8273-f23356c39860.png)










</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021790802122375220" source="discord" createTime="2022-09-20T14:31:51.181+00:00" retrieveTime="2022-10-17T11:34:59.766783">

A question: Take `RenderOpacity` for example, and suppose we want that in preemptRaster. Currently it is: 
```
layer = context.pushOpacity(offset, _alpha, super.paint, oldLayer: layer as OpacityLayer?);

// definition
  OpacityLayer pushOpacity(Offset offset, int alpha, PaintingContextCallback painter, { OpacityLayer? oldLayer }) {
    final OpacityLayer layer = oldLayer ?? OpacityLayer();
    layer
      ..alpha = alpha
      ..offset = offset;
    pushLayer(layer, painter, Offset.zero);
    return layer;
  }
```
So, my naive thought of directly manipulating it:
```
void directlyManipulateOpacityInPreemptRaster() {
  final OpacityLayer layer = layer_tree.children.where(...); // find opacity layer
  layer.alpha = some_new_value_for_animation;
}
```
If I call merely this, without all those PictureRecorder/create-new-layer etc, will it be acceptable?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-20T14:34:30Z" retrieveTime="2022-10-17T11:45:49.046468">

> If I do I think it will probably take more than 15 minutes to communicate. hhhh

Haha I think so!

> I wonder how this Frame1 is generated, now there are only two widgets with build/layout and neither of them have paint/comp etc

Well I should say, this diagram happens *after* we have rendered a lot of frames. So the layer tree is already there, just *without* the several newly added/modified widgets.

> If you use the LayerTree from the previous frame that It looks the same as it does now. (A jank happened)
Am I getting it wrong?

No, I call `preemptModifyLayerTree`. That one handles animations, e.g. CircularProgressIndicator, or ListView scrolling, or opacity changing animation. For simplest example, for opacity, it may update a OpacityLayer.opacity from 0.1 to 0.2 etc.

> I'm looking forward to seeing your prototype : )

Thanks :)

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1021792183105355846" source="discord" createTime="2022-09-20T14:37:20.433+00:00" retrieveTime="2022-10-17T11:34:59.766783">

What happens if a render object doesn't implement preemptRaster?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021792880861384764" source="discord" createTime="2022-09-20T14:40:06.791+00:00" retrieveTime="2022-10-17T11:34:59.766783">

Just put it into `RenderObject.layout`

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021793050411933706" source="discord" createTime="2022-09-20T14:40:47.215+00:00" retrieveTime="2022-10-17T11:34:59.766783">

e.g. add `if (time_is_nearly_out) preemptRaster();` as 1st line of RenderObject.layout. (Surely we may optimize it to be faster, but idea is same)

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1021807196272603156" source="discord" createTime="2022-09-20T15:36:59.851+00:00" retrieveTime="2022-10-17T11:34:59.766783">

What happens if devs write something slow into `preemptRaster`? 🙂

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1021807402510716970" source="discord" createTime="2022-09-20T15:37:49.022+00:00" retrieveTime="2022-10-17T11:34:59.766783">

I'm curious about this, maybe it'd help to see a little bit more detail around implemenation. Perhaps write up a doc?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021917668288245772" source="discord" createTime="2022-09-20T22:55:58.432+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Just do not do that 😉 It is like asking "what if dev use a million of pushLayer today (answer: it will be slow)"

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021917840808362024" source="discord" createTime="2022-09-20T22:56:39.564+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Sure! Do you mean https://docs.google.com/document/d/1SFRO8U2toOlAaZ38dsuEU7Wm5fn41wvBCWKiwADqfmw/edit the flutter design doc template?

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1021917907569090641" source="discord" createTime="2022-09-20T22:56:55.481+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So I think an ideal solution will not require developers to update their widgets/render objects, and will not break if developers decide to just throw tons of work into a new method they have to implement

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1021917931367583814" source="discord" createTime="2022-09-20T22:57:01.155+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes, that would be good

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021917995548815420" source="discord" createTime="2022-09-20T22:57:16.457+00:00" retrieveTime="2022-10-17T11:35:13.053450">

not require developers to update their widgets/render objects -> Yes, this solution do not require

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021918064721276928" source="discord" createTime="2022-09-20T22:57:32.949+00:00" retrieveTime="2022-10-17T11:35:13.053450">

will not break if developers decide to just throw tons of work into a new method they have to implement -> dev do not implement preemptRaster

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021918138276773928" source="discord" createTime="2022-09-20T22:57:50.486+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Instead, the API we give is like this:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021918398495592519" source="discord" createTime="2022-09-20T22:58:52.527+00:00" retrieveTime="2022-10-17T11:35:13.053450">

No dev will know what is preemptRaster. They only know that, when they want a smooth CircularProgressIndicator, or a smooth ListView scroll, or a smooth opacity animation, they put a special widget into the tree, say, `PreemptCircularProgressIndicator()`

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021918533053055027" source="discord" createTime="2022-09-20T22:59:24.608+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Under the hood, our PreemptCircularProgressIndicator will utilize preemptRaster.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021918625873022996" source="discord" createTime="2022-09-20T22:59:46.738+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Btw, preemptRaster is *not* a method in RenderObject that everyone needs to implement, unlike layout/paint/... which everyone should impl

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021918706621755533" source="discord" createTime="2022-09-20T23:00:05.99+00:00" retrieveTime="2022-10-17T11:35:13.053450">

preemptRaster is like some utility function, that only we flutter *framework* dev need to impl once

</DiscussionComment>

<DiscussionComment author="ping" link="https://discord.com/channels/608014603317936148/608021234516754444/1021918768307392545" source="discord" createTime="2022-09-20T23:00:20.697+00:00" retrieveTime="2022-10-17T11:35:13.053450">

>  when they want a smooth CircularProgressIndicator, or a smooth ListView scroll, or a smooth opacity animation
Isn't that always?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021918890294521866" source="discord" createTime="2022-09-20T23:00:49.781+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Haha, then maybe make it the default 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021918915426795630" source="discord" createTime="2022-09-20T23:00:55.773+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Or, maybe add a flag into it

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021918989674369094" source="discord" createTime="2022-09-20T23:01:13.475+00:00" retrieveTime="2022-10-17T11:35:13.053450">

say, `CircularProgressIndicator(preempt: true/false)`

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021919185909063761" source="discord" createTime="2022-09-20T23:02:00.261+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Anyway I have not think about the details about the *high level* apis inside preemptRender. It may or may not support *arbitrary* widgets. I am thinking about making it run firstly.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021920487183499294" source="discord" createTime="2022-09-20T23:07:10.509+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Btw, what are you guy's timezone? I will create a design doc probably within an hour, not sure whether you guys are online or not

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021921192090812448" source="discord" createTime="2022-09-20T23:09:58.572+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Just sharing some experience I've had working on performance: it's very rare to find that applications are blocked on the UI thread, except for 1) incorrectly implemented scrolling 2) lack of isolate usage for data processing. Thus I would be quite skeptical that this sort of change would actually be beneficial to most Flutter developers, and design doc or not there is almost no chance I would be in favor of adding this to the framework.

@dnfield pointed out another case to me, which is that on particularly low end android devices, even simple UIs can jank due to text layout costs. Though I think its also fairly common for these particularly low end devices to have very few cores, or only one or two fast cores - meaning that multithreading may not help much either.

I think the only thing that would cause me to change my mind is a prototype that demonstrated substantially better performance on a real-ish app; that is one that did not intentionally do way too much work.

Not trying to be too discouraging, but I want to make sure that we're on the same page on the expectations for a feature like this.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021921345145147392" source="discord" createTime="2022-09-20T23:10:35.063+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> it's very rare to find that applications are blocked on the UI thread,
Me 😦 Quite complex UI, on very low end devices

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021921455816048681" source="discord" createTime="2022-09-20T23:11:01.449+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I understand that, but then every time I get source code access, its always 1) or 2).

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021921571339784193" source="discord" createTime="2022-09-20T23:11:28.992+00:00" retrieveTime="2022-10-17T11:35:13.053450">

not saying that you're wrong, just that I'm not willing to take anyone at their word for this. I want to see the example code

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021921790752206859" source="discord" createTime="2022-09-20T23:12:21.304+00:00" retrieveTime="2022-10-17T11:35:13.053450">

(Sorry you already mentioned that example)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021921827733389322" source="discord" createTime="2022-09-20T23:12:30.121+00:00" retrieveTime="2022-10-17T11:35:13.053450">

(wait a minute I first read all messages)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922041307340880" source="discord" createTime="2022-09-20T23:13:21.041+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> Though I think its also fairly common for these particularly low end devices to have very few cores, or only one or two fast cores - meaning that multithreading may not help much either.
My suggestion is not multithreading, it is still single thread 🙂

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922205292056706" source="discord" createTime="2022-09-20T23:14:00.138+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I might be mixing this up with the other github issue on a separate animation thread

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922220026626098" source="discord" createTime="2022-09-20T23:14:03.651+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> I think the only thing that would cause me to change my mind is a prototype that demonstrated substantially better performance on a real-ish app; that is one that did not intentionally do way too much work.
@Jsouliang @Nayuta I think their `keframe` has demonstrated some real cases where it boosts performance. I will find an article. Wait for a minute

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922313995812875" source="discord" createTime="2022-09-20T23:14:26.055+00:00" retrieveTime="2022-10-17T11:35:13.053450">

A document would be a good place to start then 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922367812943872" source="discord" createTime="2022-09-20T23:14:38.886+00:00" retrieveTime="2022-10-17T11:35:13.053450">

https://github.com/LianjiaTech/keframe

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922410418675783" source="discord" createTime="2022-09-20T23:14:49.044+00:00" retrieveTime="2022-10-17T11:35:13.053450">

The readme explains a bit

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922490622152774" source="discord" createTime="2022-09-20T23:15:08.166+00:00" retrieveTime="2022-10-17T11:35:13.053450">

They also use it in LianJia app IIRC, a somewhat large company

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922545705951322" source="discord" createTime="2022-09-20T23:15:21.299+00:00" retrieveTime="2022-10-17T11:35:13.053450">

And in Bytedance, they said they have done sth similar to optimize

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922594917732433" source="discord" createTime="2022-09-20T23:15:33.032+00:00" retrieveTime="2022-10-17T11:35:13.053450">

so I guess these are evidence of optimization of speed in real world

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922677595840543" source="discord" createTime="2022-09-20T23:15:52.744+00:00" retrieveTime="2022-10-17T11:35:13.053450">

https://github.com/flutter/flutter/issues/101227#issuecomment-1247545240 Yes, we [people in bytedance] all farmilar with KeFrame and has already applied some optimize like it.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922765315526656" source="discord" createTime="2022-09-20T23:16:13.658+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Note that my solution is quite diff from keframe.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922858630385744" source="discord" createTime="2022-09-20T23:16:35.906+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If your solution is quite different, definitely write up a doc

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922877018226709" source="discord" createTime="2022-09-20T23:16:40.29+00:00" retrieveTime="2022-10-17T11:35:13.053450">

The only similarity is that, we both want to address the less-than-60fps jank

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922909763145809" source="discord" createTime="2022-09-20T23:16:48.097+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Sure! I will do that in an hour

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021922983322857553" source="discord" createTime="2022-09-20T23:17:05.635+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Btw there is a brief (1-page) proposal currently: https://github.com/flutter/flutter/issues/101227#issuecomment-1252379787

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021923104173334548" source="discord" createTime="2022-09-20T23:17:34.448+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I thought that was the dual isolates/multithreading idea?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021923234494566463" source="discord" createTime="2022-09-20T23:18:05.519+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Nonono

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021923275145744394" source="discord" createTime="2022-09-20T23:18:15.211+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I have removed dual isolates and multithreading or coroutine 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021923312353427526" source="discord" createTime="2022-09-20T23:18:24.082+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Now look at the biggest fig in that comment

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021923333434003567" source="discord" createTime="2022-09-20T23:18:29.108+00:00" retrieveTime="2022-10-17T11:35:13.053450">

it is nothing but NORMAL function calls

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021923506537107487" source="discord" createTime="2022-09-20T23:19:10.379+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Btw, `keframe` has popularity of `93%` with 100+ likes in pub https://pub.dev/packages/keframe

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021923580948258856" source="discord" createTime="2022-09-20T23:19:28.12+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If nobody is facing build/layout jank, I guess it should not be a popular lib at all 😉

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021923680202268762" source="discord" createTime="2022-09-20T23:19:51.784+00:00" retrieveTime="2022-10-17T11:35:13.053450">

keframe has some hard-to-overcome shortcomings, but it is still already *this* popoular

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021924577791717408" source="discord" createTime="2022-09-20T23:23:25.786+00:00" retrieveTime="2022-10-17T11:35:13.053450">

most popular packages don't get folded into the SDK

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021925175878484070" source="discord" createTime="2022-09-20T23:25:48.381+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@fzyzcjy I would second @dnfield 's recommendation to write a doc. Most of us are going to have trouble following a github issue with dozens of comments, and we're not sure which parts of the proposal are still valid and which aren't

</DiscussionComment>

<DiscussionComment author="stuartmorgan" link="https://discord.com/channels/608014603317936148/608021234516754444/1021926433997733928" source="discord" createTime="2022-09-20T23:30:48.34+00:00" retrieveTime="2022-10-17T11:35:13.053450">

93% isn't actually as popular as it sounds; there are enough packages uploaded now that the percentage can be somewhat misleading. That puts it at something like 2000th.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021928405853294602" source="discord" createTime="2022-09-20T23:38:38.467+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> most popular packages don't get folded into the SDK
Sure, I know that 🙂 I just want to say "there do exist real-world cases who needs to be extra smooth"

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021928436517838969" source="discord" createTime="2022-09-20T23:38:45.778+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> Most of us are going to have trouble following a github issue with dozens of comments, and we're not sure which parts of the proposal are still valid and which aren't

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021928474002346024" source="discord" createTime="2022-09-20T23:38:54.715+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I see, just ate and now start writing

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021928515320430643" source="discord" createTime="2022-09-20T23:39:04.566+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> 93% isn't actually as popular as it sounds; there are enough packages uploaded now that the percentage can be somewhat misleading. That puts it at something like 2000th.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021928545339048021" source="discord" createTime="2022-09-20T23:39:11.723+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Did not know that before 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021928729800347648" source="discord" createTime="2022-09-20T23:39:55.702+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But anyway, hopefully my comments above already show realworld cases: The bytedance and the lianjia. Especially bytedance (IIRC it is even on flutter.dev frontpage?).

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021934264704573471" source="discord" createTime="2022-09-21T00:01:55.326+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I understand that this technique has been successful for bytedance and others, I'm not disputing or disagreeing with this. But adding something to the SDK, especially if it is a large intrusive change, is going to be held to the standard of whether it will be successful for all or most users of Flutter today. To evaluate this, we'll need _at least_ a design doc, so we can understand the change you're trying to make. Ideally we would also have some sort of prototype, so that we can understand the behavioral changes, if any, required.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021935139879665724" source="discord" createTime="2022-09-21T00:05:23.984+00:00" retrieveTime="2022-10-17T11:35:13.053450">

"large intrusive change" - I am trying to make it small 🙂
"we'll need at least a design doc" - writing! https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit# (surely not finished yet though)
" Ideally we would also have some sort of prototype, so that we can understand the behavioral changes, if any, required." - I also want to do that

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021935177766797353" source="discord" createTime="2022-09-21T00:05:33.017+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Will ping here when finish writing

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021936142834225223" source="discord" createTime="2022-09-21T00:09:23.107+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Thank you!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021938725619511336" source="discord" createTime="2022-09-21T00:19:38.891+00:00" retrieveTime="2022-10-17T11:35:13.053450">

You are welcome!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021949519459528755" source="discord" createTime="2022-09-21T01:02:32.343+00:00" retrieveTime="2022-10-17T11:35:13.053450">

https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?usp=sharing is ready

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021949801761357874" source="discord" createTime="2022-09-21T01:03:39.649+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Jonah Williams @dnfield (who said I should provide a doc)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-21T01:05:56Z" retrieveTime="2022-10-17T11:45:49.046468">

Design proposal: https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?usp=sharing

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1SuE" source="google_doc_comments" createTime="2022-09-21T01:14:35.939Z" retrieveTime="2022-10-17T11:05:47.152504">

If we can stop rendering at any point, how do we resolve the sizes of render objects that depend on their children?

What about something like a layout builder? If we pre-empted layout then we may not actually be able to finish building?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1SuI" source="google_doc_comments" createTime="2022-09-21T01:16:01.875Z" retrieveTime="2022-10-17T11:05:47.152504">

If we stop rendering based on time elapsed at an arbitrary RO, there is a risk we end up with a UI that makes no sense. i.e. we could get buttons with no labels or half filled in text. I'd be concerned that without a developer making an intentional choice of where to stop rendering, we'd be worse off than if we janked and took longer to render

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1SuQ" source="google_doc_comments" createTime="2022-09-21T01:17:55.051Z" retrieveTime="2022-10-17T11:05:47.152504">

It might be worth contrasting this approach with keframe, or elaborating on what problems this solves that keframe cannot

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1SuY" source="google_doc_comments" createTime="2022-09-21T01:19:00.455Z" retrieveTime="2022-10-17T11:05:47.152504">

We do not resolve sizes. Indeed, we are using the _previous fully_ rendered UI (plus modifications in preemptModifyLayer).

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Suc" source="google_doc_comments" createTime="2022-09-21T01:19:56.363Z" retrieveTime="2022-10-17T11:05:47.152504">

Well we are using the _previous fully_ rendered UI + modifications in preemptModifyLayer. We will never see half filled UI!

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Sug" source="google_doc_comments" createTime="2022-09-21T01:20:49.234Z" retrieveTime="2022-10-17T11:05:47.152504">

The flutter test framework generally allows developers to elapsed arbitrary amounts of time with fake async usage. This is intentional to ensure that unit tests can be reasonably deterministic.

It would be massively breaking for unit tests to take a different number of frames to reach the same conclusion, depending on the speed of the host hardware.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Suk" source="google_doc_comments" createTime="2022-09-21T01:21:19.125Z" retrieveTime="2022-10-17T11:05:47.152504">

Indeed, imagine the whole proposal like this: We are still running the janky slow UI that is less than 60FPS. But, once in a while, we "secretly" flush old layer tree + some preemptModifyLayer modifications to the screen.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Suo" source="google_doc_comments" createTime="2022-09-21T01:22:26.962Z" retrieveTime="2022-10-17T11:05:47.152504">

It seems like that would only work if the previous UI was quite similar to the current UI, but that may not be the case.

How do you connect the current render object with the previous UI? The ROs are stateful objects, the only stable representation may be the old layer tree.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Sus" source="google_doc_comments" createTime="2022-09-21T01:23:19.756Z" retrieveTime="2022-10-17T11:05:47.152504">

We should fake the meaning of "time" in this proposal as well. For example, we may provide a variable called `preemptStrategy`:

```
abstract class PreemptStrategy {
bool shouldWePreemptNow();
} 
```

and call it in place of "checking whether 15 ms has passed".

Then, when testing, we are in full control. For example, we can disable the whole preempt. We can decide to preempt at a specific RenderObject we like to test. etc

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Suw" source="google_doc_comments" createTime="2022-09-21T01:23:58.886Z" retrieveTime="2022-10-17T11:05:47.152504">

Sure. I will do that in a minute.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Su4" source="google_doc_comments" createTime="2022-09-21T01:24:34.176Z" retrieveTime="2022-10-17T11:05:47.152504">

Seems reasonable. FWIW, the amount of time available will vary per platform, and in the case of devices with dynamic refresh rates it may even vary frame to frame. I believe we should know the approximate target time for each frame when it starts though

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Su8" source="google_doc_comments" createTime="2022-09-21T01:26:55.990Z" retrieveTime="2022-10-17T11:05:47.152504">

I am mainly thinking about janks in animations. The examples - progress indicator, scrolling listview, enter page transition, all are examples.

If your previous UI does not look similar to current, it is also OK. My proposal is just like, "originally the UI is janky, now we add some extra frames into its normal frames".

Anyway they can always disable it by a simple flag in widgets.

When flushing ui during animation, we just provide (old + minor modified) layer tree. We do not touch RO indeed.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1SvA" source="google_doc_comments" createTime="2022-09-21T01:27:57.841Z" retrieveTime="2022-10-17T11:05:47.152504">

Agree, and that should be fetchable from some kind of platform APIs. I am saying 15ms or 16.6ms just because it is simple to explain :)

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1SvQ" source="google_doc_comments" createTime="2022-09-21T01:31:57.627Z" retrieveTime="2022-10-17T11:05:47.152504">

Yes, understood! :)

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1SvU" source="google_doc_comments" createTime="2022-09-21T01:33:54.168Z" retrieveTime="2022-10-17T11:05:47.152504">

What I mean is - how do you detect that the previous UI is not like the current UI? Its OK if this isn't a performance improvement for that case, but I don't see how you would actually determine that it was "Safe" to use an old layer tree

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Svc" source="google_doc_comments" createTime="2022-09-21T01:36:30.982Z" retrieveTime="2022-10-17T11:05:47.152504">

It is always safe. Because we are just "inserting" extra frames into the plain old frames!

For example, suppose it originally runs at 10 fps. Now, between frame 1 and frame 2, we insert frame 1a,1b,1c, ..., which is very alike frame 1 except for minor modifications (such as one OffsetLayer.offset).

If the users find this UI weird in their special case, they can also choose to disable surely.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021960815567454258" source="discord" createTime="2022-09-21T01:47:25.545+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Thanks @fzyzcjy , I left some comments in the doc which I see you've responded to. In general, my feedback is that I don't see how some parts of your proposal would actually work in practice. Re-using the previous frame and yielding during layout may break many fundamental assumptions we've made throughout the framework, and without a runnable example/prototype I don't think we're going to be able to understand the trade-offs you're making.

I'd also add that I don't think you need new engine APIS for this.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021961588355371110" source="discord" createTime="2022-09-21T01:50:29.792+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Jonah Williams Hi thanks for the suggestions!
> I don't think you need new engine APIS for this.
I am worried about this. FlutterView.render says:
>   /// If this function is called a second time during a single
>   /// [PlatformDispatcher.onBeginFrame]/[PlatformDispatcher.onDrawFrame]
>   /// callback sequence or called outside the scope of those callbacks, the call
>   /// will be ignored.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021961676532236388" source="discord" createTime="2022-09-21T01:50:50.815+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So in our case it will be ignored. We have to change the engine...

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021961831218159657" source="discord" createTime="2022-09-21T01:51:27.695+00:00" retrieveTime="2022-10-17T11:35:13.053450">

that is pretty fundamental

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021961855054389268" source="discord" createTime="2022-09-21T01:51:33.378+00:00" retrieveTime="2022-10-17T11:35:13.053450">

you can only submit a single frame in a vsync

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021961863724007464" source="discord" createTime="2022-09-21T01:51:35.445+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> without a runnable example/prototype I don't think we're going to be able to understand the trade-offs you're making.
I will try to do so today

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021961880987762761" source="discord" createTime="2022-09-21T01:51:39.561+00:00" retrieveTime="2022-10-17T11:35:13.053450">

otherwise you're just doing extra work

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021961946301464587" source="discord" createTime="2022-09-21T01:51:55.133+00:00" retrieveTime="2022-10-17T11:35:13.053450">

you'd have to submit a frame with you pre-empted frame, and then schedule a new frame to continue running

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021962009870344212" source="discord" createTime="2022-09-21T01:52:10.289+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I think you'd want that approach anyway.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021962033492656180" source="discord" createTime="2022-09-21T01:52:15.921+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes, only one in single vsync. But when the main code is very slow (say 10 frames to build/layout/paint/...), we want to respond to 2nd 3rd ... vsync

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021962093332803615" source="discord" createTime="2022-09-21T01:52:30.188+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So engine has to be modified IMHO

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021962350917591151" source="discord" createTime="2022-09-21T01:53:31.601+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I am not an expert in engine TBH (never did such big changes before!), but I will try my best to prototype it.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021962694091350057" source="discord" createTime="2022-09-21T01:54:53.42+00:00" retrieveTime="2022-10-17T11:35:13.053450">

That is a very substantial change. What is the advantage to that approach over scheduling a new frame after the preemption?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021963163702415360" source="discord" createTime="2022-09-21T01:56:45.384+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Sorry not quite get it. If we schedule a new frame, and vsync comes, what should we do? We cannot call Flutter's onDrawFrame definitely, because Flutter is still busy doing build/layout/... of the first frame.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021963804747255929" source="discord" createTime="2022-09-21T01:59:18.221+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So backing up a bit, you're not really pre-empting in the way I thought you were. My idea was something like:

* Start drawing a frame
* Exceed threshold
* Submit frame
* Schedule new frame with some metadata that allows continuation.
* Repeat

Then your idea is more like:

* Start drawing a frame
* Exceed threshold
* Submit frame
* Continue building
* Submit frame
* Finish building

Is that correct?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021964564876775464" source="discord" createTime="2022-09-21T02:02:19.45+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021964603204304956" source="discord" createTime="2022-09-21T02:02:28.588+00:00" retrieveTime="2022-10-17T11:35:13.053450">

That is why I have zero overhead for suspending the layout phase

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021965008751566888" source="discord" createTime="2022-09-21T02:04:05.278+00:00" retrieveTime="2022-10-17T11:35:13.053450">

"with some metadata that allows continuation" - that seems to be the approach that was discussed in Jan 2022 by @Hixie etc, and discussed again in May (?) 2022 by bytedance people, and discussed again by me in github. I am writing comparison about it in google doc now (WIP), under the title"Compared with modify-the-layout-function methods".

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021965174703403038" source="discord" createTime="2022-09-21T02:04:44.844+00:00" retrieveTime="2022-10-17T11:35:13.053450">

one disadvantage of not yielding is that I don't think you'll receive input events. i.e. you start a page transition, start janking and then the user cancels. How do you avoid just continuing the animation?

At least if you yield, you could receive input events and run event handlers

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021965288813625434" source="discord" createTime="2022-09-21T02:05:12.05+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Please have a look at `preemptHandleTouchEvents`

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021965367934988378" source="discord" createTime="2022-09-21T02:05:30.914+00:00" retrieveTime="2022-10-17T11:35:13.053450">

The preempt-aware special widgets will do that. For example, see "scrolling ListView" example. The scrolling will be 60fps.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021965808668246039" source="discord" createTime="2022-09-21T02:07:15.993+00:00" retrieveTime="2022-10-17T11:35:13.053450">

You're going to end up rebuilding widgets recursively from within layout of a layer tree. I'm not really sure if that would work.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021965914293407786" source="discord" createTime="2022-09-21T02:07:41.176+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I guess have pre-emption you can yield from layout, handle events, and then go back?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021966043486363668" source="discord" createTime="2022-09-21T02:08:11.978+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But TBH that seems a lot more complicated than using the existing drawFrame APIs and scheduling new tasks.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021966338601783358" source="discord" createTime="2022-09-21T02:09:22.339+00:00" retrieveTime="2022-10-17T11:35:13.053450">

and preemptHandleTouchEvents isn't sufficient, because you need to account for the existing gesture areas, otherwise event behavior may change between non pre-empted and pre-empted rendering

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021966535557922857" source="discord" createTime="2022-09-21T02:10:09.297+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> rebuilding widgets recursively from within layout of a layer tree
Well no? I will just grab the layer tree and send to raster thread, without touching RenderObject, let alone element or widget

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021966554470027304" source="discord" createTime="2022-09-21T02:10:13.806+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I think if you broke it down so that each pre-emption behaved like a regular flutter frame though, it might work

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021966601504952320" source="discord" createTime="2022-09-21T02:10:25.02+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but then you might as well just schedule a frame

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021966650016284713" source="discord" createTime="2022-09-21T02:10:36.586+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but event handlers can setState

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021966860775850054" source="discord" createTime="2022-09-21T02:11:26.835+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> and preemptHandleTouchEvents isn't sufficient, because you need to account for the existing gesture areas, otherwise event behavior may change between non pre-empted and pre-empted rendering
It is just for simple things like "shifting a listview". For normal gestures, let it be done in normal frame pipeline. In other words, suppose it takes 1s to run a full pipeline, then the ListView will see all touch events during this 1s.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021966932267782295" source="discord" createTime="2022-09-21T02:11:43.88+00:00" retrieveTime="2022-10-17T11:35:13.053450">

No, you can't create a distinct pre-empty only set of gestures

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021966959698513950" source="discord" createTime="2022-09-21T02:11:50.42+00:00" retrieveTime="2022-10-17T11:35:13.053450">

The preemptHandleTouchEvents will see events in each of 60fps frame, but that is like "secretly peeking at it"

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967005055733872" source="discord" createTime="2022-09-21T02:12:01.234+00:00" retrieveTime="2022-10-17T11:35:13.053450">

you'll get different behavior between pre epmted and non pre-empted rendering

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967036492034108" source="discord" createTime="2022-09-21T02:12:08.729+00:00" retrieveTime="2022-10-17T11:35:13.053450">

you have to go through the full event dispatch for correctness

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967109279981578" source="discord" createTime="2022-09-21T02:12:26.083+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> each pre-emption behaved like a regular flutter frame though, it might work
I am worried about that, b/c we will be build/layout a whole tree, inside the middle of build/layout a whole tree

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967141920067674" source="discord" createTime="2022-09-21T02:12:33.865+00:00" retrieveTime="2022-10-17T11:35:13.053450">

consider the case where a ListView is behind something like a pointer interceptor

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967256730730516" source="discord" createTime="2022-09-21T02:13:01.238+00:00" retrieveTime="2022-10-17T11:35:13.053450">

you don't want the listview to get scroll events in pre-empted frames because the pointer interceptor isn't aware of the pre-empt behavior

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967276943085710" source="discord" createTime="2022-09-21T02:13:06.057+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> consider the case where a ListView is behind something like a pointer interceptor
That's why preemptHandleTouchEvents is for *animations*, not general-purpose

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967475107188847" source="discord" createTime="2022-09-21T02:13:53.303+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Users may set a preempt handler in this case, specifying it not to scroll

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967612315451492" source="discord" createTime="2022-09-21T02:14:26.016+00:00" retrieveTime="2022-10-17T11:35:13.053450">

It is like how React Fiber does things

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967656401768518" source="discord" createTime="2022-09-21T02:14:36.527+00:00" retrieveTime="2022-10-17T11:35:13.053450">

With fiber, JS animation still jank. Only css animation is smooth

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967730087297086" source="discord" createTime="2022-09-21T02:14:54.095+00:00" retrieveTime="2022-10-17T11:35:13.053450">

React does not have a layout or paint phase, and ultimately works much different from flutter

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967759833309184" source="discord" createTime="2022-09-21T02:15:01.187+00:00" retrieveTime="2022-10-17T11:35:13.053450">

preemptHandleTouchEvents and its brothers are like "css animation" - another thing, parallel to traditional flutter widgets etc

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967844306595890" source="discord" createTime="2022-09-21T02:15:21.327+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i.e. React essentially yields during the equivalent of build

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967848710606921" source="discord" createTime="2022-09-21T02:15:22.377+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Sure, I am just analogy 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021967986602553374" source="discord" createTime="2022-09-21T02:15:55.253+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I am analogy about the framework users' feeling: They have to write down something different (CSS instead of JS) for smooth animation.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021968036602847282" source="discord" createTime="2022-09-21T02:16:07.174+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Introducing a different set of event handlers, that may only fire sometimes during scrolling, is not a reasonable change IMO

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021968063421231186" source="discord" createTime="2022-09-21T02:16:13.568+00:00" retrieveTime="2022-10-17T11:35:13.053450">

it will be too hard for users to predict the behavior

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021968071356858419" source="discord" createTime="2022-09-21T02:16:15.46+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Anyway for standard cases, such as ListView scrolling, or any animation that requires one DisplayListLayer, we can embed into framework

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021968561440292864" source="discord" createTime="2022-09-21T02:18:12.305+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Hmm

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021968602678702151" source="discord" createTime="2022-09-21T02:18:22.137+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So what solution do you think?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021968714339467294" source="discord" createTime="2022-09-21T02:18:48.759+00:00" retrieveTime="2022-10-17T11:35:13.053450">

adjust your design 🙂

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021968757003931679" source="discord" createTime="2022-09-21T02:18:58.931+00:00" retrieveTime="2022-10-17T11:35:13.053450">

you are essentially proposing a new, Flutter-like framework

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021968788729639014" source="discord" createTime="2022-09-21T02:19:06.495+00:00" retrieveTime="2022-10-17T11:35:13.053450">

which, maybe that is the right thing for your use-case

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021968856408928257" source="discord" createTime="2022-09-21T02:19:22.631+00:00" retrieveTime="2022-10-17T11:35:13.053450">

We cannot run hitTest for not-yet-layout widgets I guess

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021968883231494205" source="discord" createTime="2022-09-21T02:19:29.026+00:00" retrieveTime="2022-10-17T11:35:13.053450">

What?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969027783983235" source="discord" createTime="2022-09-21T02:20:03.49+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Well I am considering the general use case: Loading indicator, scrolling ListView, enter page transition. Isn't that many people needs 🙂

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969047916658758" source="discord" createTime="2022-09-21T02:20:08.29+00:00" retrieveTime="2022-10-17T11:35:13.053450">

event handling is pretty core to how the framework behaves. not that we can't adjust the behavior, but what you are describing sounds like a huge departure.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969206163546142" source="discord" createTime="2022-09-21T02:20:46.019+00:00" retrieveTime="2022-10-17T11:35:13.053450">

and, if you are seriously dropping frames on the UI side of things with those examples, you will also drop raster frames

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969225746751528" source="discord" createTime="2022-09-21T02:20:50.688+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Indeed for my own case, I have heavy rasterize. But I do not propose PRs about this, since I guess few people have my own case

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969267509444651" source="discord" createTime="2022-09-21T02:21:00.645+00:00" retrieveTime="2022-10-17T11:35:13.053450">

so that may not help reduce the perception of jank

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969418911227934" source="discord" createTime="2022-09-21T02:21:36.742+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Sorry I do not quite get it. I send layer tree to rasterizer at 60fps, so no jank?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969445087879209" source="discord" createTime="2022-09-21T02:21:42.983+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I see.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969480093552742" source="discord" createTime="2022-09-21T02:21:51.329+00:00" retrieveTime="2022-10-17T11:35:13.053450">

no, because each layer tree also has to be rasterized and then submitted

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969517427052624" source="discord" createTime="2022-09-21T02:22:00.23+00:00" retrieveTime="2022-10-17T11:35:13.053450">

and that requires work on the engine side and then the GPU

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969530571997234" source="discord" createTime="2022-09-21T02:22:03.364+00:00" retrieveTime="2022-10-17T11:35:13.053450">

which can also jank

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969550171975740" source="discord" createTime="2022-09-21T02:22:08.037+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I think the React generator the VirtualDom Tree and Diff VDomTree will cost too long time, so in React18 it use a Fiber to interrupt the process if a  recursion level is too deep

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969559491711107" source="discord" createTime="2022-09-21T02:22:10.259+00:00" retrieveTime="2022-10-17T11:35:13.053450">

You mean rastierzed at ui thread or raster thread?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969601468317757" source="discord" createTime="2022-09-21T02:22:20.267+00:00" retrieveTime="2022-10-17T11:35:13.053450">

raster thread

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969675539730452" source="discord" createTime="2022-09-21T02:22:37.927+00:00" retrieveTime="2022-10-17T11:35:13.053450">

"raster thread runs too slow that it causes visual jank" is not addressed in this proposal indeed.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969700973977690" source="discord" createTime="2022-09-21T02:22:43.991+00:00" retrieveTime="2022-10-17T11:35:13.053450">

That may be a separate proposal

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969874370707538" source="discord" createTime="2022-09-21T02:23:25.332+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes I am not analogy to that specific algorithm, just analogy about dev experience.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021969920545792120" source="discord" createTime="2022-09-21T02:23:36.341+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Which I think is essentially yielding during build, for the Flutter analogy. But Flutter runs layout/paint in the same thread, whereas browsers already have separate threads

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970032911200296" source="discord" createTime="2022-09-21T02:24:03.131+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes, so my design is not an analogy to fiber when it comes to implementation

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970040238657576" source="discord" createTime="2022-09-21T02:24:04.878+00:00" retrieveTime="2022-10-17T11:35:13.053450">

html is also much more tolerant of half finished UIs....

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970106282147840" source="discord" createTime="2022-09-21T02:24:20.624+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Indeed this design very different from fiber 🙂

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970149466710026" source="discord" createTime="2022-09-21T02:24:30.92+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But the widget build or layout is run on the UI Thread, if build or layout is cost too long time, it will jank

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970213429854279" source="discord" createTime="2022-09-21T02:24:46.17+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes, and this proposal tries to address the problem

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970230689398935" source="discord" createTime="2022-09-21T02:24:50.285+00:00" retrieveTime="2022-10-17T11:35:13.053450">

that same like the vdom diff or build in the js thread

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970288327536680" source="discord" createTime="2022-09-21T02:25:04.027+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So, currently our problem is, how to handle input events?

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970288671457380" source="discord" createTime="2022-09-21T02:25:04.109+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i think they are the same issue

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970361677520917" source="discord" createTime="2022-09-21T02:25:21.515+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I think you should handle input events by using the regular event handling pipeline

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970389578027100" source="discord" createTime="2022-09-21T02:25:28.167+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes that is our goal

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970484746784798" source="discord" createTime="2022-09-21T02:25:50.857+00:00" retrieveTime="2022-10-17T11:35:13.053450">

which requires you to implement this by scheduling new frames instead of allowing multiple submissions from a single frame

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021970663508021318" source="discord" createTime="2022-09-21T02:26:33.477+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I am thinking about it - is it possible to do this inside preempt...

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021971446169346098" source="discord" createTime="2022-09-21T02:29:40.078+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Is it possible to do like this:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021971585202126888" source="discord" createTime="2022-09-21T02:30:13.226+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Do not propagate to ROs that are dirty. Only propagate to those who are clean.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021971597529202750" source="discord" createTime="2022-09-21T02:30:16.165+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i.e. call hitTests etc

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021971631859572756" source="discord" createTime="2022-09-21T02:30:24.35+00:00" retrieveTime="2022-10-17T11:35:13.053450">

All done inside the preemptRender.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021971810293645332" source="discord" createTime="2022-09-21T02:31:06.892+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Jonah Williams Will we have trouble?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021971892904669286" source="discord" createTime="2022-09-21T02:31:26.588+00:00" retrieveTime="2022-10-17T11:35:13.053450">

TBH I think you'll have a tremendous amount of trouble

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021971938295418932" source="discord" createTime="2022-09-21T02:31:37.41+00:00" retrieveTime="2022-10-17T11:35:13.053450">

good luck!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021971960537825280" source="discord" createTime="2022-09-21T02:31:42.713+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Ah??

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972064816603157" source="discord" createTime="2022-09-21T02:32:07.575+00:00" retrieveTime="2022-10-17T11:35:13.053450">

For design of event handler, or for the whole proposal?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972086887022633" source="discord" createTime="2022-09-21T02:32:12.837+00:00" retrieveTime="2022-10-17T11:35:13.053450">

whole thing

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972107850170449" source="discord" createTime="2022-09-21T02:32:17.835+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Ah

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972304286191717" source="discord" createTime="2022-09-21T02:33:04.669+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I would really be interested in a using a prototype

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972329389109319" source="discord" createTime="2022-09-21T02:33:10.654+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes I will do that

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972357507723284" source="discord" createTime="2022-09-21T02:33:17.358+00:00" retrieveTime="2022-10-17T11:35:13.053450">

do you think it is worthwhile to prototype it

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972369704755201" source="discord" createTime="2022-09-21T02:33:20.266+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but I am worried this would break in many unexpected ways

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972448373125130" source="discord" createTime="2022-09-21T02:33:39.022+00:00" retrieveTime="2022-10-17T11:35:13.053450">

if it is a meaningless proposal, I will just halt *now*

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972701331599412" source="discord" createTime="2022-09-21T02:34:39.332+00:00" retrieveTime="2022-10-17T11:35:13.053450">

It depends on what your goal is. If you want to keep exploring this, I don't see any way forward besides building a prototype. I may yet be wrong, or we may learn something from the proposal even if it doesn't get accepted.

But building a prototype doesn't mean that we're committed to accepting it in the framework or engine

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972830306455612" source="discord" createTime="2022-09-21T02:35:10.082+00:00" retrieveTime="2022-10-17T11:35:13.053450">

or you may find ways to adjust the proposal to implement it with few or no changes to the framework

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972845724704789" source="discord" createTime="2022-09-21T02:35:13.758+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> But building a prototype doesn't mean that we're committed to accepting it in the framework or engine

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021972862703259698" source="discord" createTime="2022-09-21T02:35:17.806+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Sure I know that

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021974345083527208" source="discord" createTime="2022-09-21T02:41:11.233+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Jonah Williams About the event handler problem: In React Fiber example, a programmer has to think about two systems as well - the JS animation system and CSS animation system. They have to think about "the JS animation is jank while CSS animation runs smoothly" and collaborate with that. So in our Flutter even handler problem, maybe it is OK for dev to think about "the ListView  event handler is janky, while the preempt scrolling is smooth"?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021974496510492763" source="discord" createTime="2022-09-21T02:41:47.336+00:00" retrieveTime="2022-10-17T11:35:13.053450">

No

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021974538092818453" source="discord" createTime="2022-09-21T02:41:57.25+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I mean, maybe

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021974552626081863" source="discord" createTime="2022-09-21T02:42:00.715+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but my guess is no

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021974578051956797" source="discord" createTime="2022-09-21T02:42:06.777+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Hmm

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021974617700696104" source="discord" createTime="2022-09-21T02:42:16.23+00:00" retrieveTime="2022-10-17T11:35:13.053450">

It is opt-in. If someone hates it just set flag to false.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021974626617786468" source="discord" createTime="2022-09-21T02:42:18.356+00:00" retrieveTime="2022-10-17T11:35:13.053450">

HTML+CSS+JS Is not exactly a high water mark of ease of use

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021974675049418842" source="discord" createTime="2022-09-21T02:42:29.903+00:00" retrieveTime="2022-10-17T11:35:13.053450">

and its not a goal to be as complicated as it can be

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021974850060955729" source="discord" createTime="2022-09-21T02:43:11.629+00:00" retrieveTime="2022-10-17T11:35:13.053450">

because the problem isn't just that "the ListView  event handler is janky, while the preempt scrolling is smooth"?, its that the ListView only scrolls when pre-empted because I'm actually expecting the events to be sent to a different event handler

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021974855014436977" source="discord" createTime="2022-09-21T02:43:12.81+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I know its limitation and love Flutter (as you can see - I write Flutter code now instead of web code)

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021975024002945044" source="discord" createTime="2022-09-21T02:43:53.1+00:00" retrieveTime="2022-10-17T11:35:13.053450">

or consider the case where the listview is literally covered

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021975056567509033" source="discord" createTime="2022-09-21T02:44:00.864+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> "the ListView only scrolls when pre-empted because I'm actually expecting the events to be sent to a different event handler"
When `preempt: true` they are expecting it to happen maybe?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021975098959351808" source="discord" createTime="2022-09-21T02:44:10.971+00:00" retrieveTime="2022-10-17T11:35:13.053450">

so it wouldn't get events normally because the dispatchEvent code handles that

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021975153095221358" source="discord" createTime="2022-09-21T02:44:23.878+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I will think about thta

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021975156383555604" source="discord" createTime="2022-09-21T02:44:24.662+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but now suddenly its receiving scroll events?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021975471514210314" source="discord" createTime="2022-09-21T02:45:39.795+00:00" retrieveTime="2022-10-17T11:35:13.053450">

With my apologies to @Hixie  😆

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021976107408429158" source="discord" createTime="2022-09-21T02:48:11.404+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I agree that should never happen

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021976421796696194" source="discord" createTime="2022-09-21T02:49:26.36+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Is it possible we let developers manually handle it? Flutter is like a automatic car, but when really needed (for performance), give dev a manual control button?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021976509239545856" source="discord" createTime="2022-09-21T02:49:47.208+00:00" retrieveTime="2022-10-17T11:35:13.053450">

everything is opt in, not opt out

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021976608317378580" source="discord" createTime="2022-09-21T02:50:10.83+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If I'm trying to provide a generic ListView like widget, how can I tell within a frame if I am obscured or not?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021976744095395900" source="discord" createTime="2022-09-21T02:50:43.202+00:00" retrieveTime="2022-10-17T11:35:13.053450">

(generally you don't need to handle this, because the hitTest system does for you)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021976856678912050" source="discord" createTime="2022-09-21T02:51:10.044+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Let the dev do the job. For example, suppose we are developing this Discord mobile app. Then I will specify "it is always visible" if I am the dev.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021976969040117910" source="discord" createTime="2022-09-21T02:51:36.833+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If we are developing docs.google.com I will also specify "always visible"

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021977090951761963" source="discord" createTime="2022-09-21T02:52:05.899+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Of course, except that it is not the latest route entry - but that case is simple to be built-in

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021977148069789696" source="discord" createTime="2022-09-21T02:52:19.517+00:00" retrieveTime="2022-10-17T11:35:13.053450">

that means that nothing in the framework will be able to use this

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021977225823780914" source="discord" createTime="2022-09-21T02:52:38.055+00:00" retrieveTime="2022-10-17T11:35:13.053450">

That maybe means framework needs to accept a parameter

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021977241929916426" source="discord" createTime="2022-09-21T02:52:41.895+00:00" retrieveTime="2022-10-17T11:35:13.053450">

by users

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021977281935183913" source="discord" createTime="2022-09-21T02:52:51.433+00:00" retrieveTime="2022-10-17T11:35:13.053450">

eg. `ListView(prempt: PreemptStrategy?)`

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021977358347030568" source="discord" createTime="2022-09-21T02:53:09.651+00:00" retrieveTime="2022-10-17T11:35:13.053450">

where `abstract class PreemptStrategy { bool shouldWeAcceptThatHitTest(); }`. And provide null to disable preempt.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021977465264025670" source="discord" createTime="2022-09-21T02:53:35.142+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I know it is not an automatic car in such cases 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021977622487519262" source="discord" createTime="2022-09-21T02:54:12.627+00:00" retrieveTime="2022-10-17T11:35:13.053450">

And, for the enter page transition, and the loading indicator, we even do not need gestures handling

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021977662278881332" source="discord" createTime="2022-09-21T02:54:22.114+00:00" retrieveTime="2022-10-17T11:35:13.053450">

you do, because they can be cancelled

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021977799873007626" source="discord" createTime="2022-09-21T02:54:54.919+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I mean, no extra gesture handling at 60fps. Just normal handling at low fps

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978041062277124" source="discord" createTime="2022-09-21T02:55:52.423+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I don't really think it would be OK. You've got a performance improvement that is off by default, and using requires knowing exactly how your layout will look at all times. And nothing in the framework can use it....

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978047118844004" source="discord" createTime="2022-09-21T02:55:53.867+00:00" retrieveTime="2022-10-17T11:35:13.053450">

For example, I tap a button and enter a page. Maybe we do not care that the system cannot respond to my touch *when* the new page is transitioning in (indeed, what gesture will we have there?)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978228262453258" source="discord" createTime="2022-09-21T02:56:37.055+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But, when new page is transitioning in, if that transition is, say, 15fps, humans eyes can see it and feel it not good

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978434815131648" source="discord" createTime="2022-09-21T02:57:26.301+00:00" retrieveTime="2022-10-17T11:35:13.053450">

have you looked at how we made the Android ZoomPageTransition faster  (on master currently)? FWIW It was almost entirely raster thread issues

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978490729398272" source="discord" createTime="2022-09-21T02:57:39.632+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes I followed that github issue

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978552620552234" source="discord" createTime="2022-09-21T02:57:54.388+00:00" retrieveTime="2022-10-17T11:35:13.053450">

ahh right, I remember you were in the Github review

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978576620363827" source="discord" createTime="2022-09-21T02:58:00.11+00:00" retrieveTime="2022-10-17T11:35:13.053450">

haha

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978657645928448" source="discord" createTime="2022-09-21T02:58:19.428+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But when the new page has a ton of widgets, we will face build/layout jank I guess?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978765582143498" source="discord" createTime="2022-09-21T02:58:45.162+00:00" retrieveTime="2022-10-17T11:35:13.053450">

raster slowness is like a separate issue that my current design doc does not address

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978786054549535" source="discord" createTime="2022-09-21T02:58:50.043+00:00" retrieveTime="2022-10-17T11:35:13.053450">

even on the low end android devices I tested, all of the jank was raster jank

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978861120004177" source="discord" createTime="2022-09-21T02:59:07.94+00:00" retrieveTime="2022-10-17T11:35:13.053450">

that or GCs, which you will hit even with your system

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021978997028036638" source="discord" createTime="2022-09-21T02:59:40.343+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Hmm so you are saying we do not need to optimize build/layout jank?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021979112652410991" source="discord" createTime="2022-09-21T03:00:07.91+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Jsouliang do you see build/layout jank in your bytedance app? Or are all of them raster jank?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021979146009727107" source="discord" createTime="2022-09-21T03:00:15.863+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Personally speaking my app has build/layout jank as well

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021979260644229140" source="discord" createTime="2022-09-21T03:00:43.194+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But given it is not open sourced and I cannot say I am the expert in optimization this may not be a big evidence

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021979417234374707" source="discord" createTime="2022-09-21T03:01:20.528+00:00" retrieveTime="2022-10-17T11:35:13.053450">

text layout can be quite slow

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/608021234516754444/1021979601142034535" source="discord" createTime="2022-09-21T03:02:04.375+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Raster jank we call look forward to impeller to solve it, case most raster thread jank are caused by share compile

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/608021234516754444/1021979726463651880" source="discord" createTime="2022-09-21T03:02:34.254+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes, some UI jank are cased the measure text content

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021979750476021850" source="discord" createTime="2022-09-21T03:02:39.979+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I wish that were true, some Skia functionality is actually quite slow the way we use it. Clips for example, not slow due to shader compile. Same with ImageFilters

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/608021234516754444/1021979764883456060" source="discord" createTime="2022-09-21T03:02:43.414+00:00" retrieveTime="2022-10-17T11:35:13.053450">

that will block the UI Layout

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/608021234516754444/1021979927911858209" source="discord" createTime="2022-09-21T03:03:22.283+00:00" retrieveTime="2022-10-17T11:35:13.053450">

do you have some idea to optimize the text measure?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021980209798455427" source="discord" createTime="2022-09-21T03:04:29.49+00:00" retrieveTime="2022-10-17T11:35:13.053450">

We've not had any success

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/608021234516754444/1021980251171061790" source="discord" createTime="2022-09-21T03:04:39.354+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1021980250357371010/2022-09-21_11.04.19.png)
![image](https://cdn.discordapp.com/attachments/608021234516754444/1021980250818756618/2022-09-21_11.04.10.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021980287787352125" source="discord" createTime="2022-09-21T03:04:48.084+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Then maybe my proposal is a bit useful I guess?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021980441080758273" source="discord" createTime="2022-09-21T03:05:24.632+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If your prototype works and doesn't require Flutter 4.0, then maybe

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021980497649336390" source="discord" createTime="2022-09-21T03:05:38.119+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Haha surely not 4.0 - all user visible API are opt in (and btw Flutter 3.0 has no breaking change)

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021980721356754975" source="discord" createTime="2022-09-21T03:06:31.455+00:00" retrieveTime="2022-10-17T11:35:13.053450">

the problem with opt in, is that most folks won't. Similarly, I don't think creating a parallel event handling system is reasonable. I think you will have better luck trying to break apart expensive scenes into multiple frames. But ultimately its your time + resources, so spend them how you see fit

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021980884871680000" source="discord" createTime="2022-09-21T03:07:10.44+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> break apart expensive scenes into multiple frames
I guess that is how hixie, dnfield, bytedance people, and I have tried. No success yet 😦

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021980939838042183" source="discord" createTime="2022-09-21T03:07:23.545+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Anyway I will also try on that

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021982672098168923" source="discord" createTime="2022-09-21T03:14:16.548+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Jonah Williams Another workaround: What if we throw away support for gesture system in preemptRender?
When scrolling a ListView, it is mainly the inertia the drives the list to move, and seems that human finger speed will not dramatically change during a swipe. Then, if we never support gesture in preemptRender, the following will happen: (1) ListView is scrolled at 60fps, instead of (e.g.) 15fps, so user eyes will not see jank. (2) ListView is responding to user finger at only 15fps, but since this is not a game but just a scrolling, users may not feel it

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021982752372957266" source="discord" createTime="2022-09-21T03:14:35.687+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Now we can by default enable the feature, and no parallel event handling system

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021982864344109116" source="discord" createTime="2022-09-21T03:15:02.383+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Btw for the loading indicator and the enter page transition example, already no need for event handling by default

</DiscussionComment>

<DiscussionComment author="Callum" link="https://discord.com/channels/608014603317936148/608021234516754444/1021983030597926952" source="discord" createTime="2022-09-21T03:15:42.021+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I looked at the document, an interesting idea for sure with the synchronous/parallel tree. But I also think it won't be feasible to implement the preemptModifyLayerTree() unless the animation is very simple. The more applicable it is, the more you are just reimplementing the framework.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021983708842037328" source="discord" createTime="2022-09-21T03:18:23.727+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> But I also think it won't be feasible to implement the preemptModifyLayerTree() unless the animation is very simple. The more applicable it is, the more you are just reimplementing the framework.
It already supports the following with simple code, see doc for details:
* any widgets fit within DisplayListLayer, such as CircularProgressIndicator. Arbitrarily fancy animation goes here, as long as in one DisplayListLayer. Or more generally, if they fit in a leaf subtree.
* let ListView scroll at 60fps

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/608021234516754444/1021983909887615007" source="discord" createTime="2022-09-21T03:19:11.66+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Jonah Williams what's the 'ghost text' ?
![image](https://cdn.discordapp.com/attachments/608021234516754444/1021983909887627284/20220921-111837.jpeg)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021985366049312788" source="discord" createTime="2022-09-21T03:24:58.836+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Callum We may integrate with the existing framework and allow a lot of widgets to animate (just a very rough proposal): Indeed what is done in preemptModifyLayerTree is just to modify arbitrary layers, so maybe we can reuse existing framework to arbitrarily render a subtree etc. Not come up with details yet though.
But anyway, I guess most people just need a smooth loading indicator, a smooth scrolling listview?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021985826193813525" source="discord" createTime="2022-09-21T03:26:48.543+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Jonah Williams So is this proposal looks ok? (repeat here in case the original comment is already so above that it is not read)

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021986923293724733" source="discord" createTime="2022-09-21T03:31:10.112+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Rendering placeholder text, like a bunch of grey blocks in place of your actual text on first frames or when doing larger transitions

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1021987187870421053" source="discord" createTime="2022-09-21T03:32:13.192+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If the behavior of the framework is changing substantially in pre-empty frames then I think most developers would interpret that as a bug

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021987751710699632" source="discord" createTime="2022-09-21T03:34:27.622+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But I wonder how should we know how many blocks? You know each english letter has different width, and paragraphing is quite hard to guess. If we put wrong number of grey blocks, the UI will be of wrong height. Then, after it gets the real height, all widgets below it (suppose we have a ListView) will jump

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021987957021868062" source="discord" createTime="2022-09-21T03:35:16.572+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Jonah Williams Well, what about this: It is still the plain old Flutter with (e.g.) 15fps. But we just have some "magic" here, such that it automatically generates something as a "tween" to have 60fps.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1021988294550110259" source="discord" createTime="2022-09-21T03:36:37.045+00:00" retrieveTime="2022-10-17T11:35:13.053450">

IIRC, some researches or nvidia has some "magic" such that, they input some low resolution low fps frames, and output high resolution high fps frames
Consider this proposal as such kind of "tween creator", then maybe dev will feel it natural

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1021993719337058359" source="discord" createTime="2022-09-21T03:58:10.415+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Started a thread.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1021993719337058354" source="discord" createTime="2022-09-21T03:58:10.415+00:00" retrieveTime="2022-10-17T11:35:25.618280">



</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1021993721140621353" source="discord" createTime="2022-09-21T03:58:10.845+00:00" retrieveTime="2022-10-17T11:35:25.618280">

This is a good part of what makes it hard. The difficult case right now isn't the progress indicator, it's when you have a large scene change (like a route transition or some other full screen animation).

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1021993881371418714" source="discord" createTime="2022-09-21T03:58:49.047+00:00" retrieveTime="2022-10-17T11:35:25.618280">

And lets say you want to render a lot of small pieces of text, which now all have to get laid out for the first time and will send you over budget for a single frame.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1021994148284334130" source="discord" createTime="2022-09-21T03:59:52.684+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I see, I guess my proposal can solve the problem?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1021994222368329809" source="discord" createTime="2022-09-21T04:00:10.347+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@dnfield Btw what do you think about the proposal 🙂

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Swc" source="google_doc_comments" createTime="2022-09-21T04:03:57.720Z" retrieveTime="2022-10-17T11:05:47.152504">

Layout for a single widget can easily blow through frame budget. That's part of what we'd like to solve with an interruptible approach, assuming such an approach is possible.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Swg" source="google_doc_comments" createTime="2022-09-21T04:04:10.196Z" retrieveTime="2022-10-17T11:05:47.152504">

This will cause problems with scrolling/touch events.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Swk" source="google_doc_comments" createTime="2022-09-21T04:05:06.582Z" retrieveTime="2022-10-17T11:05:47.152504">

These are not particularly pressing examples right now - showing a single progress indicator or simple animation tends not to be the issue, it's more like doing a full screen route transition where you're building a a large new tree or subtree with a few hundred widgets to inflate and layout.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Sws" source="google_doc_comments" createTime="2022-09-21T04:05:58.504Z" retrieveTime="2022-10-17T11:05:47.152504">

This needs a lot more details about how you would sensibly interrupt and restart layout at a meaningful point.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1021995751154389032" source="discord" createTime="2022-09-21T04:06:14.838+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I think it's interesting but it's missing a lot of important details

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1021997189628706838" source="discord" createTime="2022-09-21T04:11:57.797+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I am willing to fill in details

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1021997228736389150" source="discord" createTime="2022-09-21T04:12:07.121+00:00" retrieveTime="2022-10-17T11:35:25.618280">

and will prototype as well

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1021997250488053840" source="discord" createTime="2022-09-21T04:12:12.307+00:00" retrieveTime="2022-10-17T11:35:25.618280">

so what is missing?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Sww" source="google_doc_comments" createTime="2022-09-21T04:13:53.415Z" retrieveTime="2022-10-17T11:05:47.152504">

Hmm do you mean one single _leaf_ widget? 

Indeed that is also very simple: I am proposing adding `if (timeout) preemptRender()` at the beginning of each RenderObject.layout.

Now, we can add more. Say, for YourHeavyRenderObject.performLayout() function, add 10 of such `if timeout preemptRender`

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Sw0" source="google_doc_comments" createTime="2022-09-21T04:14:24.576Z" retrieveTime="2022-10-17T11:05:47.152504">

That's "that" approach which I am comparing to. My proposal does not have this :)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Sw4" source="google_doc_comments" createTime="2022-09-21T04:16:01.715Z" retrieveTime="2022-10-17T11:05:47.152504">

> showing a single progress indicator or simple animation tends not to be the issue

Well the example is indeed, "have progress indicator 60fps, *while* we are doing something really heavy". i.e. just the interesting case you said :)

Content edited

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgdW1Sw8" source="google_doc_comments" createTime="2022-09-21T04:18:05.939Z" retrieveTime="2022-10-17T11:05:47.152504">

The proposal do not interrupt, neither restart. It just calls a function (the preemptRender).

Not sure but maybe you have the same understanding as @JonahWilliams? This comment may be helpful: https://discord.com/channels/608014603317936148/608021234516754444/1021963804747255929

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1021998838363463690" source="discord" createTime="2022-09-21T04:18:30.886+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I have replied to google doc (not see that just now)

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgfacSXE" source="google_doc_comments" createTime="2022-09-21T12:15:28.332Z" retrieveTime="2022-10-17T11:05:47.152504">

How is this Layertree generated (since the current RO is not painted), it still looks like the LayerTree from the previous frame?

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgfacSXI" source="google_doc_comments" createTime="2022-09-21T12:20:48.095Z" retrieveTime="2022-10-17T11:05:47.152504">

If I understand correctly, you want to use the full LayerTree result from the last time. Like this object in the Raster thread?

https://github.com/flutter/engine/blob/4839a3b5d225f7d522bf9edf5cfe395c187b0e93/shell/common/rasterizer.cc#L381

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022130584279068772" source="discord" createTime="2022-09-21T13:02:01.56+00:00" retrieveTime="2022-10-17T11:35:25.618280">

In the current Framework design, once entering the RenderFlexObject, all child nodes will be Layout, and when the RO tree Layout is completed, paint will be submitted. Now we add a timer to the RenderFlexObject layout, the first child node layout is almost finished (16ms), at which point we interrupt the layout and submit the current RO tree for Paint. At this point, RenderFlexObject contains a child node. When the next schedule comes, do I continue to start from this RenderFlexObject node or something else?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022131117471580190" source="discord" createTime="2022-09-21T13:04:08.683+00:00" retrieveTime="2022-10-17T11:35:25.618280">

So I guess you mean your example has an app which has Flex as its root widget, and thus RenderFlex as its root RenderObject?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022131391699353620" source="discord" createTime="2022-09-21T13:05:14.064+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> When the next schedule comes, do I continue to start from this RenderFlexObject node or something else?
We do not continue to "start from" anywhere. We just *call* the preemptRender function inside `RenderObject.layout()`. And then, when preemptRender function returns, we continue running our code.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022131453099786250" source="discord" createTime="2022-09-21T13:05:28.703+00:00" retrieveTime="2022-10-17T11:35:25.618280">

preemptRender is nothing but a very normal function

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgfusIVM" source="google_doc_comments" createTime="2022-09-21T13:06:00.227Z" retrieveTime="2022-10-17T11:05:47.152504">

Yes, from previous frame, but modified a bit from preemptModifyLayerTree.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgfusIVQ" source="google_doc_comments" createTime="2022-09-21T13:06:28.964Z" retrieveTime="2022-10-17T11:05:47.152504">

Almost the same full layer tree, except for preemptModifylayerTree

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022131706469306388" source="discord" createTime="2022-09-21T13:06:29.111+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I want to know more details of preemptModifyLayerTree CircularProgressIndicator such as you mentioned. What will do in preemptModifyLayerTree?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022131786446282772" source="discord" createTime="2022-09-21T13:06:48.179+00:00" retrieveTime="2022-10-17T11:35:25.618280">

```
void preemptModifyLayerTree() {
  for (final renderObject in renderObjectsWhoWantsToPreemptModifyTheLayerTree) renderObject.preemptModifyLayerTree();
}
```

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022131839164485632" source="discord" createTime="2022-09-21T13:07:00.748+00:00" retrieveTime="2022-10-17T11:35:25.618280">

```
class RenderPreemptDisplayList extends RenderBox {
  @override
  void paint(PaintingContext context, Offset offset) {
    layer = paint_child_subtree_inside_a_DisplayListLayer();
  }

  @override
  void preemptModifyLayerTree() {
    layer = paint_child_subtree_inside_a_DisplayListLayer();
  }
}

```

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022131888640499782" source="discord" createTime="2022-09-21T13:07:12.544+00:00" retrieveTime="2022-10-17T11:35:25.618280">

So, it calls RenderPreemptDisplayList.preemptModifyLayerTree

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022131947541102632" source="discord" createTime="2022-09-21T13:07:26.587+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Then, RenderPreemptDisplayList.preemptModifyLayerTree paints its child.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022132013194547200" source="discord" createTime="2022-09-21T13:07:42.24+00:00" retrieveTime="2022-10-17T11:35:25.618280">

For simplicity, let's say, we do not want a CircularProgressIndicator, but only want a color rect

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022132021784498186" source="discord" createTime="2022-09-21T13:07:44.288+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Then it is like:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022132176910831656" source="discord" createTime="2022-09-21T13:08:21.273+00:00" retrieveTime="2022-10-17T11:35:25.618280">

```
class RenderWhatever extends RenderBox {
  @override
  void paint(PaintingContext context, Offset offset) {
    layer = create_DisplayListLayer_and_paint_a_colored_rect(color: red);
  }

  @override
  void preemptModifyLayerTree() {
    layer = create_DisplayListLayer_and_paint_a_colored_rect(color: whatever_color_you_like_in_animation);
  }
}
```

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022132562606440488" source="discord" createTime="2022-09-21T13:09:53.23+00:00" retrieveTime="2022-10-17T11:35:25.618280">

What would you do in the `paint_child_subtree_inside_a_DisplayListLayer` method at this point in the interrupt, maybe the child node hasn't been built/laid out yet?

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022132763761053716" source="discord" createTime="2022-09-21T13:10:41.189+00:00" retrieveTime="2022-10-17T11:35:25.618280">

`    layer = create_DisplayListLayer_and_paint_a_colored_rect(color: red);`
 like placeholder ？

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022132843473809458" source="discord" createTime="2022-09-21T13:11:00.194+00:00" retrieveTime="2022-10-17T11:35:25.618280">

For circular progress indicator, just paint a indicator you need

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022132900289851432" source="discord" createTime="2022-09-21T13:11:13.74+00:00" retrieveTime="2022-10-17T11:35:25.618280">

for scrolling listview, it is a longer story, maybe see doc

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-21T13:15:53Z" retrieveTime="2022-10-17T11:45:49.046468">

For readers of GitHub and not yet read Discord: Some discussions happen in Discord as well, see - https://discord.com/channels/608014603317936148/608021234516754444/1021783497112821861

As well as the sub-discussion in discord: https://discord.com/channels/608014603317936148/1021987751710699632

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022136927232720916" source="discord" createTime="2022-09-21T13:27:13.838+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@fzyzcjy  The build/layout phase is a recursive call, how do you break it?On keframe, we're actually doing recursion on the current frame, just using placeholders

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022137348475068487" source="discord" createTime="2022-09-21T13:28:54.27+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Just do not break it 🙂 We are *calling* preemptRender. The call stack become deeper when calling that function

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022137580600438815" source="discord" createTime="2022-09-21T13:29:49.613+00:00" retrieveTime="2022-10-17T11:35:25.618280">


![image](https://cdn.discordapp.com/attachments/1021987751710699632/1022137580218761226/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022137683688030228" source="discord" createTime="2022-09-21T13:30:14.191+00:00" retrieveTime="2022-10-17T11:35:25.618280">

In that figure, a rectangle means the life of a function.

</DiscussionComment>

<DiscussionComment author="JsouLiang" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022137801099190334" source="discord" createTime="2022-09-21T13:30:42.184+00:00" retrieveTime="2022-10-17T11:35:25.618280">

so for not layout node we will paint a placeholder rect like this?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022137931881795694" source="discord" createTime="2022-09-21T13:31:13.365+00:00" retrieveTime="2022-10-17T11:35:25.618280">

We will know nothing for a node that *has not* been painted *before* this frame

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022137959962644480" source="discord" createTime="2022-09-21T13:31:20.06+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Because it is not in the layer tree

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022138051855667302" source="discord" createTime="2022-09-21T13:31:41.969+00:00" retrieveTime="2022-10-17T11:35:25.618280">

No placeholder rect indeed. But if you like, what about just putting a placeholder rect there, in previous frame

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022138088354480258" source="discord" createTime="2022-09-21T13:31:50.671+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Well the story is like:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022138149327085609" source="discord" createTime="2022-09-21T13:32:05.208+00:00" retrieveTime="2022-10-17T11:35:25.618280">

https://discord.com/channels/608014603317936148/608021234516754444/1021988294550110259

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022138208898781204" source="discord" createTime="2022-09-21T13:32:19.411+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Some researches or nvidia has some "magic" such that, they input some low resolution low fps frames, and output high resolution high fps frames. Consider this proposal as such kind of "tween creator".

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022138382106771496" source="discord" createTime="2022-09-21T13:33:00.707+00:00" retrieveTime="2022-10-17T11:35:25.618280">

So this proposal will output some extra frames, which are just "previous jank frame's layer tree + preemotModifyLayerTree minor changes like animation"

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022138949931634688" source="discord" createTime="2022-09-21T13:35:16.087+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Does this mean that the build/layout of all nodes needs to be synchronized for this to happen? Normally build, layout are recursive calls.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022139119264075839" source="discord" createTime="2022-09-21T13:35:56.459+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> Does this mean that the build/layout of all nodes needs to be synchronized for this to happen? Normally build, layout are recursive calls.
It is still recursive call. Just like plain old. Except that one extra line:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022139135709945856" source="discord" createTime="2022-09-21T13:36:00.38+00:00" retrieveTime="2022-10-17T11:35:25.618280">

```
class RenderObject {
  void layout(Constraints constraints, { bool parentUsesSize = false }) {
    if (nearTimeout) { preemptRender(); }
    … the original layout code …
  }
}
```

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022141575133929614" source="discord" createTime="2022-09-21T13:45:41.984+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I kind of figured it out. The core thing is that when my time is running out, submit a LayerTree to the engine in `preemptRender` for rendering, and then continue with layout (The recursion does not exit at this point
).

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022141675839180829" source="discord" createTime="2022-09-21T13:46:05.994+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Yes!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022141746286702642" source="discord" createTime="2022-09-21T13:46:22.79+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Then we get zero overhead for a lot of thing, etc

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022141794525401098" source="discord" createTime="2022-09-21T13:46:34.291+00:00" retrieveTime="2022-10-17T11:35:25.618280">

What if the whole element tree and RO tree change in the next frame

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022141849995063376" source="discord" createTime="2022-09-21T13:46:47.516+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Just do the same thing in the next cycle

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022141859230928947" source="discord" createTime="2022-09-21T13:46:49.718+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Is there any problem

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022141913366810754" source="discord" createTime="2022-09-21T13:47:02.625+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Just use this mimic

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022142732887670905" source="discord" createTime="2022-09-21T13:50:18.014+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Is paint applied to the parent of the interrupt node? I'm more concerned with the generation of this Layertree.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022143507558834216" source="discord" createTime="2022-09-21T13:53:22.71+00:00" retrieveTime="2022-10-17T11:35:25.618280">

No

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022143624709935125" source="discord" createTime="2022-09-21T13:53:50.641+00:00" retrieveTime="2022-10-17T11:35:25.618280">

no paint is happened in preemptRender, except for preemptModifyLayerTree - which only few specialized RO will handle

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022143715445325896" source="discord" createTime="2022-09-21T13:54:12.274+00:00" retrieveTime="2022-10-17T11:35:25.618280">

but anyway, if you use PreemptDisplayList and put progress indicator as its child, then that child does get painted

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022144207617527848" source="discord" createTime="2022-09-21T13:56:09.617+00:00" retrieveTime="2022-10-17T11:35:25.618280">

The key point I think is that the generation of this Layertree, if we just call preemptRender(), For example, `layer = create_DisplayListLayer_and_paint_a_colored_rect(color: whatever_color_you_like_in_animation);`  , it could be very different from the previous UI

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022145486444056636" source="discord" createTime="2022-09-21T14:01:14.513+00:00" retrieveTime="2022-10-17T11:35:25.618280">

We do not generate a whole new layer tree. Instead, we modify it a little bit in the preemptModifyLayerTree

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022145565699612773" source="discord" createTime="2022-09-21T14:01:33.409+00:00" retrieveTime="2022-10-17T11:35:25.618280">

For example, modify the color of a box a little bit, modify the shifting of the listview a bit

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022145618166157332" source="discord" createTime="2022-09-21T14:01:45.918+00:00" retrieveTime="2022-10-17T11:35:25.618280">

so it will be very similar to previous (janky) frame except for a bit of animation change

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022145714115067975" source="discord" createTime="2022-09-21T14:02:08.794+00:00" retrieveTime="2022-10-17T11:35:25.618280">

surely it may be different from next frame, if your prev frame is diff from next frame - but that definitely should be like that

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022146721645596773" source="discord" createTime="2022-09-21T14:06:09.008+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Yes, I think it depends on the height similarity between the two frames

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022147860646600797" source="discord" createTime="2022-09-21T14:10:40.567+00:00" retrieveTime="2022-10-17T11:35:25.618280">

There are two issues I would love to see more detail on: 
1. How to generate this Layertree to the Engine when an interrupt occurs (e.g., two frames are completely different) 
2. How to handle vsync scheduling in case of interruption (for example, the whole Widget tree changes in the next vsync)

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022147953902759956" source="discord" createTime="2022-09-21T14:11:02.801+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Would you consider making a prototype of this solution any time soon?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022148131804151829" source="discord" createTime="2022-09-21T14:11:45.216+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> How to generate this Layertree to the Engine when an interrupt occurs (e.g., two frames are completely different)
Since when preemptRender happens, we are in build & layout phase, we never touch layer tree yet. So we have the old layer tree. Now, we provide the old layer tree (with minor modify from preemptModifyLayerTree), to the engine

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022148419046866964" source="discord" createTime="2022-09-21T14:12:53.7+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> How to handle vsync scheduling in case of interruption (for example, the whole Widget tree changes in the next vsync)
No vsync is passed to dart layer during jank. Say we have a build/layout that takes 1s. Then during the 60 hardware vsync, we render 60 frames to screen via preemptRender. However, for the Dart code (excluding the preemptRender part), it only sees *one* vsync, *one* build/paint/layout/etc.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022148441746440192" source="discord" createTime="2022-09-21T14:12:59.112+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> Would you consider making a prototype of this solution any time soon?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022148462906724436" source="discord" createTime="2022-09-21T14:13:04.157+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Sure 🙂

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022149372185686128" source="discord" createTime="2022-09-21T14:16:40.946+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I think the core is the design of this `preemptModifyLayerTree` which sounds similar to some low FPS conversion high FPS (inserting excessive frames in the middle).

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022149456407314502" source="discord" createTime="2022-09-21T14:17:01.026+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Yes, I have said that here:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022149493371711488" source="discord" createTime="2022-09-21T14:17:09.839+00:00" retrieveTime="2022-10-17T11:35:25.618280">

https://discord.com/channels/608014603317936148/608021234516754444/1021987957021868062

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022149552012263494" source="discord" createTime="2022-09-21T14:17:23.82+00:00" retrieveTime="2022-10-17T11:35:25.618280">

and here: https://discord.com/channels/608014603317936148/1021987751710699632/1022138208898781204

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022150021883383838" source="discord" createTime="2022-09-21T14:19:15.846+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Indeed I am inserting a paragraph saying similar things into the doc at the same minute haha
![image](https://cdn.discordapp.com/attachments/1021987751710699632/1022150020344070244/unknown.png)
![image](https://cdn.discordapp.com/attachments/1021987751710699632/1022150020788654110/unknown.png)

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022150200313266247" source="discord" createTime="2022-09-21T14:19:58.387+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Yes, (sorry I didn't really understand that before)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022150233808982176" source="discord" createTime="2022-09-21T14:20:06.373+00:00" retrieveTime="2022-10-17T11:35:25.618280">


![image](https://cdn.discordapp.com/attachments/1021987751710699632/1022150233473417246/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022150268843987016" source="discord" createTime="2022-09-21T14:20:14.726+00:00" retrieveTime="2022-10-17T11:35:25.618280">

That's OK

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022152307984584764" source="discord" createTime="2022-09-21T14:28:20.895+00:00" retrieveTime="2022-10-17T11:35:25.618280">

If the core is `preemptModifyLayerTree`, that means when you want do some high priority render, you have to implement it?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022152899582754897" source="discord" createTime="2022-09-21T14:30:41.943+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Yes and no. 
1. For whatever widget tree that fit in a layer subtree without disturbing others, like a CircularProgressIndicator, reuse existing (well, to-be-written) PreemptDisplayList
2. For listview scrolling, maybe just let ListView's RO implement preemptModifyLayerTree to implement inertia etc. (The design doc is a bit old, see discussions above for details)
3. But I will think about more general solution to support arbitrary case. Anyway this is not the top priority - we should have the main idea running

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022153705920921630" source="discord" createTime="2022-09-21T14:33:54.189+00:00" retrieveTime="2022-10-17T11:35:25.618280">

that means a new mechanism to implement for widgets who want use it, and has a cost to migrate

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022153885541998693" source="discord" createTime="2022-09-21T14:34:37.014+00:00" retrieveTime="2022-10-17T11:35:25.618280">

For widgets who want 60fps, I guess not much - you can reuse it in many places

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022154012226748476" source="discord" createTime="2022-09-21T14:35:07.218+00:00" retrieveTime="2022-10-17T11:35:25.618280">

It is like, we write down computeIntrinsicWidth, performLayout, performDryLayout, etc, a lot of things manually nowadays

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022154256196829195" source="discord" createTime="2022-09-21T14:36:05.385+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Notice we never need to implement new functions for things like CircularProgressIndicator

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022154342666604574" source="discord" createTime="2022-09-21T14:36:26.001+00:00" retrieveTime="2022-10-17T11:35:25.618280">

for those, just use the existing (will-be-in-framework) PreemptDisplayList

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022154720980258907" source="discord" createTime="2022-09-21T14:37:56.198+00:00" retrieveTime="2022-10-17T11:35:25.618280">

And according to you pseudo code, one RO has a layer for previous frame, if it laid with all its relative parts, what should we do for its layer, will it be updated? and what happened when it completed?
Did that means layer painting is un-interrupted?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022154930213101578" source="discord" createTime="2022-09-21T14:38:46.083+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> if it laid with all its relative parts
Do you mean, what happen if that RO has its layer be the new data (instead of old data of previous frame)?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022154962270179429" source="discord" createTime="2022-09-21T14:38:53.726+00:00" retrieveTime="2022-10-17T11:35:25.618280">

That will not happen. We only preempt during build & layout phase. Paint is not happen yet

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022155160287445063" source="discord" createTime="2022-09-21T14:39:40.937+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I got it, layers only change when paint commit

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022155199147671583" source="discord" createTime="2022-09-21T14:39:50.202+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Yes, IIRC

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022155442824159242" source="discord" createTime="2022-09-21T14:40:48.299+00:00" retrieveTime="2022-10-17T11:35:25.618280">

So there is no such thing like Fiber do, build/layout, record and diff?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022155514773258240" source="discord" createTime="2022-09-21T14:41:05.453+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Maybe yes?

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022156434760269905" source="discord" createTime="2022-09-21T14:44:44.795+00:00" retrieveTime="2022-10-17T11:35:25.618280">

What if the `preemptModifyLayerTree` overcost?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022156603660697612" source="discord" createTime="2022-09-21T14:45:25.064+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Then it janks, surely

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022156617799696425" source="discord" createTime="2022-09-21T14:45:28.435+00:00" retrieveTime="2022-10-17T11:35:25.618280">

but why it overcost

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022156698871402607" source="discord" createTime="2022-09-21T14:45:47.764+00:00" retrieveTime="2022-10-17T11:35:25.618280">

when the implement sucks

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022156706198847548" source="discord" createTime="2022-09-21T14:45:49.511+00:00" retrieveTime="2022-10-17T11:35:25.618280">

e.g. painting a tiny progress indicator, should be fast; for listview scrolling example, just modify a little bit of OffsetLayer.offset

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022156765103669288" source="discord" createTime="2022-09-21T14:46:03.555+00:00" retrieveTime="2022-10-17T11:35:25.618280">

It is like asking "what if you misuse flutter" - answer is you get trouble 🙂

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022158210309820436" source="discord" createTime="2022-09-21T14:51:48.119+00:00" retrieveTime="2022-10-17T11:35:25.618280">

A question popped into my mind, I'm thinking of what the difference between this and Keframe(Especially after your optimization, build/layout as many widgets as possible in one frame)? For example, for some Wigdet you mentioned, need to implement preemptModifyLayerTree, and in this case, what if you use KeFrame and you set a placeholder like that?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022158616666587247" source="discord" createTime="2022-09-21T14:53:25.002+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> tell me the difference between this and Keframe
I am going to sleep in a minute, will compare it tomorrow morning. Indeed the design doc has talked a little bit, and github issues also talked a bit.

</DiscussionComment>

<DiscussionComment author="SecondFlight" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022158676565430372" source="discord" createTime="2022-09-21T14:53:39.283+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@fzyzcjy Hey! I've been lurking on the GitHub thread and didn't want to ask this there as I feel like I'm missing something.

Does your most recent proposal allow trivial layout changes to take priority over multi-frame changes? It seems a lot of nontrivial animations require some amount of layout shifting, but your diagram seems to indicate that all widgets must still build and layout in turn, so if an expensive widget needed to rebuild in a different part of the tree then it would still jank since the animation builder would still need to wait its turn.

Sorry if this is somewhat ignorant, I'm still trying to wrap my mind around it all.

</DiscussionComment>

<DiscussionComment author="SecondFlight" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022158725873664070" source="discord" createTime="2022-09-21T14:53:51.039+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Also please sleep if you need to, the question can wait 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022158850192855142" source="discord" createTime="2022-09-21T14:54:20.679+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@SecondFlight Hi, I will reply tomorrow morning 🙂

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022159079478661151" source="discord" createTime="2022-09-21T14:55:15.345+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Well, I actually know the answer to that, but I think it might need to be spelled out a little bit more clearly

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022159499781484624" source="discord" createTime="2022-09-21T14:56:55.553+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I'm still looking forward to your prototype ，Well done

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022159538683662387" source="discord" createTime="2022-09-21T14:57:04.828+00:00" retrieveTime="2022-10-17T11:35:25.618280">

good night 🌙

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022159633785290862" source="discord" createTime="2022-09-21T14:57:27.502+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Thanks, good night

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022189103132987392" source="discord" createTime="2022-09-21T16:54:33.542+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I've already lost track of this thread, but I think there's some good questions here about how this would work in a flex based widget (e.g. a column or row). We also should try to think about how it'd work in general for multi-child ROs

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022272736648757341" source="discord" createTime="2022-09-21T22:26:53.326+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I think we should probably have  a linter that sorts `required` keyword parameters first.  See this screenshot of the api popup in vscode, you have to scroll around and hunt for the signature of itembuilder
![image](https://cdn.discordapp.com/attachments/608021234516754444/1022272736682324020/Screen_Shot_2022-09-21_at_3.11.03_PM.png)

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022276047904981132" source="discord" createTime="2022-09-21T22:40:02.791+00:00" retrieveTime="2022-10-17T11:35:13.053450">

https://github.com/dart-lang/linter/issues/3708

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022282476191756288" source="discord" createTime="2022-09-21T23:05:35.414+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Jonah Williams Continuing from the problem of gesture subsystem of the design, here is a mental modal:

Some researchers/nvidia/etc have some "magic" such that, they can input some low resolution low fps frames, and output high resolution high fps frames. Consider this proposal as such a kind of "tween creator". In other words, originally we have janky rendering (say, 15fps). And now, we add three extra animating frames after each of the 15fps frames, to get a 60fps smooth feeling.

(Copied from updated design doc)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022282608626892891" source="discord" createTime="2022-09-21T23:06:06.989+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> I've already lost track of this thread
Ah feel free to ask any questions and I am willing to answer!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022282692638806026" source="discord" createTime="2022-09-21T23:06:27.019+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> how this would work in a flex based widget (e.g. a column or row). We also should try to think about how it'd work in general for multi-child ROs
It works well, no need to do any special treatment indeed 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022282837015150662" source="discord" createTime="2022-09-21T23:07:01.441+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@dnfield Btw I have answered your comments in google doc as well

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022283305078501416" source="discord" createTime="2022-09-21T23:08:53.036+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> allow trivial layout changes to take priority over multi-frame changes
yes, allow things like a animating indicator or a scrolling listview to take priority over normal janky heavy build/layout

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022283500801499156" source="discord" createTime="2022-09-21T23:09:39.7+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> if an expensive widget needed to rebuild in a different part of the tree then it would still jank since the animation builder would still need to wait its turn

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022283729735000186" source="discord" createTime="2022-09-21T23:10:34.282+00:00" retrieveTime="2022-10-17T11:35:25.618280">

If you mean that, your animation requires an expensive widget built onto a different part of tree, then yes it will jank

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022284203703939164" source="discord" createTime="2022-09-21T23:12:27.285+00:00" retrieveTime="2022-10-17T11:35:25.618280">

But will that be common? "some amount of layout shifting" - For example, a scrolling listview is very common case where we need 60fps smoothness. See the design doc, it indeed only needs a tiny change to OffsetLayer.offset

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022284953779707906" source="discord" createTime="2022-09-21T23:15:26.117+00:00" retrieveTime="2022-10-17T11:35:25.618280">

(I will update the doc probably within an hour)

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1022285320395444265" source="discord" createTime="2022-09-21T23:16:53.525+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I understand the argument you are trying to make but I don't find it convincing. Adding a second gesture system is not reasonable IMO. You should be working on how to eliminate that from your proposal. More time spent discussing with me is not going to help you there

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022285591246815292" source="discord" createTime="2022-09-21T23:17:58.101+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> Adding a second gesture system is not reasonable IMO.
I am proposing to have *no* second gesture system 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022285654723399760" source="discord" createTime="2022-09-21T23:18:13.235+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Ok I will update my proposal, reflecting there is no second gesture system at all

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022285676080791633" source="discord" createTime="2022-09-21T23:18:18.327+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Forget to do that, sorry

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022286314336428143" source="discord" createTime="2022-09-21T23:20:50.499+00:00" retrieveTime="2022-10-17T11:35:13.053450">

And I am going to prototype today btw

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK6o" source="google_doc_comments" createTime="2022-09-21T23:28:16.183Z" retrieveTime="2022-10-17T11:05:47.152504">

I don't see a clear description of what your proposal is.  The first information under "detailed design" are questions.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK7E" source="google_doc_comments" createTime="2022-09-21T23:29:52.258Z" retrieveTime="2022-10-17T11:05:47.152504">

I should move it, wait a minute

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022288819921367122" source="discord" createTime="2022-09-21T23:30:47.877+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I don't understand the proposal, is it that if `build + layout > 1/60ms`  then capture a continuation of that work, submit a frame to the renderer, and finish the build/layout on the next frame?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022289152034742292" source="discord" createTime="2022-09-21T23:32:07.059+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Jonah Williams Hi I have removed gesture system from the proposal, and also add explanations why that looks reasonable. Mainly change the "example 2 implementation" at the bottom of proposal.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022289260725948536" source="discord" createTime="2022-09-21T23:32:32.973+00:00" retrieveTime="2022-10-17T11:35:13.053450">

"on the next frame" - if it is quite slow, maybe on the next next next frame etc indeed

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022289372340564038" source="discord" createTime="2022-09-21T23:32:59.584+00:00" retrieveTime="2022-10-17T11:35:13.053450">

"capture a continuation of that work" - Well I do not capture anything. The `preemptRender` is nothing but a normal function call.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022289479584731166" source="discord" createTime="2022-09-21T23:33:25.153+00:00" retrieveTime="2022-10-17T11:35:13.053450">

We just *call* preemptRender, which sends layer tree to raster it, and later when it *returns* we continue doing layout/build

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022289545619845150" source="discord" createTime="2022-09-21T23:33:40.897+00:00" retrieveTime="2022-10-17T11:35:13.053450">

what are you rendering while that work is happening?  a partial representation of the ui or the previous ui?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022289686045143103" source="discord" createTime="2022-09-21T23:34:14.377+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Previous layer tree (given that we preempt at build/layout, no modify to layer tree in current frame). But, we call preemptModifylayerTree, which modifies the layer a little bit for animations

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022289784015700020" source="discord" createTime="2022-09-21T23:34:37.735+00:00" retrieveTime="2022-10-17T11:35:13.053450">

e.g. in listview scrolling example, we call OffsetLayer.offset += 123.45 so content is moved

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022289878379139142" source="discord" createTime="2022-09-21T23:35:00.233+00:00" retrieveTime="2022-10-17T11:35:13.053450">

ahh so, the previous layer, but some effort is made it keep it animating, interesting

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022289946234585098" source="discord" createTime="2022-09-21T23:35:16.411+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes, like that

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022289962844037150" source="discord" createTime="2022-09-21T23:35:20.371+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Thanks 🙂

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022290422132908113" source="discord" createTime="2022-09-21T23:37:09.874+00:00" retrieveTime="2022-10-17T11:35:13.053450">

do you have a profile of those build + layout frames that are going over budget by any chance?

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022290592039964813" source="discord" createTime="2022-09-21T23:37:50.383+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I believe it can happen, but my first thought would be that maybe something like synchronous calls that shouldn't be synchronous are happening.

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK7c" source="google_doc_comments" createTime="2022-09-21T23:41:52.568Z" retrieveTime="2022-10-17T11:05:47.152504">

I think that stuff we just said on the discord would be a good description: preempt build/layout, update the last layer, render the last frame, resume build/layout

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022291692646318111" source="discord" createTime="2022-09-21T23:42:12.788+00:00" retrieveTime="2022-10-17T11:35:13.053450">

IIRC some discussions above confirm this jank does happens (especially on low end devices), let me find a link

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022291862729527357" source="discord" createTime="2022-09-21T23:42:53.339+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Around this comment: https://discord.com/channels/608014603317936148/608021234516754444/1021980287787352125

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022291936884826192" source="discord" createTime="2022-09-21T23:43:11.019+00:00" retrieveTime="2022-10-17T11:35:13.053450">

In short: bytedance people reported jank of build/layout in their real world app

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022292055847862342" source="discord" createTime="2022-09-21T23:43:39.382+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I am not bytedance so maybe need to ask them for a profiling data

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022292185225367644" source="discord" createTime="2022-09-21T23:44:10.228+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I also see jank in my app, but given that I am not expert in optimization and the app is not open sourced, my words is not that helpful

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK7o" source="google_doc_comments" createTime="2022-09-21T23:44:41.631Z" retrieveTime="2022-10-17T11:05:47.152504">

Thanks! I will add that

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022292715221831680" source="discord" createTime="2022-09-21T23:46:16.589+00:00" retrieveTime="2022-10-17T11:35:13.053450">

A couple of months ago I looked into build/layout performance.  I tried to squeeze as much as I could out of the framework but ran out of ideas.  My understanding from looking into is a lot of jank was shader compilation.  The thing that might be holding back layout / build is locality which will be hard to fix.  But I didn't see a lot of evidence from what I remember that it is worth the investment =T

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK8I" source="google_doc_comments" createTime="2022-09-21T23:47:38.511Z" retrieveTime="2022-10-17T11:05:47.152504">

the way flutter does build and layout is interleaved, but not fine-grained. lots of building happens, then lots of layout, then lots of building, etc. You can run out of time at any time in this process, with a hundred widgets built but not laid out, for example. now the system is in a very inconsistent state.

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022293294773981184" source="discord" createTime="2022-09-21T23:48:34.765+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I guess my point is that if you want to propose a solution that fixes long (build + layout) times, we should establish that that is a worthwhile problem to fix backed up with some data.

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK8M" source="google_doc_comments" createTime="2022-09-21T23:48:55.117Z" retrieveTime="2022-10-17T11:05:47.152504">

since we haven't done paint yet, what we're painting here is just the last frame. there's no need to send it to the engine, it's already got it.

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK8Q" source="google_doc_comments" createTime="2022-09-21T23:51:38.614Z" retrieveTime="2022-10-17T11:05:47.152504">

how does it know what to do?

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK8U" source="google_doc_comments" createTime="2022-09-21T23:52:01.162Z" retrieveTime="2022-10-17T11:05:47.152504">

what if the preempt happened before the progress indicator got to rebuild?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022294891805552672" source="discord" createTime="2022-09-21T23:54:55.527+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Thanks I will add a section to design doc. 
"shader compilation" - seems that @Jsouliang has mentioned above, they expect Impeller to solve the problem. Personally speaking I am not very sure b/c have not checked into impeller deeply.
"might be holding back layout / build is locality" - could you please elaborate it a bit - Do you mean memory locality that causes page fault etc? Anyway, *any form* of build/layout slowness can be fixed by this proposal, no matter the cause. Even if you just heavily compute synchronously inside initState, this proposal can also fix 🙂
"I guess my point is that if you want to propose a solution that fixes long (build + layout) times, we should establish that that is a worthwhile problem to fix backed up with some data." - I agree. I wonder whether this is enough: @dnfield has gived a pointer, "A good canonical case here would be something like https://github.com/flutter/flutter/blob/master/dev/benchmarks/macrobenchmarks/lib/src/list_text_layout.dart. This ends up being janky because layout gets expensive for all that text (on a lower end phone it can easily take 20-30+ms just to layout all the text there, and the ListTile is a little deceptive because Material introduces expense - this is the kind of thing we want to figure out how to break up "automatically")."

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022296432738320454" source="discord" createTime="2022-09-22T00:01:02.914+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Oh interesting, I hadn't seen the list text layout benchmark.  WRT heavily computing inside initState shouldn't happen on the isolate, we should be giving users the tools to quickly offload work to a background isolate.  I think flutter/dart can do better there.  With the locality, yea talking about memory locality.  When I ran profiles I saw numbers that couldn't be associated with a single widget.  I suspect it is the recursive nature of crawling down the widget / render trees which jumps all over in memory.  Also Dart doesn't have value types so every single rectangle in layout is an indirection to another location in memory.  The locality thing is my pet theory, I can't prove it though 😛

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022297458941902888" source="discord" createTime="2022-09-22T00:05:07.58+00:00" retrieveTime="2022-10-17T11:35:13.053450">

also @fzyzcjy you should look into impeller, i haven't run it recently and I don't want to hype it much, but it should make a huge impact.  it's almost not worth looking into jank until after it.  you can turn it on with a flag.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022297793555083274" source="discord" createTime="2022-09-22T00:06:27.358+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> WRT heavily computing inside initState shouldn't happen on the isolate, we should be giving users the tools to quickly offload work to a background isolate.
Sure, that should be a misuse in most of the time 🙂
But indeed, sometimes it is sane to do so. For a simple example, you may have a giant tree in main isolate, and have to modify a lot of its nodes. It is hard (or impossible) to send it to another isolate, modify, and go back, otherwise copying is either too slow or even impossible for some types of objects. Anyway that is just a side remark, and my proposal is not designed to solely solve this special case

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022297942452875365" source="discord" createTime="2022-09-22T00:07:02.858+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> With the locality, yea talking about memory locality.  When I ran profiles I saw numbers that couldn't be associated with a single widget.  I suspect it is the recursive nature of crawling down the widget / render trees which jumps all over in memory.   Also Dart doesn't have value types so every single rectangle in layout is an indirection to another location in memory.  The locality thing is my pet theory, I can't prove it though 😛
I see. So my design should solve it 😛

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022298136930168852" source="discord" createTime="2022-09-22T00:07:49.225+00:00" retrieveTime="2022-10-17T11:35:13.053450">

IMHO impeller is purely about raster thread? (Correct me if I am wrong!) In other words, even if we have impeller, if our *dart* code janks, it still janks just like the old days

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK9A" source="google_doc_comments" createTime="2022-09-22T00:09:05.191Z" retrieveTime="2022-10-17T11:05:47.152504">

Sure. Then I should insert `if timeout then preemptRender` into the `build()` as well, and seems we have no problem.

Btw, no inconsistent state :) I am sending the _layer tree_ in preemptRender, so I just accept the dart state to be completely in middle

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022298635632918619" source="discord" createTime="2022-09-22T00:09:48.125+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I can't remember for sure but shader compilation may happen on the platform thread while the raster thread waits for it synchronously.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK9E" source="google_doc_comments" createTime="2022-09-22T00:10:03.149Z" retrieveTime="2022-10-17T11:05:47.152504">

Last frame,  but plus "preemptModifyLayerTree". For the scrolling listview example, we will modify the OffsetLayer.offset a bit (the amount by inertia). Then, users will see the list content shifted a little bit. So users will see list scrolling smoothly at 60fps, even if one build/layout/paint/... cycle takes, say, 10fps.

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022298850918158356" source="discord" createTime="2022-09-22T00:10:39.453+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> It is hard (or impossible) to send it to another isolate, modify, and go back, 
Yea a couple months ago I tried to come up with a way to get move semantics for sending data between isolates in constant time.  I couldn't find a good proposal that the dart team liked.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK9I" source="google_doc_comments" createTime="2022-09-22T00:10:42.809Z" retrieveTime="2022-10-17T11:05:47.152504">

See examples below, flutter framework dev (e.g. me) write down some code to cover a range of cases. Users can also write some if want very special behavior

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK9M" source="google_doc_comments" createTime="2022-09-22T00:11:20.716Z" retrieveTime="2022-10-17T11:05:47.152504">

No problem :) Progress indicator updates the UI also inside preemptModifyLayerTree, and that is why it is smooth 60fps.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1022299041490550815" source="discord" createTime="2022-09-22T00:11:24.889+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Isolate.exit does send most data in constant time

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1022299102769332305" source="discord" createTime="2022-09-22T00:11:39.499+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but that doesn't help for long-lived isolates of course, just `compute`

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022299257744654450" source="discord" createTime="2022-09-22T00:12:16.448+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yeah, but the problem is I have to send data to that new isolate, which is linear. Anyway, that is just a special corner case, and my proposal does not aim to solve it as the main problem

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022299332751405108" source="discord" createTime="2022-09-22T00:12:34.331+00:00" retrieveTime="2022-10-17T11:35:13.053450">

yea, sorry to digress but it's an interesting problem

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022299348131909742" source="discord" createTime="2022-09-22T00:12:37.998+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I see. Btw platform thread is not ui thread IIRC, so ui thread is still ok?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022299381879291964" source="discord" createTime="2022-09-22T00:12:46.044+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Haha I also feel it interesting

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022299507666456647" source="discord" createTime="2022-09-22T00:13:16.034+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Const time transfering in both side will be quite helpful indeed

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022299954825400360" source="discord" createTime="2022-09-22T00:15:02.645+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yea, sorta, but if you are blocking the platform thread you can be blocking events which feels janky.  it really depends on the embedder too what effect it can have.  I'm not saying build/layout isn't a potential issue, but from my having looked into this a couple months ago I think shader compilation was by and far the biggest issue which is good the flutter team is making a big investment there

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022300039516799088" source="discord" createTime="2022-09-22T00:15:22.837+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i gotta run, good luck @fzyzcjy nice meeting you

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022300083997376563" source="discord" createTime="2022-09-22T00:15:33.442+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I see. Eagerly looking to see impeller be in production as well!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022300111293906954" source="discord" createTime="2022-09-22T00:15:39.95+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@gaaclarke See you 🙂 Nice meeting you

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022300571673305108" source="discord" createTime="2022-09-22T00:17:29.713+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Hixie Btw I have replied your questions on google doc (not seeing it just now)

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK90" source="google_doc_comments" createTime="2022-09-22T00:47:21.780Z" retrieveTime="2022-10-17T11:05:47.152504">

This is the part I don't really understand.

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK94" source="google_doc_comments" createTime="2022-09-22T00:47:48.550Z" retrieveTime="2022-10-17T11:05:47.152504">

How does the framework know this is the one that needs painting?

What if it this is the slow part?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK98" source="google_doc_comments" createTime="2022-09-22T00:49:30.019Z" retrieveTime="2022-10-17T11:05:47.152504">

Users manually write down "PreemptDisplayList(child:CircularProgressIndicator(preempt: false, … other argos …),)"

Then, when framework wants to preempt render an extra frame, it calls PreemptDisplayList.preemptModifyLayerTree.

> What if it this is the slow part?

Then it jank. But IMHO this happens rarely, at least should be ok for progress indicator and scrolling list view - could you please provide some real world case where it will be slow?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK-A" source="google_doc_comments" createTime="2022-09-22T00:50:08.815Z" retrieveTime="2022-10-17T11:05:47.152504">

I have replied to another comment in google doc. Does that help? If not I can elaborate

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgghZK-E" source="google_doc_comments" createTime="2022-09-22T00:50:59.190Z" retrieveTime="2022-10-17T11:05:47.152504">

If the animation is really the slow part under that special case, then any single-threaded solution will not work IMHO. (Seems flutter does not want multithread and I agree with that, so we only consider single thread solutions)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022321189730910208" source="discord" createTime="2022-09-22T01:39:25.441+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Update: The google doc https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?usp=sharing is updated, most changes are in "touch event handling system" and "comparison"

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022336752695918713" source="discord" createTime="2022-09-22T02:41:15.941+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@dnfield  Yes, if I understand correctly, this case should not need to be considered separately. Since this solution does not affect the existing flow, it just calls preemptRender to submit a frame of drawing to engine at the end of the 16ms. Then continue back to the existing Layout flow

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022337039540174888" source="discord" createTime="2022-09-22T02:42:24.33+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Yes it is like that

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022338135360802816" source="discord" createTime="2022-09-22T02:46:45.594+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@fzyzcjy  Yeah, I thought about it later, and I think one of the challenges is. In the case of video, when we go from 15FPS to 30fps, we actually know the content of each frame, so we can calculate the difference between two frames and interpolate them (IIRC some frames are diff messages). But with Flutter, we don't know what it looks like until we paint it on the next frame.

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022338260871168130" source="discord" createTime="2022-09-22T02:47:15.518+00:00" retrieveTime="2022-10-17T11:35:25.618280">

For example, in this case, when I navigate from loading to a specific page

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022338351434563605" source="discord" createTime="2022-09-22T02:47:37.11+00:00" retrieveTime="2022-10-17T11:35:25.618280">


![image](https://cdn.discordapp.com/attachments/1021987751710699632/1022338351099027567/unknown.png)

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022338478995935334" source="discord" createTime="2022-09-22T02:48:07.523+00:00" retrieveTime="2022-10-17T11:35:25.618280">

video source https://github.com/flutter/flutter/issues/110063#issuecomment-1223774091

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAggxsF2g" source="google_doc_comments" createTime="2022-09-22T02:50:13.980Z" retrieveTime="2022-10-17T11:05:47.152504">



</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAggxsF2k" source="google_doc_comments" createTime="2022-09-22T02:50:15.062Z" retrieveTime="2022-10-17T11:05:47.152504">



</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022339665178669076" source="discord" createTime="2022-09-22T02:52:50.331+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@Nayuta I have not checked Nvidia's tech in details yet. But I guess, because of latency reasons, it will only "guess" extra frames from previous frame? (Will check this soon)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022339976869970010" source="discord" createTime="2022-09-22T02:54:04.644+00:00" retrieveTime="2022-10-17T11:35:25.618280">

For the navigation, say the new page takes 3 frame to render and the page shift animation is 10 frame. Then, users will see 60fps smooth page shift, and during frame 0-3 they see new page is purely empty and in frame 4-10 they see new page with content

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022344022771105852" source="discord" createTime="2022-09-22T03:10:09.262+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I think that a solution that requires developers to implement their own render objects to achieve this may be interesting for a package but probably won't end up in the core framework

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022344204283826186" source="discord" createTime="2022-09-22T03:10:52.538+00:00" retrieveTime="2022-10-17T11:35:25.618280">

If we require developers to think more about whether their widget/RO needs this, and how to create a custom one that will do the right thing, it's going to be very difficult for them to use. It might be very useful and a skilled developer might find very clever ways to do it, but it won't be something that will scale very well.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022345695509876796" source="discord" createTime="2022-09-22T03:16:48.074+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> requires developers to implement their own render objects to achieve 
Well I guess yes and no. 
1. For anything that fit into a subtree, no need for dev to do anything except for inserting PreemptDisplayList widget to the tree
2. For list view scrolling, we do need to change listview's source code a bit, but flutter devs will not even know that change

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022345949797949450" source="discord" createTime="2022-09-22T03:17:48.701+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Let me think about whether I can do something like "just drop in a widget and it works" for end users 🤔

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022347027532763136" source="discord" createTime="2022-09-22T03:22:05.653+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Do you think the 1. and 2. above are enough to cover most common use cases?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022347123229986929" source="discord" createTime="2022-09-22T03:22:28.469+00:00" retrieveTime="2022-10-17T11:35:25.618280">

If so then maybe we are ok - we speed up common cases, and for rare edge cases they need to craft something

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022348023604465694" source="discord" createTime="2022-09-22T03:26:03.135+00:00" retrieveTime="2022-10-17T11:35:25.618280">

It's really hard to tell whether something fits into a subtree, particularly in a large project with many people working on it and in situations where large subtrees are getting built (route transitions)

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022348134547980298" source="discord" createTime="2022-09-22T03:26:29.586+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Scrolling isn't usually the big offender here - we have mechanisms to lazily build the contents of what's getting scrolled, and changing the offset on the layer of what's already built is cheap

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022348342090539044" source="discord" createTime="2022-09-22T03:27:19.068+00:00" retrieveTime="2022-10-17T11:35:25.618280">

The problem is more like "I need to build an entire new tree of widgets in 8ms or less and I have 300+ widgets to build to get there and on my low end phone it's taking a long time"

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022348923249119304" source="discord" createTime="2022-09-22T03:29:37.627+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@dnfield 
> It's really hard to tell whether something fits into a subtree, particularly in a large project with many people working on it and in situations where large subtrees are getting built (route transitions)
Route transitions will always not fit into a leaf subtree indeed, but it is in my example 3.
> Scrolling isn't usually the big offender here - we have mechanisms to lazily build the contents of what's getting scrolled, and changing the offset on the layer of what's already built is cheap
@Nayuta 's Keframe deals with scrolling and is popular, and I also see problems in scrolling (both in my realworld app and my experiments), so I guess it may be a problem sometimes
> The problem is more like "I need to build an entire new tree of widgets in 8ms or less and I have 300+ widgets to build to get there and on my low end phone it's taking a long time"
i.e. page transition? (the example 3)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022349287629271111" source="discord" createTime="2022-09-22T03:31:04.502+00:00" retrieveTime="2022-10-17T11:35:25.618280">

So maybe what I should do is answering: "Devs want to write fancy route transition animations, by themselves and without need to think hard, and at the same time, the new page is heavy and cannot be rendered in one frame"

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022349323582832681" source="discord" createTime="2022-09-22T03:31:13.074+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I will come back when having a solution 🙂

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022349554542190643" source="discord" createTime="2022-09-22T03:32:08.139+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I think it's a little more like "devs want to inflate a large widget tree and be confident that if it doesn't fit into frame budget it will get broken up into pieces that make sense"

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022349664705597482" source="discord" createTime="2022-09-22T03:32:34.404+00:00" retrieveTime="2022-10-17T11:35:25.618280">

(And they can't spend hours altering the logic controlling that every time they refactor or add widgets)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022349833580855409" source="discord" createTime="2022-09-22T03:33:14.667+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> "devs want to inflate a large widget tree and be confident that if it doesn't fit into frame budget it will get broken up into pieces that make sense"
I see. That is exactly what the proposal aims to solve.
> (And they can't spend hours altering the logic controlling that every time they refactor or add widgets)
Totally agree 🙂 I should make the dev-facing API easier

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022350466761379881" source="discord" createTime="2022-09-22T03:35:45.629+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@dnfield Well, maybe I forget to explain: Dev *never* need to do anything special for most of their app. The *only* extra thing is the part for 60fps smooth animation. Only if they want something to be very smooth, and it is not a leaf subtree (e.g. loading indicator) and not a scrolling listview and not a already-provided-in-framework page transition, they will have to write some extra code (in the current proposal).

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022351031981572127" source="discord" createTime="2022-09-22T03:38:00.388+00:00" retrieveTime="2022-10-17T11:35:25.618280">

It might help to have some example application showing the improvements

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022351070007132160" source="discord" createTime="2022-09-22T03:38:09.454+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Would you mind giving a realworld example where userrs, using my currently proposed api, have to write a lot of extra code? such that I will have an example in mind to optimize

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022351088550158366" source="discord" createTime="2022-09-22T03:38:13.875+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Sure, I should do that. Probably create an app w/ page transition etc

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022384252085604372" source="discord" createTime="2022-09-22T05:50:00.678+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Quick update: I am now experimenting multiple subtrees (i.e. a forest). Flutter seems to allow so (e.g. examples/api/lib/widgets/framework/build_owner.0.dart example). If this works, we may have a natural API, i.e. only insert a few extra Widgets to dev's widget tree and that's all, and @dnfield's worry will be solved.

</DiscussionComment>

<DiscussionComment author="xanahopper" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022393700594229259" source="discord" createTime="2022-09-22T06:27:33.378+00:00" retrieveTime="2022-10-17T11:35:25.618280">

for some reason I think maybe build in one frame, layout and paint in next frame is acceptable

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022395490924515369" source="discord" createTime="2022-09-22T06:34:40.226+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Agree, if that is implementable looks like also an idea, as long as the build fits in 16ms

</DiscussionComment>

<DiscussionComment author="Nayuta403" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAghP1jDo" source="google_doc_comments" createTime="2022-09-22T13:01:35.648Z" retrieveTime="2022-10-17T11:05:47.152504">

I would like to add:  this solution has less overhead than keframe. When Keframe replaces placeholder with real widget, it is driven by vsync signal to execute drawFrame process and submit to engine, so it will execute the complete build/layout/paint etc process. But build/layout/paint other than the actual widget is not necessary. In the Preempt Layout scheme, the UI thread just voluntarily submits a frame to the Engine after 16ms of detection, and then returns to the normal rendering flow without much additional overhead.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAghP1jEQ" source="google_doc_comments" createTime="2022-09-22T13:18:08.710Z" retrieveTime="2022-10-17T11:05:47.152504">

Thanks, I added it

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022518983817166868" source="discord" createTime="2022-09-22T14:45:23.226+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Update: minimalist API (one widget for everything) + a prototype about framework layer.

Now, developers will only need to insert `PreemptBuilder(builder: (context, child) => whatever_you_like, child: also_free_to_choose)` widget, and that's all. Arbitrary builder, arbitrary child subtree, and smooth 60fps will be there for the builder. The google doc is updated to discuss this - mainly in (1) "usage examples" (2) "From preemptModifyLayerTree to PreemptBuilder" in "detailed design".

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022518994579755108" source="discord" createTime="2022-09-22T14:45:25.792+00:00" retrieveTime="2022-10-17T11:35:25.618280">

Update: minimalist API (one widget for everything) + a prototype about framework layer.

Now, developers will only need to insert `PreemptBuilder(builder: (context, child) => whatever_you_like, child: also_free_to_choose)` widget, and that's all. Arbitrary builder, arbitrary child subtree, and smooth 60fps will be there for the builder. The google doc is updated to discuss this - mainly in (1) "usage examples" (2) "From preemptModifyLayerTree to PreemptBuilder" in "detailed design".

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022519050875707513" source="discord" createTime="2022-09-22T14:45:39.214+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@dnfield I guess your worry is now solved? 😄

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-22T14:46:52Z" retrieveTime="2022-10-17T11:45:49.046468">

Update: minimalist API (one widget for everything) + a prototype about framework layer.

Now, developers will only need to insert `PreemptBuilder(builder: (context, child) => whatever_you_like, child: also_free_to_choose)` widget, and that's all. Arbitrary builder, arbitrary child subtree, and smooth 60fps will be there for the builder. The google doc is updated to discuss this - mainly in (1) "usage examples" (2) "From preemptModifyLayerTree to PreemptBuilder" in "detailed design".

Code prototype:

<details>

```dart
// ignore_for_file: avoid_print, prefer_const_constructors, invalid_use_of_protected_member

import 'dart:ui';

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

final secondTreePack = SecondTreePack();

// since prototype, only one [RenderAdapterInSecondTree], so do like this
final mainSubTreeLayerHandle = LayerHandle(OffsetLayer());

void main() {
  debugPrintBeginFrameBanner = debugPrintEndFrameBanner = true;
  secondTreePack; // touch it
  mainSubTreeLayerHandle; // touch it
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  var buildCount = 0;

  @override
  Widget build(BuildContext context) {
    buildCount++;
    print('$runtimeType.build ($buildCount)');

    if (buildCount < 5) {
      Future.delayed(Duration(seconds: 1), () {
        print('$runtimeType.setState after a second');
        setState(() {});
      });
    }

    return MaterialApp(
      home: Scaffold(
        body: _buildBody(),
      ),
    );
  }

  Widget _buildBody() {
    return Column(
      children: [
        Text('A$buildCount', style: TextStyle(fontSize: 30)),
        Container(
          decoration: BoxDecoration(
            border: Border.all(
              color: Colors.orange[(buildCount % 8 + 1) * 100]!,
              width: 10,
            ),
          ),
          width: 300,
          height: 300,
          // hack: [AdapterInMainTreeWidget] does not respect "offset" in paint
          // now, so we add a RepaintBoundary to let offset==0
          // hack: [AdapterInMainTreeWidget] does not respect "offset" in paint
          // now, so we add a RepaintBoundary to let offset==0
          child: RepaintBoundary(
            child: AdapterInMainTreeWidget(
              parentBuildCount: buildCount,
              // child: DrawCircleWidget(parentBuildCount: buildCount),
              child: Center(
                child: Container(
                  width: 100,
                  height: 100,
                  color: Colors.pink[(buildCount % 8 + 1) * 100],
                ),
              ),
            ),
          ),
        ),
        Text('B$buildCount', style: TextStyle(fontSize: 30)),
        WindowRenderWhenLayoutWidget(parentBuildCount: buildCount),
        Text('C$buildCount', style: TextStyle(fontSize: 30)),
      ],
    );
  }
}

class WindowRenderWhenLayoutWidget extends SingleChildRenderObjectWidget {
  final int parentBuildCount;

  const WindowRenderWhenLayoutWidget({
    super.key,
    required this.parentBuildCount,
    super.child,
  });

  @override
  WindowRenderWhenLayoutRender createRenderObject(BuildContext context) =>
      WindowRenderWhenLayoutRender(
        parentBuildCount: parentBuildCount,
      );

  @override
  void updateRenderObject(
      BuildContext context, WindowRenderWhenLayoutRender renderObject) {
    renderObject.parentBuildCount = parentBuildCount;
  }
}

class WindowRenderWhenLayoutRender extends RenderProxyBox {
  WindowRenderWhenLayoutRender({
    required int parentBuildCount,
    RenderBox? child,
  })  : _parentBuildCount = parentBuildCount,
        super(child);

  int get parentBuildCount => _parentBuildCount;
  int _parentBuildCount;

  set parentBuildCount(int value) {
    if (_parentBuildCount == value) return;
    _parentBuildCount = value;
    print('$runtimeType markNeedsLayout because parentBuildCount changes');
    markNeedsLayout();
  }

  @override
  void performLayout() {
    // unconditionally call this, as an experiment
    pseudoPreemptRender();

    super.performLayout();
  }

  void pseudoPreemptRender() {
    print('$runtimeType pseudoPreemptRender start');

    // ref: https://github.com/fzyzcjy/yplusplus/issues/5780#issuecomment-1254562485
    // ref: RenderView.compositeFrame

    final builder = SceneBuilder();

    // final recorder = PictureRecorder();
    // final canvas = Canvas(recorder);
    // final rect = Rect.fromLTWH(0, 0, 500, 500);
    // canvas.drawRect(Rect.fromLTWH(100, 100, 50, 50.0 * parentBuildCount),
    //     Paint()..color = Colors.green);
    // final pictureLayer = PictureLayer(rect);
    // pictureLayer.picture = recorder.endRecording();
    // final rootLayer = OffsetLayer();
    // rootLayer.append(pictureLayer);
    // final scene = rootLayer.buildScene(builder);

    final binding = WidgetsFlutterBinding.ensureInitialized();

    preemptModifyLayerTree(binding);

    // why this layer? from RenderView.compositeFrame
    final scene = binding.renderView.layer!.buildScene(builder);

    print('call window.render');
    window.render(scene);

    scene.dispose();

    print('$runtimeType pseudoPreemptRender end');
  }

  void preemptModifyLayerTree(WidgetsBinding binding) {
    // hack, just want to prove we can change something (preemptModifyLayerTree)
    // inside the preemptRender
    final rootLayer = binding.renderView.layer! as TransformLayer;
    rootLayer.transform =
        rootLayer.transform!.multiplied(Matrix4.translationValues(0, 50, 0));
    print('preemptModifyLayerTree rootLayer=$rootLayer (after)');

    refreshSecondTree();
  }

  void refreshSecondTree() {
    print('$runtimeType refreshSecondTree start');
    secondTreePack.innerStatefulBuilderSetState(() {});

    // NOTE reference: WidgetsBinding.drawFrame & RendererBinding.drawFrame
    // https://github.com/fzyzcjy/yplusplus/issues/5778#issuecomment-1254490708
    secondTreePack.buildOwner.buildScope(secondTreePack.element);
    secondTreePack.pipelineOwner.flushLayout();
    secondTreePack.pipelineOwner.flushCompositingBits();
    secondTreePack.pipelineOwner.flushPaint();
    // renderView.compositeFrame(); // this sends the bits to the GPU
    // pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.
    secondTreePack.buildOwner.finalizeTree();

    print('$runtimeType refreshSecondTree end');
  }
}

class AdapterInMainTreeWidget extends SingleChildRenderObjectWidget {
  final int parentBuildCount;

  const AdapterInMainTreeWidget({
    super.key,
    required this.parentBuildCount,
    super.child,
  });

  @override
  RenderAdapterInMainTree createRenderObject(BuildContext context) =>
      RenderAdapterInMainTree(parentBuildCount: parentBuildCount);

  @override
  void updateRenderObject(
      BuildContext context, RenderAdapterInMainTree renderObject) {
    renderObject.parentBuildCount = parentBuildCount;
  }
}

class RenderAdapterInMainTree extends RenderBox
    with RenderObjectWithChildMixin<RenderBox> {
  RenderAdapterInMainTree({
    required int parentBuildCount,
    // RenderBox? child,
  }) : _parentBuildCount = parentBuildCount;

  // super(child);

  int get parentBuildCount => _parentBuildCount;
  int _parentBuildCount;

  set parentBuildCount(int value) {
    if (_parentBuildCount == value) return;
    _parentBuildCount = value;
    print('$runtimeType markNeedsLayout because parentBuildCount changes');
    markNeedsLayout();
  }

  // should not be singleton, but we are prototyping so only one such guy
  static RenderAdapterInMainTree? instance;

  @override
  void attach(covariant PipelineOwner owner) {
    super.attach(owner);
    assert(instance == null);
    instance = this;
  }

  @override
  void detach() {
    assert(instance == this);
    instance == null;
    super.detach();
  }

  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    print('$runtimeType.layout called');
    super.layout(constraints, parentUsesSize: parentUsesSize);
  }

  @override
  void performLayout() {
    print('$runtimeType.performLayout start');

    // NOTE
    secondTreePack.rootView.configuration =
        SecondTreeRootViewConfiguration(size: constraints.biggest);

    print('$runtimeType.performLayout child.layout start');
    child!.layout(constraints);
    print('$runtimeType.performLayout child.layout end');

    size = constraints.biggest;
  }

  // TODO correct?
  @override
  bool get alwaysNeedsCompositing => true;

  // static final staticPseudoRootLayerHandle = () {
  //   final recorder = PictureRecorder();
  //   final canvas = Canvas(recorder);
  //   final rect = Rect.fromLTWH(0, 0, 200, 200);
  //   canvas.drawRect(
  //       Rect.fromLTWH(0, 0, 50, 100), Paint()..color = Colors.green);
  //   final pictureLayer = PictureLayer(rect);
  //   pictureLayer.picture = recorder.endRecording();
  //   final wrapperLayer = OffsetLayer();
  //   wrapperLayer.append(pictureLayer);
  //
  //   final pseudoRootLayer = TransformLayer(transform: Matrix4.identity());
  //   pseudoRootLayer.append(wrapperLayer);
  //
  //   pseudoRootLayer.attach(secondTreePack.rootView);
  //
  //   return LayerHandle(pseudoRootLayer);
  // }();

  @override
  void paint(PaintingContext context, Offset offset) {
    assert(offset == Offset.zero,
        '$runtimeType prototype has not deal with offset yet');

    print('$runtimeType.paint called');

    // super.paint(context, offset);
    // return;

    // context.canvas.drawRect(Rect.fromLTWH(0, 0, 50, 50.0 * parentBuildCount),
    //     Paint()..color = Colors.green);
    // return;

    // context.pushLayer(
    //   OpacityLayer(alpha: 100),
    //   (context, offset) {
    //     context.canvas.drawRect(
    //         Rect.fromLTWH(0, 0, 50, 50.0 * parentBuildCount),
    //         Paint()..color = Colors.green);
    //   },
    //   offset,
    // );
    // return;

    // context.addLayer(PerformanceOverlayLayer(
    //   overlayRect: Rect.fromLTWH(offset.dx, offset.dy, size.width, size.height),
    //   optionsMask: 1 <<
    //           PerformanceOverlayOption.displayRasterizerStatistics.index |
    //       1 << PerformanceOverlayOption.visualizeRasterizerStatistics.index |
    //       1 << PerformanceOverlayOption.displayEngineStatistics.index |
    //       1 << PerformanceOverlayOption.visualizeEngineStatistics.index,
    //   rasterizerThreshold: 0,
    //   checkerboardRasterCacheImages: true,
    //   checkerboardOffscreenLayers: true,
    // ));
    // return;

    // {
    //   final recorder = PictureRecorder();
    //   final canvas = Canvas(recorder);
    //   final rect = Rect.fromLTWH(0, 0, 200, 200);
    //   canvas.drawRect(Rect.fromLTWH(0, 0, 50, 50.0 * parentBuildCount),
    //       Paint()..color = Colors.green);
    //   final pictureLayer = PictureLayer(rect);
    //   pictureLayer.picture = recorder.endRecording();
    //   final wrapperLayer = OffsetLayer();
    //   wrapperLayer.append(pictureLayer);
    //
    //   // NOTE addLayer vs pushLayer
    //   context.addLayer(wrapperLayer);
    //
    //   print('pictureLayer.attached=${pictureLayer.attached} '
    //       'wrapperLayer.attached=${wrapperLayer.attached}');
    //
    //   return;
    // }

    // {
    //   if (staticPseudoRootLayerHandle.layer!.attached) {
    //     print('pseudoRootLayer.detach');
    //     staticPseudoRootLayerHandle.layer!.detach();
    //   }
    //
    //   print('before addLayer staticPseudoRootLayer=${staticPseudoRootLayerHandle.layer!.toStringDeep()}');
    //
    //   context.addLayer(staticPseudoRootLayerHandle.layer!);
    //
    //   print('after addLayer staticPseudoRootLayer=${staticPseudoRootLayerHandle.layer!.toStringDeep()}');
    //
    //   return;
    // }

    // ref: RenderOpacity

    // TODO this makes "second tree root layer" be *removed* from its original
    //      parent. shall we move it back later? o/w can be slow!
    final secondTreeRootLayer = secondTreePack.rootView.layer!;

    // print(
    //     'just start secondTreeRootLayer=${secondTreeRootLayer.toStringDeep()}');

    // HACK!!!
    if (secondTreeRootLayer.attached) {
      print('$runtimeType.paint detach the secondTreeRootLayer');
      // TODO attach again later?
      secondTreeRootLayer.detach();
    }

    // print(
    //     'before addLayer secondTreeRootLayer=${secondTreeRootLayer.toStringDeep()}');

    print('$runtimeType.paint addLayer');
    // NOTE addLayer, not pushLayer!!!
    context.addLayer(secondTreeRootLayer);
    // context.pushLayer(secondTreeRootLayer, (context, offset) {}, offset);

    print('secondTreeRootLayer.attached=${secondTreeRootLayer.attached}');
    print(
        'after addLayer secondTreeRootLayer=${secondTreeRootLayer.toStringDeep()}');

    // ================== paint those child in main tree ===================

    // NOTE do *not* have any relation w/ self's PaintingContext, as we will not paint there
    {
      // ref: [PaintingContext.pushLayer]
      if (mainSubTreeLayerHandle.layer!.hasChildren) {
        mainSubTreeLayerHandle.layer!.removeAllChildren();
      }
      final childContext = PaintingContext(
          mainSubTreeLayerHandle.layer!, context.estimatedBounds);
      child!.paint(childContext, Offset.zero);
      childContext.stopRecordingIfNeeded();
    }

    // =====================================================================
  }

// TODO handle layout!
}

class AdapterInSecondTreeWidget extends SingleChildRenderObjectWidget {
  final int parentBuildCount;

  const AdapterInSecondTreeWidget({
    super.key,
    required this.parentBuildCount,
    super.child,
  });

  @override
  RenderAdapterInSecondTree createRenderObject(BuildContext context) =>
      RenderAdapterInSecondTree(parentBuildCount: parentBuildCount);

  @override
  void updateRenderObject(
      BuildContext context, RenderAdapterInSecondTree renderObject) {
    renderObject.parentBuildCount = parentBuildCount;
  }
}

class RenderAdapterInSecondTree extends RenderBox {
  RenderAdapterInSecondTree({
    required int parentBuildCount,
  }) : _parentBuildCount = parentBuildCount;

  int get parentBuildCount => _parentBuildCount;
  int _parentBuildCount;

  set parentBuildCount(int value) {
    if (_parentBuildCount == value) return;
    _parentBuildCount = value;
    print('$runtimeType markNeedsLayout because parentBuildCount changes');
    markNeedsLayout();
  }

  // should not be singleton, but we are prototyping so only one such guy
  static RenderAdapterInSecondTree? instance;

  @override
  void attach(covariant PipelineOwner owner) {
    super.attach(owner);
    assert(instance == null);
    instance = this;
  }

  @override
  void detach() {
    assert(instance == this);
    instance == null;
    super.detach();
  }

  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    print('$runtimeType.layout called');
    super.layout(constraints, parentUsesSize: parentUsesSize);
  }

  @override
  void performLayout() {
    print('$runtimeType.performLayout called');
    size = constraints.biggest;
  }

  // TODO correct?
  @override
  bool get alwaysNeedsCompositing => true;

  @override
  void paint(PaintingContext context, Offset offset) {
    print('$runtimeType paint');
    context.addLayer(mainSubTreeLayerHandle.layer!);
  }
}

class SecondTreePack {
  late final PipelineOwner pipelineOwner;
  late final SecondTreeRootView rootView;
  late final BuildOwner buildOwner;
  late final RenderObjectToWidgetElement<RenderBox> element;

  var innerStatefulBuilderBuildCount = 0;
  late StateSetter innerStatefulBuilderSetState;

  SecondTreePack() {
    pipelineOwner = PipelineOwner();
    rootView = pipelineOwner.rootNode = SecondTreeRootView(
      configuration: SecondTreeRootViewConfiguration(size: Size.zero),
    );
    buildOwner = BuildOwner(
      focusManager: FocusManager(),
      onBuildScheduled: () =>
          print('second tree BuildOwner.onBuildScheduled called'),
    );

    rootView.prepareInitialFrame();

    final secondTreeWidget = StatefulBuilder(builder: (_, setState) {
      print(
          'secondTreeWidget(StatefulBuilder).builder called ($innerStatefulBuilderBuildCount)');

      innerStatefulBuilderSetState = setState;
      innerStatefulBuilderBuildCount++;

      return Container(
        width: 50 * innerStatefulBuilderBuildCount.toDouble(),
        height: 100,
        color: Colors.blue[(innerStatefulBuilderBuildCount * 100) % 800 + 100],
        child: AdapterInSecondTreeWidget(
          parentBuildCount: innerStatefulBuilderBuildCount,
        ),
      );
    });

    element = RenderObjectToWidgetAdapter<RenderBox>(
      container: rootView,
      debugShortDescription: '[root]',
      child: secondTreeWidget,
    ).attachToRenderTree(buildOwner);
  }
}

// ref: [ViewConfiguration]
class SecondTreeRootViewConfiguration {
  const SecondTreeRootViewConfiguration({
    required this.size,
  });

  final Size size;

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ViewConfiguration && other.size == size;
  }

  @override
  int get hashCode => size.hashCode;

  @override
  String toString() => '$size';
}

class SecondTreeRootView extends RenderObject
    with RenderObjectWithChildMixin<RenderBox> {
  SecondTreeRootView({
    RenderBox? child,
    required SecondTreeRootViewConfiguration configuration,
  }) : _configuration = configuration {
    this.child = child;
  }

  // NOTE ref [RenderView.size]
  /// The current layout size of the view.
  Size get size => _size;
  Size _size = Size.zero;

  // NOTE ref [RenderView.configuration] which has size and some other things
  /// The constraints used for the root layout.
  SecondTreeRootViewConfiguration get configuration => _configuration;
  SecondTreeRootViewConfiguration _configuration;

  set configuration(SecondTreeRootViewConfiguration value) {
    if (configuration == value) {
      return;
    }
    print(
        '$runtimeType set configuration(i.e. size) $_configuration -> $value');
    _configuration = value;
    markNeedsLayout();
  }

  @override
  void performLayout() {
    print(
        '$runtimeType performLayout configuration.size=${configuration.size}');

    _size = configuration.size;

    assert(child != null);
    child!.layout(BoxConstraints.tight(_size));
  }

  // ref RenderView
  @override
  void paint(PaintingContext context, Offset offset) {
    // NOTE we have to temporarily remove debugActiveLayout
    // b/c [SecondTreeRootView.paint] is called inside [preemptRender]
    // which is inside main tree's build/layout.
    // thus, if not set it to null we will see error
    // https://github.com/fzyzcjy/yplusplus/issues/5783#issuecomment-1254974511
    // In short, this is b/c [debugActiveLayout] is global variable instead
    // of per-tree variable
    final oldDebugActiveLayout = RenderObject.debugActiveLayout;
    RenderObject.debugActiveLayout = null;
    try {
      print('$runtimeType paint child start');
      context.paintChild(child!, offset);
      print('$runtimeType paint child end');
    } finally {
      RenderObject.debugActiveLayout = oldDebugActiveLayout;
    }
  }

  @override
  void debugAssertDoesMeetConstraints() => true;

  void prepareInitialFrame() {
    // ref: RenderView
    scheduleInitialLayout();
    scheduleInitialPaint(_updateMatricesAndCreateNewRootLayer());
  }

  // ref: RenderView
  TransformLayer _updateMatricesAndCreateNewRootLayer() {
    final rootLayer = TransformLayer(transform: Matrix4.identity());
    rootLayer.attach(this);
    return rootLayer;
  }

  // ref: RenderView
  @override
  bool get isRepaintBoundary => true;

  // ref: RenderView
  @override
  Rect get paintBounds => Offset.zero & size;

  // ref: RenderView
  @override
  void performResize() {
    assert(false);
  }

  // hack: just give non-sense value, this is prototype
  @override
  Rect get semanticBounds => paintBounds;
}

class DrawCircleWidget extends LeafRenderObjectWidget {
  final int parentBuildCount;

  const DrawCircleWidget({
    super.key,
    required this.parentBuildCount,
  });

  @override
  RenderDrawCircle createRenderObject(BuildContext context) => RenderDrawCircle(
        parentBuildCount: parentBuildCount,
      );

  @override
  void updateRenderObject(BuildContext context, RenderDrawCircle renderObject) {
    renderObject.parentBuildCount = parentBuildCount;
  }
}

class RenderDrawCircle extends RenderProxyBox {
  RenderDrawCircle({
    required int parentBuildCount,
    RenderBox? child,
  })  : _parentBuildCount = parentBuildCount,
        super(child);

  int get parentBuildCount => _parentBuildCount;
  int _parentBuildCount;

  set parentBuildCount(int value) {
    if (_parentBuildCount == value) return;
    _parentBuildCount = value;
    print('$runtimeType markNeedsLayout because parentBuildCount changes');
    markNeedsLayout();
  }

  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    print('$runtimeType performLayout');
    super.layout(constraints, parentUsesSize: parentUsesSize);
  }

  @override
  void performLayout() {
    size = constraints.biggest;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    print('$runtimeType paint');
    context.canvas
        .drawCircle(Offset(50, 50), 100, Paint()..color = Colors.cyan);
  }
}
```

</details>

---

Next time I may only update progress in Discord, since there are already >hundred comments there - seems everyone is there instead of in github :)

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022520470278520882" source="discord" createTime="2022-09-22T14:51:17.626+00:00" retrieveTime="2022-10-17T11:35:25.618280">

It'd help to see usage

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022520689351213126" source="discord" createTime="2022-09-22T14:52:09.857+00:00" retrieveTime="2022-10-17T11:35:25.618280">

In the example section of the google doc, updated

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022520976669409390" source="discord" createTime="2022-09-22T14:53:18.359+00:00" retrieveTime="2022-10-17T11:35:25.618280">

```
YourParentWidgets(
  child: PreemptBuilder(
    builder: (_, child) => YourFancyAnimationWhichNeeds60FPS(child: child)),
    child: YourNewPageAndSoOn(),
  )
)
```

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022521002900586577" source="discord" createTime="2022-09-22T14:53:24.613+00:00" retrieveTime="2022-10-17T11:35:25.618280">

For page transition

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022521020885782538" source="discord" createTime="2022-09-22T14:53:28.901+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@dnfield

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022521131653148672" source="discord" createTime="2022-09-22T14:53:55.31+00:00" retrieveTime="2022-10-17T11:35:25.618280">

All those YourSomthing are plain old widget trees, no special

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022521872950243338" source="discord" createTime="2022-09-22T14:56:52.049+00:00" retrieveTime="2022-10-17T11:35:25.618280">

@dnfield Curious is it OK to you? Btw I am going to sleep in a minute and will reply 8hr later for later comments

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022525438846828626" source="discord" createTime="2022-09-22T15:11:02.225+00:00" retrieveTime="2022-10-17T11:35:25.618280">

A demo would help

</DiscussionComment>

<DiscussionComment author="Callum" link="https://discord.com/channels/608014603317936148/608021234516754444/1022533843724537968" source="discord" createTime="2022-09-22T15:44:26.104+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I would rather think of an API like this would be useful
```
SlowSubtree(
    placeholder: Center(child: CupertinoActivityIndicator())
    child: MyBigScrollingPage()
)
```
And that child could be built over multiple frames. Main use case would be to not frame-drop during page push animation when the new page is complex. Seems like based on `build_owner.0.dart` example it can be possible to build arbitrary subtrees? But would need to modify the build owner in order to yield back and show the placeholder.

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022546349926924368" source="discord" createTime="2022-09-22T16:34:07.815+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If someone has stackoverflow comment abilities can you please comment on this answer: https://stackoverflow.com/a/64167746/20063373  It assumes that the `builder` for `StreamBuilder` will get called 1-to-1 for the `Stream` events.  So the code will fail depending on the timing of the Stream.  It's kind of a nasty gotcha.

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022550647956062208" source="discord" createTime="2022-09-22T16:51:12.545+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Filed an issue to propose the ability to make `StreamBuilder` lossless since the fail case is too dire imo

</DiscussionComment>

<DiscussionComment author="BetoMan0" link="https://discord.com/channels/608014603317936148/608021234516754444/1022560256900993135" source="discord" createTime="2022-09-22T17:29:23.496+00:00" retrieveTime="2022-10-17T11:35:13.053450">

could you link it please?

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgAJWz4g" source="google_doc_comments" createTime="2022-09-22T18:10:23.481Z" retrieveTime="2022-10-17T11:05:47.152504">

I think if we can find a way to do multithreading nobody is against it a priori.

If I may, it sounds like your proposal boils down to "provide developers with a way to mark areas of the tree that should be updated first (doing build, layout, paint, and semantics), then, if the time runs out during a frame, send the updated layer tree that only contains those parts and not the others, then continue doing the frame". Is that right?

If so, I think the main problem with this approach is that we'd have to rerun the rarely-mentioned (because it's so cheap) "animation" step that happens before build, so that the parts of the tree that need animating early can be updated with the new time stamp, but in the current model, that requires winding down the stack frame because between the "animation" and "build" phases we run microtasks.

I also worry that it would lead to some strange effects like how to determine which parts of the tree to update and which to not. For example, suppose you have three parts to your page. Part A is marked as needing fast updates, and parts B and C other two are expensive animations.

We start frame 1, we update all the AnimationControllers, we build/layout/paint/layer/semantics the first (A), then we start on B, and we do no build and layout of B. Then we interrupt the work to send the tree to the engine with A's update. We do a new animation phase to update all the AnimationControllers again, we build/layout/paint/layer/semantics the first (A), then we resume the work on the original frame. Now we build/layout C. Finally build and layout are done so we paint B and C and do the layer tree and render it. Unfortunately, because B and C were painted after different animation phases, they'll be out of sync. It'll look like the two animations are running at a low frame rate _and out of sync with each other_, which IMHO is worse than today (where they're just at a low frame rate).

That's assuming we can figure out how to do the animation phase at all.

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022585702728355851" source="discord" createTime="2022-09-22T19:10:30.254+00:00" retrieveTime="2022-10-17T11:35:13.053450">

oops, sorry https://github.com/flutter/flutter/issues/112197

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022641922352881774" source="discord" createTime="2022-09-22T22:53:54.057+00:00" retrieveTime="2022-10-17T11:35:25.618280">

It is still a prototype :/

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022642041236246588" source="discord" createTime="2022-09-22T22:54:22.401+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I will have a more complete prototype today. Just want to confirm whether the user-facing API looks good to you or not (b/c it is an API, not an implementation detail)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022642455327289405" source="discord" createTime="2022-09-22T22:56:01.128+00:00" retrieveTime="2022-10-17T11:35:25.618280">

If the API is still bad I need to think another

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022642563573882981" source="discord" createTime="2022-09-22T22:56:26.936+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Callum That would be great, and looks like what the modify-the-build and modify-the-layout will do (see compaison between them and my proposal, in the google doc https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit#)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022642805467787375" source="discord" createTime="2022-09-22T22:57:24.608+00:00" retrieveTime="2022-10-17T11:35:13.053450">

However, the main problem is that, seems not to exist efficient implementable solutions for those ideas (some by googlers, some by bytedancers, some by me). They have either performance problems, or logical problems IIRC. I am also looking forward to see progress on those methods!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022643311422476379" source="discord" createTime="2022-09-22T22:59:25.237+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Done (under @ch271828n account, also me)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgi3nytg" source="google_doc_comments" createTime="2022-09-22T23:07:21.894Z" retrieveTime="2022-10-17T11:05:47.152504">

> boils down to ... Is that right?

Quite similar to my existing proposal, if it is implementable, sure.

> we'd have to rerun the rarely-mentioned (because it's so cheap) "animation" step ... because between the "animation" and "build" phases we run microtasks.

Indeed I am also quite curious why it was design like that, instead of putting animation into build/layout phase.
Anyway, if using the PreemptBuilder dev-facing API, dev just use a builder callback (like what we have done a million times) to drive animation, which is flexible.

> Unfortunately, because B and C were painted after different animation phases, they'll be out of sync.

Sorry I cannot get it. In my proposal, they always see the same vsync signal. Indeed, using the mental model (a section in this design doc), every code should just see the plain old janky environment, except for a small portion of the code (the one inside PreemptBuilder) which knows extra info.

> That's assuming we can figure out how to do the animation phase at all.

Currently I plan *not* to do the animation phase indeed, and just use the builder callback.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgi3nytk" source="google_doc_comments" createTime="2022-09-22T23:26:20.434Z" retrieveTime="2022-10-17T11:05:47.152504">

IIRC, Flutter officially supports us to using builder pattern for animations. For example, AnimatedBuilder is indeed implemented as `setState` per Listenable update, very similar to how we treat PreemptBuilder - build (setState?) per 60fps frame.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022654879577145364" source="discord" createTime="2022-09-22T23:45:23.3+00:00" retrieveTime="2022-10-17T11:35:25.618280">

It's still not quite clear to me how it will work or if it's solving the problem that I'm particularly interested in (building big widget trees on slow devices)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022655590494896139" source="discord" createTime="2022-09-22T23:48:12.796+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> if it's solving the problem that I'm particularly interested in (building big widget trees on slow devices)
At the API level I guess yes?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022655611919417374" source="discord" createTime="2022-09-22T23:48:17.904+00:00" retrieveTime="2022-10-17T11:35:25.618280">

```
YourParentWidgets(
  child: PreemptBuilder(
    builder: (_, child) => YourFancyAnimationWhichNeeds60FPS(child: child)),
    child: ABigWidgetTreeThatYouWant(),
  )
)
```

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022655894992977980" source="discord" createTime="2022-09-22T23:49:25.394+00:00" retrieveTime="2022-10-17T11:35:25.618280">

> how it will work
The code is already working (except that I have not modify engine, so it just omits later window.render to screen...), anyway I will prototype more today

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-23T13:28:16Z" retrieveTime="2022-10-17T11:45:49.046468">

### Prototype: Enter-new-heavy-page, smoothly even though it takes 0.5s to build/layout

Also posted in discord and google doc

#### Defects in the prototype compared to the future full implementation

* The page is so heavy that even paint without the time of build and layout causes a visible jank with PreemptBuilder; in real world should not be that slow (since in real world build/layout does not take 30 frames)
* Extra frame is driven by simple `DateTime.now` (instead of vsync), so it is not at its best performance
* Prototype code has not been fully clean up yet

#### Code

https://github.com/fzyzcjy/flutter/tree/experiment-forest and https://github.com/fzyzcjy/engine/tree/experiment-smooth

#### Downloadable app

[app-profile.apk.zip](https://github.com/flutter/flutter/files/9634000/app-profile.apk.zip)

#### Video

Firstly the slow (plain old) case, then the fast (using PreemptBuilder) case. The grey circle appears when I touch the screen (by android system recorder).

https://user-images.githubusercontent.com/5236035/191970843-a9c82a38-1276-4024-8a1b-c102c9b8e22f.mp4




</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022862104325259294" source="discord" createTime="2022-09-23T13:28:49.53+00:00" retrieveTime="2022-10-17T11:35:13.053450">

**Prototype: Enter-new-heavy-page, smoothly even though it takes 0.5s to build/layout**

Defects in the prototype compared to the future full implementation

* The page is so heavy that even paint without the time of build and layout causes a visible jank with PreemptBuilder; in real world should not be that slow (since in real world build/layout does not take 30 frames)
* Extra frame is driven by simple `DateTime.now` (instead of vsync), so it is not at its best performance
* Prototype code has not been fully clean up yet

Code

github.com/fzyzcjy/flutter/tree/experiment-forest and github.com/fzyzcjy/engine/tree/experiment-smooth (deliberately removed https o/w discord pop up big cards)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022862260735066182" source="discord" createTime="2022-09-23T13:29:26.821+00:00" retrieveTime="2022-10-17T11:35:13.053450">

apk:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022862373742194740" source="discord" createTime="2022-09-23T13:29:53.764+00:00" retrieveTime="2022-10-17T11:35:13.053450">

https://github.com/flutter/flutter/issues/101227#issuecomment-1256212759 has an attachment (the apk)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022862385159090176" source="discord" createTime="2022-09-23T13:29:56.486+00:00" retrieveTime="2022-10-17T11:35:13.053450">

video:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022862437994725436" source="discord" createTime="2022-09-23T13:30:09.083+00:00" retrieveTime="2022-10-17T11:35:13.053450">



</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022862458798485566" source="discord" createTime="2022-09-23T13:30:14.043+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Firstly the slow (plain old) case, then the fast (using PreemptBuilder) case. The grey circle appears when I touch the screen (by android system recorder).

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022862703032795176" source="discord" createTime="2022-09-23T13:31:12.273+00:00" retrieveTime="2022-10-17T11:35:25.618280">

https://discord.com/channels/608014603317936148/608021234516754444/1022862104325259294

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/1021987751710699632/1022862801095630972" source="discord" createTime="2022-09-23T13:31:35.653+00:00" retrieveTime="2022-10-17T11:35:25.618280">

I made the prototype 😄

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022865871166779472" source="discord" createTime="2022-09-23T13:43:47.615+00:00" retrieveTime="2022-10-17T11:35:13.053450">

/cc @Hixie @Jonah Williams @dnfield @gaaclarke @XanaHopper @Nayuta @Jsouliang @SecondFlight who had comments about the design doc (hope I remembered everyone)

</DiscussionComment>

<DiscussionComment author="Piero512" link="https://discord.com/channels/608014603317936148/608021234516754444/1022873820358520954" source="discord" createTime="2022-09-23T14:15:22.85+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I noticed that we're calling it pre-emptive rendering

</DiscussionComment>

<DiscussionComment author="Piero512" link="https://discord.com/channels/608014603317936148/608021234516754444/1022873983156228217" source="discord" createTime="2022-09-23T14:16:01.664+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but since Flutter is a reactive framework

</DiscussionComment>

<DiscussionComment author="Piero512" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874018321272944" source="discord" createTime="2022-09-23T14:16:10.048+00:00" retrieveTime="2022-10-17T11:35:13.053450">

https://reactjs.org/blog/2022/03/29/react-v18.html#gradually-adopting-concurrent-features this is what react is doing

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874287125835837" source="discord" createTime="2022-09-23T14:17:14.136+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Piero512 Not sure which part in the link are you refer to - do you mean Fiber?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874356654809198" source="discord" createTime="2022-09-23T14:17:30.713+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Indeed Fiber is the very beginning: https://github.com/flutter/flutter/issues/101227

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874414481690634" source="discord" createTime="2022-09-23T14:17:44.5+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But my current solution is indeed quite different from fiber (indeed little similarity)

</DiscussionComment>

<DiscussionComment author="HrX" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874663849832530" source="discord" createTime="2022-09-23T14:18:43.954+00:00" retrieveTime="2022-10-17T11:35:13.053450">

it seems to break the specified transition duration, is it expected?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874707902595173" source="discord" createTime="2022-09-23T14:18:54.457+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Break what?

</DiscussionComment>

<DiscussionComment author="HrX" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874727938805881" source="discord" createTime="2022-09-23T14:18:59.234+00:00" retrieveTime="2022-10-17T11:35:13.053450">

like, if a transition was meant to be (say) 400ms then that constraint is not respected anymore

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874762525020322" source="discord" createTime="2022-09-23T14:19:07.48+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Should be 400ms

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874774097113139" source="discord" createTime="2022-09-23T14:19:10.239+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If not, it is a bug

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874830145585172" source="discord" createTime="2022-09-23T14:19:23.602+00:00" retrieveTime="2022-10-17T11:35:13.053450">

This is prototype indeed, so please bear some bugs 🙂

</DiscussionComment>

<DiscussionComment author="HrX" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874850018205779" source="discord" createTime="2022-09-23T14:19:28.34+00:00" retrieveTime="2022-10-17T11:35:13.053450">

hm hm i see

</DiscussionComment>

<DiscussionComment author="HrX" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874903701094401" source="discord" createTime="2022-09-23T14:19:41.139+00:00" retrieveTime="2022-10-17T11:35:13.053450">

was asking out of curiosity indeed, cuz was wondering if it was expected or no

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022874961054019605" source="discord" createTime="2022-09-23T14:19:54.813+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I see 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1022875079421481070" source="discord" createTime="2022-09-23T14:20:23.034+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Your app should be exactly like what you expect, except that you have extra smooth frames, when using this PreemptBuilder

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1022907305471246456" source="discord" createTime="2022-09-23T16:28:26.323+00:00" retrieveTime="2022-10-17T11:35:13.053450">

is that dilating the time of the animation?  What is supposed to be the duration of that transition?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1023007290300833872" source="discord" createTime="2022-09-23T23:05:44.564+00:00" retrieveTime="2022-10-17T11:35:13.053450">

It looks like a bug in my prototype. I use DateTime.now() everywhere (since this is a prototype), so it is weird that it dilates so much. It should be 0.3s.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1023007451282415687" source="discord" createTime="2022-09-23T23:06:22.945+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I will debug it soon

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1023065826078756944" source="discord" createTime="2022-09-24T02:58:20.581+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Btw, I realized that, the video is only <30FPS (even if recording non-flutter apps), so cannot demonstrate the real case... Will change a software.

**Update** (2022.9.24 22:00 @ UTC+8): Given that you guys seem to be on weekend, I will not post details to avoid disturbing. But if you are interested in my today (and tomorrow)'s progress, all my progress can be seen in realtime in the github branches posted above. Have a good weekend! 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1023410732336939129" source="discord" createTime="2022-09-25T01:48:52.641+00:00" retrieveTime="2022-10-17T11:35:13.053450">

**Brief visual update: It runs at ~60fps, while widget build/layout needs ~500ms**

Video description: (1) The slow (plain-old) case is repeated twice (2) Then the fast (using PreemptBuilder) case is done twice (3) Lastly a debug animation is shown (to be explained below).

How to verify it is 60fps: I personally use `ffmpeg -i $VIDEO -vsync 0 -frame_pts true -vf drawtext=fontfile=/usr/share/fonts/truetype/freefont/FreeMonoBold.ttf:fontsize=80:text='%{pts}':fontcolor=white@0.8:x=7:y=7 ~/temp/video_frames/output_%04d.jpg` to extract every frame of the video.

P.S. The last section in the video (debug animation) is used to verify the file transfer. If that part is seen janky, then it is probably a problem when transferring the video file etc, since that should definitely be 60FPS.

As usual, the code is at the GitHub branch mentioned above.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-25T01:50:08Z" retrieveTime="2022-10-17T11:45:49.046468">

### Brief visual update: It runs at ~60fps, while widget build/layout needs ~500ms

X-Posted: https://discord.com/channels/608014603317936148/608021234516754444/1023410732336939129

Video description: (1) The slow (plain-old) case is repeated twice (2) Then the fast (using PreemptBuilder) case is done twice (3) Lastly a debug animation is shown (to be explained below).

How to verify it is 60fps: I personally use `ffmpeg -i $VIDEO -vsync 0 -frame_pts true -vf drawtext=fontfile=/usr/share/fonts/truetype/freefont/FreeMonoBold.ttf:fontsize=80:text='%{pts}':fontcolor=white@0.8:x=7:y=7 ~/temp/video_frames/output_%04d.jpg` to extract every frame of the video.

P.S. The last section in the video (debug animation) is used to verify the file transfer. If that part is seen janky, then it is probably a problem when transferring the video file etc, since that should definitely be 60FPS.

As usual, the code is at the GitHub branch mentioned above.


https://user-images.githubusercontent.com/5236035/192124851-19bae792-ad31-4ae3-8717-8a0821038d00.mp4



</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1023411181567868978" source="discord" createTime="2022-09-25T01:50:39.746+00:00" retrieveTime="2022-10-17T11:35:13.053450">

https://user-images.githubusercontent.com/5236035/192124851-19bae792-ad31-4ae3-8717-8a0821038d00.mp4

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1023834043906793552" source="discord" createTime="2022-09-26T05:50:57.984+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Brief update in recent experiments: Overhead per frame is medium=0.53ms, p95=0.81ms, p99=1.10ms, on my low-end testing device, for the "enter-new-screen" demo. (Indeed it may not be called "overhead", since those time are really needed to update data for screen)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-26T10:27:09Z" retrieveTime="2022-10-17T11:45:49.046468">

Latest video (if you are interested :))

https://user-images.githubusercontent.com/5236035/192254354-e65a8bd2-9f49-4c5b-acdf-eda3932402f9.mp4

(This comment is also linked from https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit#, i.e. 
[Preemption for 60 FPS (PUBLICLY SHARED) (4).pdf](https://github.com/flutter/flutter/files/9646963/Preemption.for.60.FPS.PUBLICLY.SHARED.4.pdf))


</DiscussionComment>

<DiscussionComment author="moffatman" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-26T12:15:54Z" retrieveTime="2022-10-17T11:45:49.046468">

Is build progress occuring during animation here? Because the effect could be replicated by just delaying the complex content build for ~500 ms (animation duration). 

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-26T12:37:42Z" retrieveTime="2022-10-17T11:45:49.046468">

@moffatman

> Is build progress occuring during animation here

Not completely get the question... If the question is, whether animation happens when the complex widget is being built/layouted, the answer is yes.

> Because the effect could be replicated by just delaying the complex content build for ~500 ms (animation duration).

You need some extra preempt points, instead of a single `sleep(500ms)`. For example, this should work:

```
build() {
  for(var i=0;i<100;++i) {
    Actor.instance.maybePreemptRender();
    sleep(const Duration(milliseconds: 5));
  }
  return your widget;
}
```

Indeed, preempt points are auto injected via PreemptPoint, and (possibly done in the real PR) in every RenderObject.layout. So usually no need to manually write that.

By the way, your original modification does not work, because by default I do not expect a single widget.build to exceed 16ms. Anyway if that is the case just insert a few `maybePreemptRender`.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1023962436723814412" source="discord" createTime="2022-09-26T14:21:09.217+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Good morning friends! Should I start making the PR?
@Hixie @Jonah Williams @dnfield @gaaclarke @Callum @ping (googlers who had discussions about this proposal)

The design doc has been overhauled:
* Add chapter "experiments (prototype)", showing videos, code demos, FPS analysis, and overhead analysis.
* Add section "needed code change", demonstrating what framework and engine code (few) needs to be modified.
* Overhaul chapter "comparison", elaborating the differences.

I want to sincerely say thanks to Flutter. Flutter has saved me months, if not a year, by allowing me to write a single codebase and run on dual platforms (saving half of the time), to use the very productive declarative framework and hot reload, to utilize the quickly-progressing Dart language with expressive and safe type system, to easily customize the appearance as accurate as pixel level, to be able to dig down and modify engine code when I need a new feature (impossible with Web), and many more.

That is a big reason why I decided to contribute this PR (Preemption for 60 FPS) to Flutter. Flutter has saved me so much time, so now it is my turn to provide my time to Flutter to make it better. I also love open source very much, such as my [flutter_rust_bridge](https://github.com/fzyzcjy/flutter_rust_bridge) open-source library (which could have been closed-source and only used by myself), and my previous PRs to Flutter fixing bugs, which is another driving force.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1023962525391396956" source="discord" createTime="2022-09-26T14:21:30.357+00:00" retrieveTime="2022-10-17T11:35:13.053450">

(overhauled design doc) https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024029635975065771" source="discord" createTime="2022-09-26T18:48:10.767+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i still don't understand how you run the animation phase in your proposal. (the discussion in the last comment in the doc)

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgw_vfTs" source="google_doc_comments" createTime="2022-09-26T20:17:01.105Z" retrieveTime="2022-10-17T11:05:47.152504">

It's unclear the mechanism that is used to resume layout.  Are we really resuming or retrying?  In order to resume the whole stack would have to be captured (ie a continuation).

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgw_vfT8" source="google_doc_comments" createTime="2022-09-26T20:35:41.851Z" retrieveTime="2022-10-17T11:05:47.152504">

I'm unfamiliar with how keframe works.  Would this make that library obsolete?  Does it handle all the cases it does?

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgw_vfUw" source="google_doc_comments" createTime="2022-09-26T21:21:30.304Z" retrieveTime="2022-10-17T11:05:47.152504">

What happens if we can't update the existing tree in the 1.667ms we have then?  How do we select this number 15ms?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024088435759251577" source="discord" createTime="2022-09-26T22:41:49.728+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Hixie Hi I add a section "How is animation implemented" just now. Hope I explain it clearly now!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024088529363554424" source="discord" createTime="2022-09-26T22:42:12.045+00:00" retrieveTime="2022-10-17T11:35:13.053450">

(last section in the "detailed design")

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024090751816187944" source="discord" createTime="2022-09-26T22:51:01.919+00:00" retrieveTime="2022-10-17T11:35:13.053450">

ah, i see

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024090772720590878" source="discord" createTime="2022-09-26T22:51:06.903+00:00" retrieveTime="2022-10-17T11:35:13.053450">

so it only works for animations driven from tickers

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024090828777459823" source="discord" createTime="2022-09-26T22:51:20.268+00:00" retrieveTime="2022-10-17T11:35:13.053450">

this whole design seems super fragile to me

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgw_vfXA" source="google_doc_comments" createTime="2022-09-26T22:51:53.514Z" retrieveTime="2022-10-17T11:05:47.152504">

My proposed method is not sensitive to the threshold indeed. In other words, suppose you happen to pause at 15ms, then you do not necessarily need to finish UI thread work and submit to raster thread in 16.67-15=1.67ms. On the contrary, you can, e.g. finish in 2ms or 3ms or 4ms or whatever, as long as raster thread have enough time to finish his hob.

Some details can be found in the "when to call preemptRender" section

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091043601326130" source="discord" createTime="2022-09-26T22:52:11.486+00:00" retrieveTime="2022-10-17T11:35:13.053450">

May I know what other kinds of animations exist in Flutter?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091069543088248" source="discord" createTime="2022-09-26T22:52:17.671+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I personally have only seen those from tickers

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091097045139506" source="discord" createTime="2022-09-26T22:52:24.228+00:00" retrieveTime="2022-10-17T11:35:13.053450">

could be anything

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091142188441660" source="discord" createTime="2022-09-26T22:52:34.991+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Hmm could you please point out where so I can try to improve?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091239605358592" source="discord" createTime="2022-09-26T22:52:58.217+00:00" retrieveTime="2022-10-17T11:35:13.053450">

https://docs.flutter.dev/development/ui/animations

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091329824821330" source="discord" createTime="2022-09-26T22:53:19.727+00:00" retrieveTime="2022-10-17T11:35:13.053450">

what i mean by fragile is that there's lots of ways you could write a flutter app that violates the assumptions made here

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091389375565906" source="discord" createTime="2022-09-26T22:53:33.925+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If I understand correctly, AnimatedBuilder, AnimatedWidget, FooTransition, TweenAnimationBuilder etc all use vsync and tickers

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091510934880329" source="discord" createTime="2022-09-26T22:54:02.907+00:00" retrieveTime="2022-10-17T11:35:13.053450">

like, for example, what if two widgets communicate via some other object, and one is in one of these interruptible subtrees and the other isn't. they'll be seeing different phases at different times

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091515456327681" source="discord" createTime="2022-09-26T22:54:03.985+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Dev only needs to pay attention to the code inside PreemptBuilder.builder, which should be a little of code (instead of a lot)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091581306908712" source="discord" createTime="2022-09-26T22:54:19.685+00:00" retrieveTime="2022-10-17T11:35:13.053450">

That builder is only for smooth animations

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091608687317154" source="discord" createTime="2022-09-26T22:54:26.213+00:00" retrieveTime="2022-10-17T11:35:13.053450">

not for very huge heavy things 🙂

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091648398999675" source="discord" createTime="2022-09-26T22:54:35.681+00:00" retrieveTime="2022-10-17T11:35:13.053450">

that's what i mean by fragile :-)

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091708260089897" source="discord" createTime="2022-09-26T22:54:49.953+00:00" retrieveTime="2022-10-17T11:35:13.053450">

something that isn't fragile would work in many different scenarios

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091808927580190" source="discord" createTime="2022-09-26T22:55:13.954+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Sure I agree with that. But it seems to solve the smoothness at 60fps problem

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091832247930900" source="discord" createTime="2022-09-26T22:55:19.514+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Everything comes with a cost :/

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091923889266698" source="discord" createTime="2022-09-26T22:55:41.363+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Especially with the gain of "60fps, no matter how heavy your subtree is to build and layout"

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024091974933946450" source="discord" createTime="2022-09-26T22:55:53.533+00:00" retrieveTime="2022-10-17T11:35:13.053450">

well, it doesn't really. it solves the "subset of your tree at 60fps" problem :-)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092067368009830" source="discord" createTime="2022-09-26T22:56:15.571+00:00" retrieveTime="2022-10-17T11:35:13.053450">

The "user seeing the UI at 60fps" 🙂

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092105385185290" source="discord" createTime="2022-09-26T22:56:24.635+00:00" retrieveTime="2022-10-17T11:35:13.053450">

sort of. parts will be 30fps :-)

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092110032470087" source="discord" createTime="2022-09-26T22:56:25.743+00:00" retrieveTime="2022-10-17T11:35:13.053450">

anyway

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092151992291398" source="discord" createTime="2022-09-26T22:56:35.747+00:00" retrieveTime="2022-10-17T11:35:13.053450">

is there a way to build this in a package?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092168383627344" source="discord" createTime="2022-09-26T22:56:39.655+00:00" retrieveTime="2022-10-17T11:35:13.053450">

parts that does not need change indeed so users never know it 🙂

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092183223074896" source="discord" createTime="2022-09-26T22:56:43.193+00:00" retrieveTime="2022-10-17T11:35:13.053450">

what does it actually need from the core framework?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092229884715028" source="discord" createTime="2022-09-26T22:56:54.318+00:00" retrieveTime="2022-10-17T11:35:13.053450">

(btw why you can type that face while mine will be a yellow face)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092251896422450" source="discord" createTime="2022-09-26T22:56:59.566+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes and no, the details:

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092288764354580" source="discord" createTime="2022-09-26T22:57:08.356+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i suppose you need to hook into every build/layout

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092331445600347" source="discord" createTime="2022-09-26T22:57:18.532+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1024092331273629726/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092350382870678" source="discord" createTime="2022-09-26T22:57:23.047+00:00" retrieveTime="2022-10-17T11:35:13.053450">

The "needed code change" section

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092415763685476" source="discord" createTime="2022-09-26T22:57:38.635+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So maybe I should PR those framework changes, and then make a package? Or should I PR the whole thing?

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092761613406219" source="discord" createTime="2022-09-26T22:59:01.092+00:00" retrieveTime="2022-10-17T11:35:13.053450">

some of these changes are sort of fundamentally opposed to flutter's design philosophy
like, for example, the widget system shouldn't need to know about tickers
a developer should be able to build an entirely separate animation system and just layer it on top of the framework
but if we do what this proposal suggests, we're really saying that tickers are very special in a core sense

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092818895011870" source="discord" createTime="2022-09-26T22:59:14.749+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Or a way to preempt an isolate, creating a continuation that can be resumed, but that probably isn't going to happen.

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092903770947635" source="discord" createTime="2022-09-26T22:59:34.985+00:00" retrieveTime="2022-10-17T11:35:13.053450">

yeah that seems even more fragile

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024092916408401920" source="discord" createTime="2022-09-26T22:59:37.998+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Btw, not sure what exact problem will they face? The widget in main tree see one ticker per frame. The widget in second tree see many ticker ticks per frame. And they see the same microtasks and event loop run.

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024093082909687870" source="discord" createTime="2022-09-26T23:00:17.695+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i dunno, it's hard to predict. that's what i mean by "fragile".

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024093089188565032" source="discord" createTime="2022-09-26T23:00:19.192+00:00" retrieveTime="2022-10-17T11:35:13.053450">

IIRC I have had some thoughts a bit similar to that before (see that github thread) also without success

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024093185716264960" source="discord" createTime="2022-09-26T23:00:42.206+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I see. Just want to have one example in my mind, really cannot imagine.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024093242595229708" source="discord" createTime="2022-09-26T23:00:55.767+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If there are zero examples then just cannot know what to do/worry with it

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024093324241555496" source="discord" createTime="2022-09-26T23:01:15.233+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i totally understand that my concerns are unsatisfying

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024093413295018065" source="discord" createTime="2022-09-26T23:01:36.465+00:00" retrieveTime="2022-10-17T11:35:13.053450">

It's totally OK, I just need some input to know the concerns better

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024093459973427231" source="discord" createTime="2022-09-26T23:01:47.594+00:00" retrieveTime="2022-10-17T11:35:13.053450">

such that I can try to figure out a way to solve it if it is a problem

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024093518345543880" source="discord" createTime="2022-09-26T23:02:01.511+00:00" retrieveTime="2022-10-17T11:35:13.053450">

let me see if i can think of a good example

</DiscussionComment>

<DiscussionComment author="BetoMan0" link="https://discord.com/channels/608014603317936148/608021234516754444/1024093652164808714" source="discord" createTime="2022-09-26T23:02:33.416+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I hope I'm not making an oot question: isn't the `PreemptBuilder` proposal trying to solve what Impller also aims to solve? (= remove jank on animations by pre-compiling stuff)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024093770687463424" source="discord" createTime="2022-09-26T23:03:01.674+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Well seems not. Impeller solves raster thread jank, PreemptBuilder solves build/layout jank in ui thread

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1024093830288519188" source="discord" createTime="2022-09-26T23:03:15.884+00:00" retrieveTime="2022-10-17T11:35:13.053450">

One piece of feedback that is actionable is imaging what it would take to make this a plugin.

</DiscussionComment>

<DiscussionComment author="BetoMan0" link="https://discord.com/channels/608014603317936148/608021234516754444/1024094034286891028" source="discord" createTime="2022-09-26T23:04:04.521+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Clear, thanks!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024094077072982107" source="discord" createTime="2022-09-26T23:04:14.722+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yes I also think it is a feasible idea. The "Needed code change" section is about "what needs to change framework/engine"

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024094117728354454" source="discord" createTime="2022-09-26T23:04:24.415+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Indeed not many changes to framework/engine

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024094240365625394" source="discord" createTime="2022-09-26T23:04:53.654+00:00" retrieveTime="2022-10-17T11:35:13.053450">

(That section, plus a few "make file-private function public but do not need to change any real functionality")

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024094300147032204" source="discord" createTime="2022-09-26T23:05:07.907+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@fzyzcjy so for example, suppose instead of using a Ticker i have an animation that's driven by a Timer. every time it triggers, it changes some global state. then i have many widgets that follow that global state. with your proposal, the sections inside the special widget would not animate fast.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024094425309249556" source="discord" createTime="2022-09-26T23:05:37.748+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Thanks for the example. However, IIRC "animation by timer" is discouraged?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024094478845358140" source="discord" createTime="2022-09-26T23:05:50.512+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So if a user uses a discouraged approach he gets bad results

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024094716377174026" source="discord" createTime="2022-09-26T23:06:47.144+00:00" retrieveTime="2022-10-17T11:35:13.053450">

writing a widget tree that takes more than 16ms to build is also discouraged, but we're still trying to help people who do that :-)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024094814347726898" source="discord" createTime="2022-09-26T23:07:10.502+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Well that is indeed mandatory, because:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024094876645728337" source="discord" createTime="2022-09-26T23:07:25.355+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1024094875139969074/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024094981427839006" source="discord" createTime="2022-09-26T23:07:50.337+00:00" retrieveTime="2022-10-17T11:35:13.053450">

In other words, a dev trying the best to follow Flutter suggestions still may face the build/layout-more-than-16ms problem

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095026596302848" source="discord" createTime="2022-09-26T23:08:01.106+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Such as bytedance

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095081659109436" source="discord" createTime="2022-09-26T23:08:14.234+00:00" retrieveTime="2022-10-17T11:35:13.053450">

And there are just so many really slow devices in the world indeed

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095218070462504" source="discord" createTime="2022-09-26T23:08:46.757+00:00" retrieveTime="2022-10-17T11:35:13.053450">

it's really important for us that flutter be something thet's predictable and easy to understand

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095238488346654" source="discord" createTime="2022-09-26T23:08:51.625+00:00" retrieveTime="2022-10-17T11:35:13.053450">

It is just impossible to be smooth on all slow, slower, slower than slower devices (without the proposal). layout/build really needs some time, and on them it can exceed 16ms

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095261087240192" source="discord" createTime="2022-09-26T23:08:57.013+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I totally agree

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095319492927498" source="discord" createTime="2022-09-26T23:09:10.938+00:00" retrieveTime="2022-10-17T11:35:13.053450">

for well-behaved users 😉

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095334672109599" source="discord" createTime="2022-09-26T23:09:14.557+00:00" retrieveTime="2022-10-17T11:35:13.053450">

for everyone

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095389504253952" source="discord" createTime="2022-09-26T23:09:27.63+00:00" retrieveTime="2022-10-17T11:35:13.053450">

because people don't necessarily know what best practices are

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095420172996659" source="discord" createTime="2022-09-26T23:09:34.942+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Hmm I see

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095464729104465" source="discord" createTime="2022-09-26T23:09:45.565+00:00" retrieveTime="2022-10-17T11:35:13.053450">

and they will never be able to learn if they get frustrated with a system that isn't helping them when they're new

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095491954331668" source="discord" createTime="2022-09-26T23:09:52.056+00:00" retrieveTime="2022-10-17T11:35:13.053450">

such that they just give up

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095505627750490" source="discord" createTime="2022-09-26T23:09:55.316+00:00" retrieveTime="2022-10-17T11:35:13.053450">

totally agree

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095555988754572" source="discord" createTime="2022-09-26T23:10:07.323+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but I am not very sure will a new learner really use PreemptBuilder?

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095642408198264" source="discord" createTime="2022-09-26T23:10:27.927+00:00" retrieveTime="2022-10-17T11:35:13.053450">

yes, because they'll google around "how to help slow app" and they'll find a youtube video that talks about it and they'll try it

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095645210001418" source="discord" createTime="2022-09-26T23:10:28.595+00:00" retrieveTime="2022-10-17T11:35:13.053450">

or should we add some doc to PreemptBuilder saying the care needed

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095696393097246" source="discord" createTime="2022-09-26T23:10:40.798+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Ah that is quite reasonable

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095777515118652" source="discord" createTime="2022-09-26T23:11:00.139+00:00" retrieveTime="2022-10-17T11:35:13.053450">

or use the alternative approach you mentioned above - I publish a package about it

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024095870859366500" source="discord" createTime="2022-09-26T23:11:22.394+00:00" retrieveTime="2022-10-17T11:35:13.053450">

then in the package frontpage I can just have a big warning saying "hey don't use timers" and so on

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024096275311894619" source="discord" createTime="2022-09-26T23:12:58.823+00:00" retrieveTime="2022-10-17T11:35:13.053450">

another example would be, suppose there's two RenderObjects and they each create a Layer and those Layers know they will always be used together because the RenderObjects are always used together. So they can rely on always existing as a pair and can always read the render object sizes and so on when the layer tree is walked.
now suppose one of those RenderObjects is in the "expensive" part of the subtree and the other is in the "fast" part of the subtree.
or suppose one is in the "expensive" part that got laid out before we interrupted layout, and the other is in the part that got laid out later.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024096669698117732" source="discord" createTime="2022-09-26T23:14:32.852+00:00" retrieveTime="2022-10-17T11:35:13.053450">

That looks like a problem as well. But may I know how layers read RO sizes? IIRC layers do not remember ROs

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024096700001955941" source="discord" createTime="2022-09-26T23:14:40.077+00:00" retrieveTime="2022-10-17T11:35:13.053450">

they can do whatevery they want

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024096708373786644" source="discord" createTime="2022-09-26T23:14:42.073+00:00" retrieveTime="2022-10-17T11:35:13.053450">

they're just code

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024096759502344252" source="discord" createTime="2022-09-26T23:14:54.263+00:00" retrieveTime="2022-10-17T11:35:13.053450">

That sounds like a problem

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024096931909206077" source="discord" createTime="2022-09-26T23:15:35.368+00:00" retrieveTime="2022-10-17T11:35:13.053450">

For expert users who uses custom layers

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097019767304262" source="discord" createTime="2022-09-26T23:15:56.315+00:00" retrieveTime="2022-10-17T11:35:13.053450">

another example would be GlobalKey reparenting. Suppose the section of the subtree on the "fast" branch tries to move a widget from the section of the tree in the "expensive" branch using GlobalKeys.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097112759222282" source="discord" createTime="2022-09-26T23:16:18.486+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I see, that will definitely not work.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097174142865488" source="discord" createTime="2022-09-26T23:16:33.121+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But IMHO no "animation" requires moving it

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097208724897882" source="discord" createTime="2022-09-26T23:16:41.366+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But I agree we should be friendly to all edge cases

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097242690367588" source="discord" createTime="2022-09-26T23:16:49.464+00:00" retrieveTime="2022-10-17T11:35:13.053450">

fundamentally the problem is that your proposal violates some of the core assumptions of the framework

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097318347214929" source="discord" createTime="2022-09-26T23:17:07.502+00:00" retrieveTime="2022-10-17T11:35:13.053450">

such as, that we'll always do a single build/layout/paint/layer/semantics pass per frame

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097323887890462" source="discord" createTime="2022-09-26T23:17:08.823+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I agree, it is just the least violation I can find

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097461679173632" source="discord" createTime="2022-09-26T23:17:41.675+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I refine to: per tree per pseudo or real frame. fast tree it is 60fps  pseudo "frame"

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097584370941962" source="discord" createTime="2022-09-26T23:18:10.927+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I have also tried other methods and there are previous thoughts about other methods as well, but seem they have drawbacks or cannot work

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097612237906032" source="discord" createTime="2022-09-26T23:18:17.571+00:00" retrieveTime="2022-10-17T11:35:13.053450">

(See "Comparison" chapter)

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097627605844100" source="discord" createTime="2022-09-26T23:18:21.235+00:00" retrieveTime="2022-10-17T11:35:13.053450">

any time you violate core assumptions, you have to either very carefully think about what the new assumptions should be that we can make sure the entire model follows these new assumptions, or things will become fragile

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097701249425469" source="discord" createTime="2022-09-26T23:18:38.793+00:00" retrieveTime="2022-10-17T11:35:13.053450">

totally agree

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097727258296330" source="discord" createTime="2022-09-26T23:18:44.994+00:00" retrieveTime="2022-10-17T11:35:13.053450">

(it's often extremely hard to do this)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097751853695067" source="discord" createTime="2022-09-26T23:18:50.858+00:00" retrieveTime="2022-10-17T11:35:13.053450">

think so :/

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024097948604313632" source="discord" createTime="2022-09-26T23:19:37.767+00:00" retrieveTime="2022-10-17T11:35:13.053450">

the problem with a system like flutter's, which has many years of work already done on it, is that there's a lot of these assumptions and it's easy to just not know about some of them. e.g. i'm sure i don't know them all at this point.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098031194345543" source="discord" createTime="2022-09-26T23:19:57.458+00:00" retrieveTime="2022-10-17T11:35:13.053450">

totally agree about that

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098066111934496" source="discord" createTime="2022-09-26T23:20:05.783+00:00" retrieveTime="2022-10-17T11:35:13.053450">

so should I just make a package and publish to pub.dev?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098110361841734" source="discord" createTime="2022-09-26T23:20:16.333+00:00" retrieveTime="2022-10-17T11:35:13.053450">

with minimal necessary modifications to framework and engine

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098227957547110" source="discord" createTime="2022-09-26T23:20:44.37+00:00" retrieveTime="2022-10-17T11:35:13.053450">

it would be interesting to examine what the minimal changes would need to be

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098292658884628" source="discord" createTime="2022-09-26T23:20:59.796+00:00" retrieveTime="2022-10-17T11:35:13.053450">

mainly this
![image](https://cdn.discordapp.com/attachments/608021234516754444/1024098292314943538/unknown.png)

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098298992263278" source="discord" createTime="2022-09-26T23:21:01.306+00:00" retrieveTime="2022-10-17T11:35:13.053450">

the list currently in the doc is probably not minimal enough to justify doing

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098354436767774" source="discord" createTime="2022-09-26T23:21:14.525+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Let me think whether it is possible to remove some

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098358949859368" source="discord" createTime="2022-09-26T23:21:15.601+00:00" retrieveTime="2022-10-17T11:35:13.053450">

for example, i definitely don't think we should elevate Tickers in this way

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098456052170792" source="discord" createTime="2022-09-26T23:21:38.752+00:00" retrieveTime="2022-10-17T11:35:13.053450">

and adding a hook to every build/layout step is going to be a cost everyone would pay even if they don't use the feature

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098488851636278" source="discord" createTime="2022-09-26T23:21:46.572+00:00" retrieveTime="2022-10-17T11:35:13.053450">

which is probably not something we'd want to do

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098518425681971" source="discord" createTime="2022-09-26T23:21:53.623+00:00" retrieveTime="2022-10-17T11:35:13.053450">

especially when the goal is to make things faster :-)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098613342781450" source="discord" createTime="2022-09-26T23:22:16.253+00:00" retrieveTime="2022-10-17T11:35:13.053450">

May I know why?

</DiscussionComment>

<DiscussionComment author="gaaclarke" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098652064595989" source="discord" createTime="2022-09-26T23:22:25.485+00:00" retrieveTime="2022-10-17T11:35:13.053450">

we could potentially allow people to swap out the layout function with zero cost or one layer of indirection at the top of the tree

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098773296758904" source="discord" createTime="2022-09-26T23:22:54.389+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I am not expert in compiler, but will it introduce runtime cost if the hook is always null? (Will compiler throw it away)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024098997654278144" source="discord" createTime="2022-09-26T23:23:47.88+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Or maybe we can do what @gaaclarke suggests, say create a `Renderer.layout(RenderObject ro)` and I just `class MyRenderer extends Renderer`

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024099008643346502" source="discord" createTime="2022-09-26T23:23:50.5+00:00" retrieveTime="2022-10-17T11:35:13.053450">

flutter's tried to follow a "layered" approach, where there are very few "core" components that one _must_ use. For example, you can use RenderObjects without widgets. You can use widgets without material. You don't have to use WidgetsApp if you don't want to. You don't have to use Tickers if you don't want to. etc.

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024099188079870023" source="discord" createTime="2022-09-26T23:24:33.281+00:00" retrieveTime="2022-10-17T11:35:13.053450">

if there's a way to do that that's zero cost during normal operations, that's worth considering

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024099218941550652" source="discord" createTime="2022-09-26T23:24:40.639+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i'm sure lots of packages could benefit from that kind of hook

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024099244610686986" source="discord" createTime="2022-09-26T23:24:46.759+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Oh I see maybe I do not explain clearly. We do *not*expose all tickers. We only expose those who are created inside SingleTickerProviderStateMixin

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024099333697716274" source="discord" createTime="2022-09-26T23:25:07.999+00:00" retrieveTime="2022-10-17T11:35:13.053450">

We already let SingleTickerProviderStateMixin to read TickerMode (inherited widget) so looks like we are just doing something mimicking the existing

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024099481597251624" source="discord" createTime="2022-09-26T23:25:43.261+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Then maybe I should try that `class Renderer` and report some metrics later

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024099652955553865" source="discord" createTime="2022-09-26T23:26:24.116+00:00" retrieveTime="2022-10-17T11:35:13.053450">

right my point is that TickerMode is just a widget. you don't have to use it. SingleTickerProviderStateMixin is just a tool, you don't have to use it. But if we say that SingleTickerProviderStateMixin now exposes a special API, we're saying it's special in a way that MyCustomSingleTickerProviderStateMixin is not, and can never be.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024099923056132117" source="discord" createTime="2022-09-26T23:27:28.513+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Sorry I do not quite get it. I am trying to modify SingleTickerProviderStateMixin in a ways that, originally it calls TickerMode (inherited widget), not it calls TickerMode + TickerRegistry (another inherited widget)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100072268501002" source="discord" createTime="2022-09-26T23:28:04.088+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1024100071861657611/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100104510128158" source="discord" createTime="2022-09-26T23:28:11.775+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1024100104195551314/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100162844504105" source="discord" createTime="2022-09-26T23:28:25.683+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Just read an inherited widget, completely mimicking what we do to TickerMode

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100289457958992" source="discord" createTime="2022-09-26T23:28:55.87+00:00" retrieveTime="2022-10-17T11:35:13.053450">

(code may not be exactly mimic though if merely looking at the screenshot; but digging down one or two function calls we see it is the same)

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100394659487805" source="discord" createTime="2022-09-26T23:29:20.952+00:00" retrieveTime="2022-10-17T11:35:13.053450">

what would TickerRegistry do?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100497667407953" source="discord" createTime="2022-09-26T23:29:45.511+00:00" retrieveTime="2022-10-17T11:35:13.053450">

It knows all tickers in the subtree and created by TickerProviderStateMixin

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100573475242064" source="discord" createTime="2022-09-26T23:30:03.585+00:00" retrieveTime="2022-10-17T11:35:13.053450">

so now if i want to make a new kind of Ticker, how do i register it?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100584325922856" source="discord" createTime="2022-09-26T23:30:06.172+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Then in PreemptBuilder (e.g. in 3rd package), we just call all of those tickers's onTick

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100630048022618" source="discord" createTime="2022-09-26T23:30:17.073+00:00" retrieveTime="2022-10-17T11:35:13.053450">

MyCustomTicker, which has no interfaces in common with Ticker

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100633642541117" source="discord" createTime="2022-09-26T23:30:17.93+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Just like how you register it with TickerMode

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100665053687849" source="discord" createTime="2022-09-26T23:30:25.419+00:00" retrieveTime="2022-10-17T11:35:13.053450">

TickerMode doesn't know about Tickers

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100718237450350" source="discord" createTime="2022-09-26T23:30:38.099+00:00" retrieveTime="2022-10-17T11:35:13.053450">

it just reports a boolean

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100781403668500" source="discord" createTime="2022-09-26T23:30:53.159+00:00" retrieveTime="2022-10-17T11:35:13.053450">

and notifies you when it changes

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100875783917618" source="discord" createTime="2022-09-26T23:31:15.661+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Then what about making TickerRegistry receive an abstract class (interface) instead of the real Ticker class

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100907262152745" source="discord" createTime="2022-09-26T23:31:23.166+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Or , I know it:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100944784392233" source="discord" createTime="2022-09-26T23:31:32.112+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Just do not let TickerRegistry know the tickers

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024100974077419550" source="discord" createTime="2022-09-26T23:31:39.096+00:00" retrieveTime="2022-10-17T11:35:13.053450">

so then what does it do?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024101064686964776" source="discord" createTime="2022-09-26T23:32:00.699+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Instead, let it (maybe w/a rename) provide `addListenerWhenOtherPartsOfSystemWantsToCallAnExtraOnTick`

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024101626698539008" source="discord" createTime="2022-09-26T23:34:14.693+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So now the MyCustomTicker (not extend/implement Ticker) is happy

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102166685810788" source="discord" createTime="2022-09-26T23:36:23.436+00:00" retrieveTime="2022-10-17T11:35:13.053450">

e.g. named "ExtraOnTickProvider"

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102321807962112" source="discord" createTime="2022-09-26T23:37:00.42+00:00" retrieveTime="2022-10-17T11:35:13.053450">

basically this makes ExtraOnTickProvider a special class

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102410123235438" source="discord" createTime="2022-09-26T23:37:21.476+00:00" retrieveTime="2022-10-17T11:35:13.053450">

May I know why it is special?

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102507795984425" source="discord" createTime="2022-09-26T23:37:44.763+00:00" retrieveTime="2022-10-17T11:35:13.053450">

anyone who wants to participate in this model has to make sure they can express their animation logic as an ExtraOnTickProvider

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102645742448741" source="discord" createTime="2022-09-26T23:38:17.652+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Well, again, is there real examples who create CustomTicker unrelated to real ticker logic...

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102696946516028" source="discord" createTime="2022-09-26T23:38:29.86+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If so he must be an expert

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102741120925706" source="discord" createTime="2022-09-26T23:38:40.392+00:00" retrieveTime="2022-10-17T11:35:13.053450">

And experts should understand how PreemptBuilder works 😉

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102798188621834" source="discord" createTime="2022-09-26T23:38:53.998+00:00" retrieveTime="2022-10-17T11:35:13.053450">

as we talked about before, that's not a safe line of reasoning

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102871257600000" source="discord" createTime="2022-09-26T23:39:11.419+00:00" retrieveTime="2022-10-17T11:35:13.053450">

non-experts will be exposed to all APIs

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102889448292452" source="discord" createTime="2022-09-26T23:39:15.756+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I totally agree we should be friendly to new users watching a youtube video

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102918510628965" source="discord" createTime="2022-09-26T23:39:22.685+00:00" retrieveTime="2022-10-17T11:35:13.053450">

"only experts will use it" is never a valid way to design APIs

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102952761294908" source="discord" createTime="2022-09-26T23:39:30.851+00:00" retrieveTime="2022-10-17T11:35:13.053450">

because everyone is a non-expert the first time they use an API

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102959820329082" source="discord" createTime="2022-09-26T23:39:32.534+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Well, ok :/

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024102999833976892" source="discord" createTime="2022-09-26T23:39:42.074+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I just mean not sure who will really need this

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103027008876645" source="discord" createTime="2022-09-26T23:39:48.553+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Ok then let me think about other ways to expose Tickers

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103048324325467" source="discord" createTime="2022-09-26T23:39:53.635+00:00" retrieveTime="2022-10-17T11:35:13.053450">

fwiw i think this is something we could have done from the beginning, basically instead of the animation phase which relies on scheduleMicrotask as the special magic, we would have a registry of OnTickProviders that provide the special magic

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103140032786492" source="discord" createTime="2022-09-26T23:40:15.5+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Totally agree. But seems we can never change it today? 😦

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103199172481195" source="discord" createTime="2022-09-26T23:40:29.6+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but having now gone the former route, moving to the latter route either means having extra complexity (because we have both), or means taking on the rather large task of migrating the entire ecosystem to the new mechanism

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103251148296215" source="discord" createTime="2022-09-26T23:40:41.992+00:00" retrieveTime="2022-10-17T11:35:13.053450">

sometimes we have done that kind of thing

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103328281530468" source="discord" createTime="2022-09-26T23:41:00.382+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I can contribute

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103371348643850" source="discord" createTime="2022-09-26T23:41:10.65+00:00" retrieveTime="2022-10-17T11:35:13.053450">

e.g. at one point State.widget was called State.config and someone (i forget who?) renamed it and basically migrated the entire ecosystem to the new name

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103413354606634" source="discord" createTime="2022-09-26T23:41:20.665+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but that was a long time ago and the ecosystem is much bigger now

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103436008038440" source="discord" createTime="2022-09-26T23:41:26.066+00:00" retrieveTime="2022-10-17T11:35:13.053450">

that's true

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103468199325696" source="discord" createTime="2022-09-26T23:41:33.741+00:00" retrieveTime="2022-10-17T11:35:13.053450">

(and congratulations!)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103521924153354" source="discord" createTime="2022-09-26T23:41:46.55+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So what about this:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103679156031509" source="discord" createTime="2022-09-26T23:42:24.037+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Change `SingleTickerProviderStateMixin.createTicker` . Do not `ticker = Ticker()`. But instead `ticker = TickerProviderConfigInheritedWidget.of(context).createTicker()`

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103730611765269" source="discord" createTime="2022-09-26T23:42:36.305+00:00" retrieveTime="2022-10-17T11:35:13.053450">

In other words, we have a new TickerProviderConfigInheritedWidget

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103772349268000" source="discord" createTime="2022-09-26T23:42:46.256+00:00" retrieveTime="2022-10-17T11:35:13.053450">

it just configures how TickerProviderStateMixin create tickers

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103883447992392" source="discord" createTime="2022-09-26T23:43:12.744+00:00" retrieveTime="2022-10-17T11:35:13.053450">

SingleTickerProviderStateMixin.createTicker is not the only way animation triggers are created

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103900111966298" source="discord" createTime="2022-09-26T23:43:16.717+00:00" retrieveTime="2022-10-17T11:35:13.053450">

When there is no such inherited widget, just do the old logic: `new Ticker()`

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103946194792499" source="discord" createTime="2022-09-26T23:43:27.704+00:00" retrieveTime="2022-10-17T11:35:13.053450">

May I know what are the others?

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024103979770187846" source="discord" createTime="2022-09-26T23:43:35.709+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Timer.periodic, for example

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024104005011521567" source="discord" createTime="2022-09-26T23:43:41.727+00:00" retrieveTime="2022-10-17T11:35:13.053450">

That just will not be supported

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024104032610025522" source="discord" createTime="2022-09-26T23:43:48.307+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Streams are another

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024104109877514261" source="discord" createTime="2022-09-26T23:44:06.729+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Since these logic are in my 3rd party package I guess it is not a huge problem

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024104151552098364" source="discord" createTime="2022-09-26T23:44:16.665+00:00" retrieveTime="2022-10-17T11:35:13.053450">

just write down "Stream and Timer are not supported" in README

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024104160607600713" source="discord" createTime="2022-09-26T23:44:18.824+00:00" retrieveTime="2022-10-17T11:35:13.053450">

of the 3rd package

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024104183349137479" source="discord" createTime="2022-09-26T23:44:24.246+00:00" retrieveTime="2022-10-17T11:35:13.053450">

yeah it's a lot easier if it's a package than the core framework

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024104264781533254" source="discord" createTime="2022-09-26T23:44:43.661+00:00" retrieveTime="2022-10-17T11:35:13.053450">

And also easier to upgrade as well (no need to wait 3mo for next stable flutter if someone sees a bug)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024104609725304965" source="discord" createTime="2022-09-26T23:46:05.902+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1024104609570111579/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024104671264133150" source="discord" createTime="2022-09-26T23:46:20.574+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So looks like my next step is to create these 4 PRs to Flutter?

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024106444519378995" source="discord" createTime="2022-09-26T23:53:23.351+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i think for each one we should carefully consider if there are potentially better ways to approach it

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024106489327144971" source="discord" createTime="2022-09-26T23:53:34.034+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Sure 🙂

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024106499150188634" source="discord" createTime="2022-09-26T23:53:36.376+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but that's definitely more tractable than the earlier list :-)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024106772501381201" source="discord" createTime="2022-09-26T23:54:41.548+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Feel free to raise any potential problems and I will try to fix them

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024107442717610034" source="discord" createTime="2022-09-26T23:57:21.34+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i haven't studied the engine changes yet

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024107476917960734" source="discord" createTime="2022-09-26T23:57:29.494+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i'm still looking at the ticker one :-)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024107550221799464" source="discord" createTime="2022-09-26T23:57:46.971+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I see, take your time 🙂

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024107596245913750" source="discord" createTime="2022-09-26T23:57:57.944+00:00" retrieveTime="2022-10-17T11:35:13.053450">

the problem you're trying to solve is, how to cause CircularProgressIndicator to tick, even though we haven't had an animation phase, right?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024107640378380288" source="discord" createTime="2022-09-26T23:58:08.466+00:00" retrieveTime="2022-10-17T11:35:13.053450">

yes

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024107798801420289" source="discord" createTime="2022-09-26T23:58:46.237+00:00" retrieveTime="2022-10-17T11:35:13.053450">

and _CircularProgressIndicatorState uses an AnimationController with a Ticker created from a SingleTickerProviderStateMixin

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024107862387077230" source="discord" createTime="2022-09-26T23:59:01.397+00:00" retrieveTime="2022-10-17T11:35:13.053450">

yes just like that

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024107942397624410" source="discord" createTime="2022-09-26T23:59:20.473+00:00" retrieveTime="2022-10-17T11:35:13.053450">

and ticker uses SchedulerBinding.instance.scheduleFrameCallback

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024107969845153903" source="discord" createTime="2022-09-26T23:59:27.017+00:00" retrieveTime="2022-10-17T11:35:13.053450">

interesting

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024107976316948641" source="discord" createTime="2022-09-26T23:59:28.56+00:00" retrieveTime="2022-10-17T11:35:13.053450">

exactly

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024108232165298196" source="discord" createTime="2022-09-27T00:00:29.559+00:00" retrieveTime="2022-10-17T11:35:13.053450">

and the problem is that after you render your interrupted frame, you want to rerun all the newly scheduled frame callbacks, so that when you repaint this widget, it ends up advanced a little...

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024108290042511381" source="discord" createTime="2022-09-27T00:00:43.358+00:00" retrieveTime="2022-10-17T11:35:13.053450">

not all indeed

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024108320505745500" source="discord" createTime="2022-09-27T00:00:50.621+00:00" retrieveTime="2022-10-17T11:35:13.053450">

only those in second tree

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024108389812416632" source="discord" createTime="2022-09-27T00:01:07.145+00:00" retrieveTime="2022-10-17T11:35:13.053450">

that's why I make inherited widget - I put one at root of second tree

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024108420338569300" source="discord" createTime="2022-09-27T00:01:14.423+00:00" retrieveTime="2022-10-17T11:35:13.053450">

ah, even trickier

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024108458020192396" source="discord" createTime="2022-09-27T00:01:23.407+00:00" retrieveTime="2022-10-17T11:35:13.053450">

because I do not want to disturb the main tree

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024109403772817458" source="discord" createTime="2022-09-27T00:05:08.892+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i certainly see why you gravitate to a way to create and/or register tickers via inherited widget

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024109750171996180" source="discord" createTime="2022-09-27T00:06:31.48+00:00" retrieveTime="2022-10-17T11:35:13.053450">

ironically it would be easier to solve if you wanted to just call the scheduled frame callbacks of every animation

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024109862306717736" source="discord" createTime="2022-09-27T00:06:58.215+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I agree. But that will cause trouble since main tree will receive extra ontick

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024110139214659585" source="discord" createTime="2022-09-27T00:08:04.235+00:00" retrieveTime="2022-10-17T11:35:13.053450">

because then you could just create a new binding...

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024110145069920256" source="discord" createTime="2022-09-27T00:08:05.631+00:00" retrieveTime="2022-10-17T11:35:13.053450">

hmm

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024110193379917854" source="discord" createTime="2022-09-27T00:08:17.149+00:00" retrieveTime="2022-10-17T11:35:13.053450">

hmm looks hard to make two bindings and let things in second subtree smartly register to second binding

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024110474373103646" source="discord" createTime="2022-09-27T00:09:24.143+00:00" retrieveTime="2022-10-17T11:35:13.053450">

yeah the binding logic knows nothing about the trees

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024110832168214538" source="discord" createTime="2022-09-27T00:10:49.448+00:00" retrieveTime="2022-10-17T11:35:13.053450">

yeah i dunno how to do this efficiently. i don't think we want to change SingleTickerProviderStateMixin et al to register their tickers, that seems like a lot of cycles spent that most people would never get to benefit from. (That said, if you can find a way to hook into layout cheaply, maybe we can expose a hook for SingleTickerProviderStateMixin too?)

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024110852636430376" source="discord" createTime="2022-09-27T00:10:54.328+00:00" retrieveTime="2022-10-17T11:35:13.053450">

tell me more about the engine changes?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024111451163594833" source="discord" createTime="2022-09-27T00:13:17.028+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> a lot of cycles spent that most people would never get to benefit from. (That said, if you can find a way to hook into layout cheaply, maybe we can expose a hook for SingleTickerProviderStateMixin too?)
I will experiment to see whether performance regresses

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024111575386308628" source="discord" createTime="2022-09-27T00:13:46.645+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So, is it enough to see benchmarks built into flutter repository? If they do not regress are we safe

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024111658307682354" source="discord" createTime="2022-09-27T00:14:06.415+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i mean to be clear, performance will definitely regress if we do more work, even if we can't measure it

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024111707708198943" source="discord" createTime="2022-09-27T00:14:18.193+00:00" retrieveTime="2022-10-17T11:35:13.053450">

That's definitely true

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024111813605994516" source="discord" createTime="2022-09-27T00:14:43.441+00:00" retrieveTime="2022-10-17T11:35:13.053450">

we can't just add code that doesn't measurably affect benchmarks because if we did that 100 times then we would have moved the benchmarks

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024111972213587979" source="discord" createTime="2022-09-27T00:15:21.256+00:00" retrieveTime="2022-10-17T11:35:13.053450">

totally agree. what about this: we just have a global flag, `enableTickerConfig`. If it is false, do the old thing. If it is true, read Inherited Widget

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024112035597926400" source="discord" createTime="2022-09-27T00:15:36.368+00:00" retrieveTime="2022-10-17T11:35:13.053450">

And in my 3rd party package, one setup step is "set enableTickerConfig=true"

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024112063758479410" source="discord" createTime="2022-09-27T00:15:43.082+00:00" retrieveTime="2022-10-17T11:35:13.053450">

and by default false

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024112283581960232" source="discord" createTime="2022-09-27T00:16:35.492+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Or, we just do not call inherited widget at all

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024112371339378708" source="discord" createTime="2022-09-27T00:16:56.415+00:00" retrieveTime="2022-10-17T11:35:13.053450">

we call a function, say: `Ticker Function(BuildContext context, VoidCallback onTick) tickerCreator = (_, onTick) => Ticker(onTick)`

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024112470375280690" source="discord" createTime="2022-09-27T00:17:20.027+00:00" retrieveTime="2022-10-17T11:35:13.053450">

it by default is nothing but `Ticker.new`, and we can set it to read the inherited widget
And I guess compilers may even inline it, if that createTheTicker is never setted?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024112582707122206" source="discord" createTime="2022-09-27T00:17:46.809+00:00" retrieveTime="2022-10-17T11:35:13.053450">

It is in the screenshot. I can explain more if something is unclear

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024113031086616576" source="discord" createTime="2022-09-27T00:19:33.711+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Indeed we are unconditionally reading inherited widget (b/c the TickerMode) whenever we create one Ticker.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024113099554422905" source="discord" createTime="2022-09-27T00:19:50.035+00:00" retrieveTime="2022-10-17T11:35:13.053450">

And I guess reading inh widget is much much more expensive that a function call that can possibly be inlined

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024113138653728899" source="discord" createTime="2022-09-27T00:19:59.357+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Though I know a little accumulates to a lot

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024113568653787176" source="discord" createTime="2022-09-27T00:21:41.877+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Or, for absolutely zero overhead: Maybe enable it by `bool.fromEnvironement` flag. IIRC those are compile time constants, and compilers will just handle them at compile time. for example, `kDebugMode ? heavy_work : cheap_work`, the heavy_work seems even not in the final binary

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024113718134591540" source="discord" createTime="2022-09-27T00:22:17.516+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Users of the 3rd party package will need `--dart-define=enableTheTickerConfig=true` or something like that. And other users have exactly zero overhead.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024115109544607785" source="discord" createTime="2022-09-27T00:27:49.254+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Hope this is a bit clearer:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024115484305666078" source="discord" createTime="2022-09-27T00:29:18.604+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1024115483961741333/unknown.png)

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024130227619778651" source="discord" createTime="2022-09-27T01:27:53.684+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i meant tell me more about why those specific changes

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024130371710890085" source="discord" createTime="2022-09-27T01:28:28.038+00:00" retrieveTime="2022-10-17T11:35:13.053450">

it sounds like what you are trying to do is allow frames to be rendered from a different callback than the one that asked for it, right?

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024130609565667420" source="discord" createTime="2022-09-27T01:29:24.747+00:00" retrieveTime="2022-10-17T11:35:13.053450">

hm, this is another one of those cases where there's some pretty fundamental assumptions built into the system that we would be breaking here, and need to think very carefully about

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024130786766631002" source="discord" createTime="2022-09-27T01:30:06.995+00:00" retrieveTime="2022-10-17T11:35:13.053450">

that has the problem of being hard to test (we would need to run all the tests for every combination of these flags, which gets exponentially expensive)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024132284158312509" source="discord" createTime="2022-09-27T01:36:04.001+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I see the problem. What about this:
```
bool? debugOverrideTheFlag;
bool get theFlag {
  var ans;
  assert(() => ans = debugOverrideTheFlag);
  return ans ?? bool.fromEnvironment('the.flag');
}
```
It has zero overhead in release (given it is just a compile time constant). And it has testability (just debugOverrideTheFlag)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024133369837137931" source="discord" createTime="2022-09-27T01:40:22.847+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1024133369568690186/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024133377101672468" source="discord" createTime="2022-09-27T01:40:24.579+00:00" retrieveTime="2022-10-17T11:35:13.053450">

"Why" added to the doc now

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024133451269550120" source="discord" createTime="2022-09-27T01:40:42.262+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I guess no? i.e. I do not violate it?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024133679653588992" source="discord" createTime="2022-09-27T01:41:36.713+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I am still calling window.render inside the BeginFrame callback, because the preemptRender is a function called from build/layout functions which is called from BeginFrame. I just call it multiple times (instead of one time).

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024133765431316491" source="discord" createTime="2022-09-27T01:41:57.164+00:00" retrieveTime="2022-10-17T11:35:13.053450">

So I guess I do not break this

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024136073657450516" source="discord" createTime="2022-09-27T01:51:07.488+00:00" retrieveTime="2022-10-17T11:35:13.053450">

but then presumably we would not call it for the next actual BeginFrame, right? since we'd have already done it

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024136184932352010" source="discord" createTime="2022-09-27T01:51:34.018+00:00" retrieveTime="2022-10-17T11:35:13.053450">

May I know what is "it"?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024136335130361898" source="discord" createTime="2022-09-27T01:52:09.828+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If "it" is "Produce", then that still calls in next BeginFrame

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024136418378924042" source="discord" createTime="2022-09-27T01:52:29.676+00:00" retrieveTime="2022-10-17T11:35:13.053450">

The logic is, at Render, when we see no continuation (this happens when one BeginFrame has two window.render), originally we just halt early

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024136520992575548" source="discord" createTime="2022-09-27T01:52:54.141+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But now, when this case, we add one extra continuation via Produce().

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024136664349687808" source="discord" createTime="2022-09-27T01:53:28.32+00:00" retrieveTime="2022-10-17T11:35:13.053450">

We will finish this Produce() just a few lines below. So in next BeginFrame we need to Produce() again (for the next frame's Render)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024136887591514272" source="discord" createTime="2022-09-27T01:54:21.545+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1024136887214014484/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024136916104392804" source="discord" createTime="2022-09-27T01:54:28.343+00:00" retrieveTime="2022-10-17T11:35:13.053450">

the blue-highlighted lines are "finish the Produce continuation" logic

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024136960899567618" source="discord" createTime="2022-09-27T01:54:39.023+00:00" retrieveTime="2022-10-17T11:35:13.053450">

it=window.render

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024137011302502531" source="discord" createTime="2022-09-27T01:54:51.04+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Oh, then we still call it in the next frame

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024137100167221269" source="discord" createTime="2022-09-27T01:55:12.227+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Because in my proposal, one plain-old frame will have zero to many extra smooth window.render

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024137140361240577" source="discord" createTime="2022-09-27T01:55:21.81+00:00" retrieveTime="2022-10-17T11:35:13.053450">

But that plain-old frame is just there. It runs normal full pipeline

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024137168685379584" source="discord" createTime="2022-09-27T01:55:28.563+00:00" retrieveTime="2022-10-17T11:35:13.053450">

including window.render inside that pipeline

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024137406049435719" source="discord" createTime="2022-09-27T01:56:25.155+00:00" retrieveTime="2022-10-17T11:35:13.053450">

oh I see, we just skip the BeginFrame for "missed" frames that this would partially render

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024137593618698300" source="discord" createTime="2022-09-27T01:57:09.875+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If a frame is missed, the whole pipeline just do not execute, and the proposed PreemptBuilder etc also do not execute

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024137629689716866" source="discord" createTime="2022-09-27T01:57:18.475+00:00" retrieveTime="2022-10-17T11:35:13.053450">

how can we know the right timestamp for the "fast" frames if we don't get the BeginFrame call?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024137698476302467" source="discord" createTime="2022-09-27T01:57:34.875+00:00" retrieveTime="2022-10-17T11:35:13.053450">

via the last PR among the four: Get latest vsync data

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024137756382859304" source="discord" createTime="2022-09-27T01:57:48.681+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Indeed only need to read "what is the latest vsync data" once per 16ms

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024137893574357014" source="discord" createTime="2022-09-27T01:58:21.39+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Btw I have confirmed the time is correct in the experiment analysis section

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024137927833440266" source="discord" createTime="2022-09-27T01:58:29.558+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1024137927216857169/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024138032749744200" source="discord" createTime="2022-09-27T01:58:54.572+00:00" retrieveTime="2022-10-17T11:35:13.053450">

in this (photos from a camera mp4 video), we can see the animation is of equal distance

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024138098642276402" source="discord" createTime="2022-09-27T01:59:10.282+00:00" retrieveTime="2022-10-17T11:35:13.053450">

i.e. the arrow shifts the same distance in each frame

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024138216799997952" source="discord" createTime="2022-09-27T01:59:38.453+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If we have the wrong vsync info (or use something like DateTime.now), then we will see the distance not equal at all

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024140695809826857" source="discord" createTime="2022-09-27T02:09:29.495+00:00" retrieveTime="2022-10-17T11:35:13.053450">

how would the system be notified that it had changed?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024140751023648778" source="discord" createTime="2022-09-27T02:09:42.659+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Just no notification

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024140779943362630" source="discord" createTime="2022-09-27T02:09:49.554+00:00" retrieveTime="2022-10-17T11:35:13.053450">

preemptRender read it and it works well

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024140871387590716" source="discord" createTime="2022-09-27T02:10:11.356+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Indeed there cannot be notifications - because UI thread is fully busy and PostTask to UI thread will not work at all

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024141682377236500" source="discord" createTime="2022-09-27T02:13:24.711+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If I understand correctly, compiler explorer says this works well with zero overhead:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024141725024923688" source="discord" createTime="2022-09-27T02:13:34.879+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1024141724576137216/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024141736479567913" source="discord" createTime="2022-09-27T02:13:37.61+00:00" retrieveTime="2022-10-17T11:35:13.053450">

https://godbolt.org/z/bGoePGqYb

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024141907414224978" source="discord" createTime="2022-09-27T02:14:18.364+00:00" retrieveTime="2022-10-17T11:35:13.053450">

In the first example (with proposed Dart code), the heavyFunction is even not compiled into the binary. In the second example (just as a comparison), the heavyFunction is compiled and conditionally called.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024142009054789632" source="discord" createTime="2022-09-27T02:14:42.597+00:00" retrieveTime="2022-10-17T11:35:13.053450">

In other words, my proposed Dart writing seems to be (1) zero overhead (2) easily testable.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024147790177247292" source="discord" createTime="2022-09-27T02:37:40.924+00:00" retrieveTime="2022-10-17T11:35:13.053450">

For the RenderObject.layout thing

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024147810423148684" source="discord" createTime="2022-09-27T02:37:45.751+00:00" retrieveTime="2022-10-17T11:35:13.053450">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1024147810066636810/unknown.png)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024147823047999488" source="discord" createTime="2022-09-27T02:37:48.761+00:00" retrieveTime="2022-10-17T11:35:13.053450">

https://godbolt.org/z/r433E75Tx

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024148018682937395" source="discord" createTime="2022-09-27T02:38:35.404+00:00" retrieveTime="2022-10-17T11:35:13.053450">

1. I do see one extra function call (from RenderObject.layout to Renderer.layout)
2. If that is acceptable we are done; otherwise, we may enable it conditionally via zero-overhead flag just like mentioned above, then we have exactly zero cost

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112436" source="github" createTime="2022-09-27T03:32:04Z" retrieveTime="2022-10-17T11:46:00.817628">

### Exposing hook about tickers with zero overhead

This PR is a part for implementing the 60fps smooth rendering (#101227).

Some discussions can be seen in Discord, such as around https://discordapp.com/channels/608014603317936148/608021234516754444/1024141682377236500.

*List which issues are fixed by this PR. You must list at least one issue.*
https://github.com/flutter/flutter/issues/101227

*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*

P.S. Not sure what naming do you like, so just put a very long (temporary) variable name here :)

## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide], including [Features we expect every widget to implement].
- [x] I signed the [CLA].
- [x] I listed at least one issue that this PR fixes in the description above.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [x] I added new tests to check the change I am making, or this PR is [test-exempt].
- [x] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[test-exempt]: https://github.com/flutter/flutter/wiki/Tree-hygiene#tests
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[Features we expect every widget to implement]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#features-we-expect-every-widget-to-implement
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112437" source="github" createTime="2022-09-27T03:53:22Z" retrieveTime="2022-10-17T11:45:59.560551">

### Exposing hook for RenderObject.layout with zero overhead

**Remark:** This PR has less priority compared with the other two (https://github.com/flutter/engine/pull/36438, https://github.com/flutter/flutter/pull/112436), because this one can be workaround, while the other two are really mandatory to implement PreemptBuilder.

---

This PR is a part for implementing the 60fps smooth rendering (#101227).

Some discussions can be seen in Discord, such as around https://discordapp.com/channels/608014603317936148/608021234516754444/1024141682377236500.

*List which issues are fixed by this PR. You must list at least one issue.*
https://github.com/flutter/flutter/issues/101227

*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*

## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide], including [Features we expect every widget to implement].
- [x] I signed the [CLA].
- [x] I listed at least one issue that this PR fixes in the description above.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [x] I added new tests to check the change I am making, or this PR is [test-exempt].
- [x] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[test-exempt]: https://github.com/flutter/flutter/wiki/Tree-hygiene#tests
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[Features we expect every widget to implement]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#features-we-expect-every-widget-to-implement
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024167126942105601" source="discord" createTime="2022-09-27T03:54:31.168+00:00" retrieveTime="2022-10-17T11:35:13.053450">

P.S. Two PRs about the framework change is created: https://github.com/flutter/flutter/pull/112436

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024167172525789276" source="discord" createTime="2022-09-27T03:54:42.036+00:00" retrieveTime="2022-10-17T11:35:13.053450">

https://github.com/flutter/flutter/pull/112437

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-09-27T05:49:30Z" retrieveTime="2022-10-17T11:46:06.192837">

### Allow render to be called multiple times for one BeginFrame

This PR is a part for implementing the 60fps smooth rendering (#101227).

*List which issues are fixed by this PR. You must list at least one issue.*
https://github.com/flutter/flutter/issues/101227

*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*

The only change is an "if" as follows (all else are just tests)

![image](https://user-images.githubusercontent.com/5236035/192693744-86842381-384b-4a81-97b6-9988767a871e.png)


## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide] and the [C++, Objective-C, Java style guides].
- [x] I listed at least one issue that this PR fixes in the description above.
- [x] I added new tests to check the change I am making or feature I am adding, or Hixie said the PR is test-exempt. See [testing the engine] for instructions on
writing and running engine tests.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [x] I signed the [CLA].
- [x] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[C++, Objective-C, Java style guides]: https://github.com/flutter/engine/blob/main/CONTRIBUTING.md#style
[testing the engine]: https://github.com/flutter/flutter/wiki/Testing-the-engine
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat

By the way, the tests and code does work: If I comment out the code, the tests fail.

![image](https://user-images.githubusercontent.com/5236035/192442910-0fd05944-98b2-4272-9dc1-8c01308ab203.png)
![image](https://user-images.githubusercontent.com/5236035/192442965-c2fb185e-8fa3-4e67-8eec-a627dcbe3ffe.png)


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024196289883295774" source="discord" createTime="2022-09-27T05:50:24.155+00:00" retrieveTime="2022-10-17T11:35:13.053450">

... and https://github.com/flutter/engine/pull/36438

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgkxeeuk" source="google_doc_comments" createTime="2022-09-27T13:38:33.735Z" retrieveTime="2022-10-17T11:05:47.152504">

Ah sorry I did not see all your questions! I only see the last, and when viewing the second-last I see my avatar so wrongly think all things below have been answered...

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgkxeeuo" source="google_doc_comments" createTime="2022-09-27T13:39:08.205Z" retrieveTime="2022-10-17T11:05:47.152504">

We do not resume or retry. We just _call_ preemptRender function as any normal function call, and just _return_ from it. So zero cost.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAgkxeeus" source="google_doc_comments" createTime="2022-09-27T13:41:58.686Z" retrieveTime="2022-10-17T11:05:47.152504">

I have not done thorough experiments (e.g. ListView scrolling) so cannot give a conclusion now. But it seems this package will cover all cases with less drawbacks and better performance, by solving the problem in a different approach.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024316520681193533" source="discord" createTime="2022-09-27T13:48:09.411+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@gaaclarke I replied to all your questions now in google doc (Sorry I did not see all your questions this morning... I only see the last, and when viewing the second-last I see my reply there so wrongly think all things below have been answered)

</DiscussionComment>

<DiscussionComment author="Callum" link="https://discord.com/channels/608014603317936148/608021234516754444/1024342539043618926" source="discord" createTime="2022-09-27T15:31:32.672+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Any sliver expert: Is it expected to provide a custom `SliverChildDelegate` for good performance? Since with the default `SliverChildBuilderDelegate`, all the children will be rebuilt if the parent is rebuilt.

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://discord.com/channels/608014603317936148/608021234516754444/1024350872362307674" source="discord" createTime="2022-09-27T16:04:39.49+00:00" retrieveTime="2022-10-17T11:35:13.053450">

@Callum only the visible children, iirc, right?

</DiscussionComment>

<DiscussionComment author="Callum" link="https://discord.com/channels/608014603317936148/608021234516754444/1024374605038755942" source="discord" createTime="2022-09-27T17:38:57.801+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Yeah that's true. For reasons, I have both pages rebuild during page pop, so the frame drop was quite noticeable. Both lists didn't need to rebuild as no change in the content, it's a good feature that was not immediately obvious.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1024377142932414596" source="discord" createTime="2022-09-27T17:49:02.882+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I'd be really surprised if there is a significant framedrop from _just_ rebuilding widgets. Do you have some sample code I could look at? I've been looking at scrolling performance issues the last couple of weeks, usually what goes wrong is folks accidentally making the entire list render (even offscreen) and that can be quite slow

</DiscussionComment>

<DiscussionComment author="Callum" link="https://discord.com/channels/608014603317936148/608021234516754444/1024387703472672889" source="discord" createTime="2022-09-27T18:31:00.711+00:00" retrieveTime="2022-10-17T11:35:13.053450">

The list items are quite complex paragraphs, during scrolling it can be okay to have 1-2ms build times. But if 24 of them build at once (12 on each page) during the page pop, it's going to drop frames.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1024388172458754068" source="discord" createTime="2022-09-27T18:32:52.526+00:00" retrieveTime="2022-10-17T11:35:13.053450">

what sort of device are you running on?

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1024388955447230515" source="discord" createTime="2022-09-27T18:35:59.205+00:00" retrieveTime="2022-10-17T11:35:13.053450">

also, if its the same paragraph, the layout should be cached in the engine

</DiscussionComment>

<DiscussionComment author="Callum" link="https://discord.com/channels/608014603317936148/608021234516754444/1024402830196477972" source="discord" createTime="2022-09-27T19:31:07.203+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Just looked into it, my paragraphs aren't getting cached because of my use of WidgetSpan, unless it's the exact same Widget, the paragraph gets re-laid-out.

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1024405284246007818" source="discord" createTime="2022-09-27T19:40:52.294+00:00" retrieveTime="2022-10-17T11:35:13.053450">

oh, well that seems like a footgun

</DiscussionComment>

<DiscussionComment author="jonahwilliams" link="https://discord.com/channels/608014603317936148/608021234516754444/1024405328688857160" source="discord" createTime="2022-09-27T19:41:02.89+00:00" retrieveTime="2022-10-17T11:35:13.053450">

do you mind filling a bug on that? We should figure out how to make that work...

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024451329030103060" source="discord" createTime="2022-09-27T22:43:50.226+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Good morning/evening friends! Three (small) PRs are created yesterday, with tests and green CI: https://github.com/flutter/flutter/pull/112436, https://github.com/flutter/flutter/pull/112437, https://github.com/flutter/engine/pull/36438. May I get a little bit review 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-09-28T05:10:55Z" retrieveTime="2022-10-17T11:46:06.192837">

Not sure whether I should "@" some people here, maybe @dnfield @jonahwilliams @gaaclarke @flar engine experts?

May I get a code review, thanks :)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-09-28T05:43:21Z" retrieveTime="2022-10-17T11:46:06.192837">

@dnfield Hi, thanks for the quick reply :)

> The documentation on FlutterView.render specifies when it is safe/allowed to call render.

I will change that doc accordingly (probably after we come to a conclusion what should be done for this PR)

> I'm not quite clear on how this will affect the pipeline - it seems like it will now be trivial for a dart:ui application to flood the pipeline if we remove guardrails around when you can call render. Today the contract is that the application can expect that it's time to call render because it got a call to onBeginFrame. In this world, the application calls render whenever it thinks it has been working too long and might want to give an update. But the application doesn't know about vsync and it will be very hard to reason about why render is getting called if we make this change.
> I don't think we should make this change. It too easily allows wasted work to happen.

Firstly, IMHO, a normal flutter app calls `window.render` once per frame, so no problem at all for all existing app.

Secondly, in my proposal (`Preempt for 60 FPS`), I do observe vsync (using VsyncAwaiter class), and only submit one `window.render` per vsync. Therefore, "But the application doesn't know about vsync" seems not to be the situation, and thus "it will be very hard to reason about why render is getting called" is also no problem.

That said, I do agree that, if the rasterizer thread takes too long (e.g. takes 50ms for one rasterize), it is a waste to submit a Scene per 16.6ms (but should submit per 50ms).

If this is still a problem for you, can I change as follows: Add a flag to `window.render`, say, `window.render({bool onlyRenderOncePerBeginFrame = true})`. Then the behavior will be exactly the same, except for someone who really needs this (e.g. the Preempt proposal).

In addition, given it is a so low-level API that most people will never touch, it seems reasonable to provide some flexibility to it.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-09-28T10:06:35Z" retrieveTime="2022-10-17T11:46:06.192837">

@dnfield Another possibility for Dart code to understand the queue is full so it do not do anything more:

Add this 4-line function:

```c++
// return: whether it is prepared successfully. If return false, it means pipeline is full, 
// and thus the user should not really compute the Scene to avoid unnecessary work.
bool Animator::PrepareExtraRender() {
  if (!producer_continuation_) {
    producer_continuation_ = layer_tree_pipeline_->Produce();
  }
  return static_cast<bool>(producer_continuation_);
}
```

usage:

```dart
realize_next_vsync_comes; // see the design for details https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit
var prepared = window.prepareExtraRender();
if (prepared) {
  ui.Scene scene = compute_the_scene();
  window.render(scene);
} else {
  // do not do anything since the rasterizer queue is already so full
  // this mimic the behavior of Animator::BeginFrame, where we skip the current frame if it is full
}
```

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-09-28T10:15:48Z" retrieveTime="2022-10-17T11:46:06.192837">

> @dnfield ... be trivial for a dart:ui application to flood the pipeline ...

IMHO the pipeline seems not to be flooded - it has depth 2. In other words, even if we call `window.render(scene)` a million times within a frame, only the first two scenes will be in the queue, and the rest 999998 will just be thrown away (suppose rasterizer has not processed any). So we are still safe.

For a dart:ui application, if needed, it can use the `window.prepareExtraRender` extra call to see whether the queue is already full, to avoid generating scene etc (just like example above).

> Today the contract is that the application can expect that it's time to call render because it got a call to onBeginFrame. In this world, the application calls render whenever it thinks it has been working too long and might want to give an update.

Just as mentioned above, adding a flag like `window.render({bool onlyRenderOncePerBeginFrame = true})` seems to solve the "contract" problem.



</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-09-28T10:16:30Z" retrieveTime="2022-10-17T11:46:06.192837">

Oops sorry @chinmaygarde and @iskakaushik I just clicked the "Icons.refresh" on dnfield and do not know why github remove review requests to you...

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1024736265033224252" source="discord" createTime="2022-09-28T17:36:04.263+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Probably we can avoid it if we figure out the widget span has the same dimensions as last time... But If it won't or we can't figure it out the text layout may have changed.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1024736708530540697" source="discord" createTime="2022-09-28T17:37:50.001+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Reviews typically happen once per week during triage meetings. I've looked at some of these PRs already though and there seems to be some missing context here. These changes don't seem quite safe on their own, and it's still not clear to me what's the bigger picture app that they fix. I think we've talked about having a sample application or benchmark that shows what you're improving - is that available (even if it requires some special patches to the engine or framework to run, that's ok)

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1024736793758806026" source="discord" createTime="2022-09-28T17:38:10.321+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I'll say right now though that, in their current form and without extra support, these patches are unlikely to land anytime soon.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024819573729525821" source="discord" createTime="2022-09-28T23:07:06.604+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Hi, for sample app, with video + full code + brief code + benchmark + analysis, please have a look at https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit#, the new "Experiments" chapter

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112436" source="github" createTime="2022-09-28T23:10:08Z" retrieveTime="2022-10-17T11:46:00.817628">

Thanks, I did discussed with Hixie on discord and wrongly thought that public discussion was enough. I will fill all those contents in a few hours.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024820680866414622" source="discord" createTime="2022-09-28T23:11:30.566+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I will let it not be "in their current form" by providing extra support doc now 🙂 Will tell you when finished (probably in a few hours)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024822948286185502" source="discord" createTime="2022-09-28T23:20:31.161+00:00" retrieveTime="2022-10-17T11:35:13.053450">

By the way, those two PRs are the most important (i.e. package cannot exist without them), so if you are busy please ignore my other PRs currently

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAhGPCXpU" source="google_doc_comments" createTime="2022-09-28T23:21:09.174Z" retrieveTime="2022-10-17T11:05:47.152504">

Other things need time on this thread, for example GC.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAhGPCXpY" source="google_doc_comments" createTime="2022-09-28T23:21:57.199Z" retrieveTime="2022-10-17T11:05:47.152504">

I'm saying that a _single_ layout function might take too long and your preempt call will come too late.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAhGPCXpg" source="google_doc_comments" createTime="2022-09-28T23:27:19.384Z" retrieveTime="2022-10-17T11:05:47.152504">

https://github.com/fzyzcjy/flutter_smooth/blob/master/packages/smooth/example/lib/main.dart#L165 is a good chunk of the hard part. I'm not really clear from this document how that would automatically get inserted in meaningful places without breaking a lot of things.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1024824746661122080" source="discord" createTime="2022-09-28T23:27:39.927+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Added a couple more comments.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112436" source="github" createTime="2022-09-28T23:28:24Z" retrieveTime="2022-10-17T11:46:00.817628">

@dnfield 

**What is the big picture that it fixes?**

The ultimate goal is, let the app run smoothly at 60FPS, even if it has heavy subtree that is very slow to build/layout. In other words, the design doc: https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko

It already has a working demo. See the (new) "experiments" chapter, with a video, screenshots, full code, brief code, benchmark, analysis.

**What's the main goal you're trying to achieve with this particular change?**

In order to solve that big goal, we must let animation callbacks run at 60FPS even if the whole tree is very slow to build/layout. Otherwise, even if we refresh a subtree by 60FPS, anything like CircularProgressIndicator, FooTransition, or manual AnimationController will all never be smooth, because they do not see new timestamp at 60FPS.

Then, to fire (extra) animation callbacks, a natural solution is to work with the `Ticker`s. Originally, `Ticker`s are fired once per frame. But now, we also extra fire it (with proper timestamp) in each 60FPS smooth extra frame.

Lastly, to fire extra events to `Ticker`s , we must know the existence of Tickers in the auxiliary widget subtree (no need for Tickers in the main subtree since they should not be fired at 60FPS). That is why I added a callback when Tickers are created - then I can record it such that to fire extra ticks.

**Why is it doing it this way?**

Why it is a compile time flag `FLUTTER_ENABLE_TICKER_PROVIDER_STATE_MIXIN_CREATOR`: Because Hixie is worried about performance loss (in Discord hackers-framework). Making it a compile time flag, then nobody will have any even tiny bit of performance loss, if they do not need this feature.

Why there is `debugOverrideEnableTickerProviderStateMixinTickerCreator` in addition to compile time flag: Because Hixie said compile time flags are hard to test. By using this `debugOverride...` flag we can test it easily (indeed I have written tests there).

Why a context must be passed to the callback: Because as mentioned above, I need to determine whether it is in the second subtree or main subtree.

Btw the name is temporary, just suggest any name you like :)

**Why can't we used existing mechanisms to achieve the same thing?**

Well, Hixie and I have tried, but cannot come up with a solution :/ Feel free to suggest solutions! Microscopic speaking, seems that cannot know a Ticker in a TickerProviderMixin is created so cannot gather them. Macroscopic speaking, did not find other ways to let it be smooth.

**Why do we need this mechanism to achieve the larger goal of having incremental/progressive layout?**

Hope this question is clear with above ;)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024825022856056862" source="discord" createTime="2022-09-28T23:28:45.777+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Reply done to GitHub "hooks" PR: https://github.com/flutter/flutter/pull/112436#issuecomment-1261568241

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAhGPCXpo" source="google_doc_comments" createTime="2022-09-28T23:30:46.105Z" retrieveTime="2022-10-17T11:05:47.152504">

I agree theoretically. But during my experiments, I see about 39% of the UI thread time is idle, and I guess GC does not need that much time. This screenshot: https://user-images.githubusercontent.com/5236035/190553863-5a373dcb-75ba-468d-8118-66e7a393070b.png

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1024825576818749460" source="discord" createTime="2022-09-28T23:30:57.852+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I really appreciate your enthusiasm for this topic! But I'm still not sure I understand the big picture purpose of this method. You've explained some of the specifics about why you're guarding certain things the way you are, which isn't really what's unclear to me. What's unclear to me is why we want tickers to have an artificial way to fire an extra tick.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAhGPCXps" source="google_doc_comments" createTime="2022-09-28T23:31:54.998Z" retrieveTime="2022-10-17T11:05:47.152504">

Just add maybePreemptRender to that _single_ layout function. For example:

class VeryHeavySingleLayout extends RenderObject {
void performLayout() {
compute_heavy_things_part_1;
maybePreemptRender();
compute_heavy_things_part_2;
maybePreemptRender();
...
compute_heavy_things_part_5;
maybePreemptRender();
}
}

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1024825915466854430" source="discord" createTime="2022-09-28T23:32:18.592+00:00" retrieveTime="2022-10-17T11:35:13.053450">

This is related to the engine PR concerns - it seems like we're struggling a bit to find the right way to express the concept of vsync/animation frame. The platform gives us a very clear signal, and I would like to avoid adding methods to the engine or framework to override that.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAhGPCXp4" source="google_doc_comments" createTime="2022-09-28T23:34:25.287Z" retrieveTime="2022-10-17T11:05:47.152504">

1. Insert a maybePreemptRender to RenderObject.layout function seems enough, without breaking anything if I think correctly.
2. I also think about another possibility, just do it the way now it is. In other words, let the user manually specify preempt points via SmoothPreemptPoint. Then one less PR to framework, and user has more flexibility.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024828646084579400" source="discord" createTime="2022-09-28T23:43:09.622+00:00" retrieveTime="2022-10-17T11:35:13.053450">

> I really appreciate your enthusiasm for this topic! 
Thanks! 🙂
> What's unclear to me is why we want tickers to have an artificial way to fire an extra tick.
Because tickers originally fire once per full pipeline, in the animation phase. But now we want it to run extra ticks in the 60fps smooth extra frame. 
> it seems like we're struggling a bit to find the right way to express the concept of vsync/animation frame. 
I do respect vsync, just using a way other than "be fired by onBeginFrame" (because when we are busy running dart code, the callback can never be fired again). Shortly speaking, I let VsyncAwaiter set a thread-shared variable about the last vsync data. Then in maybePreemptRender, I read that data. (Briefly speaking) if it is a new vsync, I realize it is time to create Scene and submit via window.render. Thus I submit once per vsync and respect vsync well.
> The platform gives us a very clear signal, and I would like to avoid adding methods to the engine or framework to override that.
I would also like to make as few changes as possible, if it is possible 🙂
Not sure what "clear signal" mean, but if it means "the vsync signal", then hope my explanaions above solve the problem - I do respect the clear signal as well in another way

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024829143470321684" source="discord" createTime="2022-09-28T23:45:08.208+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Btw, I did not add replies to https://github.com/flutter/engine/pull/36438 today since yesterday already add some and some questions seem also overlap with today.

Feel free to ask if there is anything missing!

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAhGPEyA8" source="google_doc_comments" createTime="2022-09-28T23:45:08.783Z" retrieveTime="2022-10-17T11:05:47.152504">

In real applications under real workloads there is more need for GC time - for example, if your application is creating a lot of objects to understand data it fetched from the network or SQLite.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-09-28T23:57:11Z" retrieveTime="2022-10-17T11:46:06.192837">

If we are worried that users may submit multiple window.render inside one vsync, another possibility: We may add some code in the C++ layer (or Dart layer), such that we check current vsync status, and *only* `Produce()` if it is a new vsync that has not been produced before.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024832182117728307" source="discord" createTime="2022-09-28T23:57:12.678+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If we are worried that users may submit multiple window.render inside one vsync, another possibility: We may add some code in the C++ layer (or Dart layer), such that we check current vsync status, and *only* `Produce()` if it is a new vsync that has not been produced before.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1024832459453513820" source="discord" createTime="2022-09-28T23:58:18.8+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Which patch is updating a vsync ready signal for dart:ui or the framework?

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1024832480634748978" source="discord" createTime="2022-09-28T23:58:23.85+00:00" retrieveTime="2022-10-17T11:35:13.053450">

The patches I've seen so far don't seem to do that.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024832566861234226" source="discord" createTime="2022-09-28T23:58:44.408+00:00" retrieveTime="2022-10-17T11:35:13.053450">

No patch yet, because I was thinking to submit as few as possible

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024832620401528843" source="discord" createTime="2022-09-28T23:58:57.173+00:00" retrieveTime="2022-10-17T11:35:13.053450">

If you like it I can submit one, but that may not be tiny

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024832894507683943" source="discord" createTime="2022-09-29T00:00:02.525+00:00" retrieveTime="2022-10-17T11:35:13.053450">

Spoiler: It looks like https://github.com/fzyzcjy/engine/blob/c78138e3e79abfc771449a3a8341f7fc9211066f/shell/common/vsync_waiter.cc#L187

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024833062757998613" source="discord" createTime="2022-09-29T00:00:42.639+00:00" retrieveTime="2022-10-17T11:35:13.053450">

* Set a variable ("lastVsyncInfo") when VsyncAwaiter callback is fired
* Dart can read that variable

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024833534248091679" source="discord" createTime="2022-09-29T00:02:35.051+00:00" retrieveTime="2022-10-17T11:35:13.053450">

The current possibly hard part for that potential PR: in android sdk>=29 and ios, seems that the  callback of VsyncWaiter is fired on ui thread. But our Dart code is occupying the UI thread (for a long time) so that vsync callback may not be fired. For old android it does work well because it is fired in platform thread (my example is based on that)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024833652263243817" source="discord" createTime="2022-09-29T00:03:03.188+00:00" retrieveTime="2022-10-17T11:35:13.053450">

To create the PR, I may need to move new-android and ios VsyncWaiter to platform thread as well.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAhGPEyBY" source="google_doc_comments" createTime="2022-09-29T00:06:53.439Z" retrieveTime="2022-10-17T11:05:47.152504">

I agree. But seems that we need to compare two cases:
1. Without this new proposal: Suppose one frame is 100ms, then we have busy UI thread for 100ms without idle. And then frame ends so we have idle.
2. With this proposal: We still be busy for 100ms (+3% overhead so indeed 103ms), and then get idle. In addition, we have 6 extra smooth frames which may generate some object.

Thus, the difference with this proposal is that, the objects we create inside extra smooth frame do give GC extra pressure. But I hope that is small - they are just animations.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit?disco=AAAAhGPEyBc" source="google_doc_comments" createTime="2022-09-29T00:09:30.460Z" retrieveTime="2022-10-17T11:05:47.152504">

Moreover, IMHO, my approach allows GC to happen, as long as it is less than 16ms stop-the-world and is not very unlucky.

For example, suppose GC happens during 17ms to 20ms. Then I can still build the layer tree and submit window.render at around 33.33ms. That stop-the-world GC does not cause any problem like visible jank. As long as we have about 0.5ms per 16.667ms, because 0.5ms is what we need (in experiments below) to produce an extra smooth frame.

On the contrary, existing methods may have jank in such cases. Because if GC runs for 3ms, they have 3ms less to compute the next scene.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1024835407113883708" source="discord" createTime="2022-09-29T00:10:01.577+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I'm not suggesting you create that PR right now, but having a working patch that shows what would need to be done, with some details about why this approach is being taken would help.

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://discord.com/channels/608014603317936148/608021234516754444/1024835469546106950" source="discord" createTime="2022-09-29T00:10:16.462+00:00" retrieveTime="2022-10-17T11:35:13.053450">

For example, I'd expect your document to have a section on this explaining how it will work and what threading considerations are being made etc.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024840166189309965" source="discord" createTime="2022-09-29T00:28:56.229+00:00" retrieveTime="2022-10-17T11:35:13.053450">

I see. I will add that (probably within a few hours) and come back when I am done.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1024852804029927537" source="discord" createTime="2022-09-29T01:19:09.325+00:00" retrieveTime="2022-10-17T11:35:13.053450">

That section is now written under "Get last vsync time information" doc section, with psuedo-code, threading concerns etc
I will make a runnable code if the proposal about this vsync change looks interesting

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-09-29T02:44:43Z" retrieveTime="2022-10-17T11:45:58.248267">

### `AutomatedTestWidgetsFlutterBinding.pump` provides wrong pump time stamp, probably because of forgetting the precision

The fix is just one line:

![image](https://user-images.githubusercontent.com/5236035/192926480-dc287d01-62bb-4dc8-9c16-f62f6d03b0da.png)

I have `git blame` and find the bug exist since the first version 7yr ago, and no special comments about why this is introduced so I guess it is but not feature.

IMHO the bug may be written like, the programmer wants to convert DateTime (the `clock.now()`) into a Duration. But then it is forgotten that both are microseconds precision instead of milliseconds precision, and the milliseconds approach is used.

*List which issues are fixed by this PR. You must list at least one issue.*
Close #112610

*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*

## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide], including [Features we expect every widget to implement].
- [x] I signed the [CLA].
- [x] I listed at least one issue that this PR fixes in the description above.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [x] I added new tests to check the change I am making, or this PR is [test-exempt].
- [x] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[test-exempt]: https://github.com/flutter/flutter/wiki/Tree-hygiene#tests
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[Features we expect every widget to implement]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#features-we-expect-every-widget-to-implement
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat

---

p.s. test fails with old code, confirming that the test is effective.

![image](https://user-images.githubusercontent.com/5236035/192926239-e83874e6-6dc0-4265-a4d5-dda0c9018bf8.png)
![image](https://user-images.githubusercontent.com/5236035/192926266-e202747f-9e1a-49a2-abf2-a9624bd2c03d.png)


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112619" source="github" createTime="2022-09-29T06:21:11Z" retrieveTime="2022-10-17T11:45:56.806946">

### Export `elapseBlocking` to test binding, so slow sync work can be simulated such as a slow widget build

There are needs to simulate sync heavy work, such as a slow widget build, in flutter widget tests. This method simply expose that.

As a remark, this cannot be replaced by `runAsync`. Consider the following example:

```dart
    testWidgets('can use to simulate slow build', (WidgetTester tester) async {
      final DateTime beforeTime = binding.clock.now();

      await tester.pumpWidget(Builder(builder: (_) {
        bool timerCalled = false;
        Timer.run(() => timerCalled = true);

        binding.elapseBlocking(const Duration(seconds: 1));

        // if we use `delayed` instead of `elapseBlocking`, such as
        // binding.delayed(const Duration(seconds: 1));
        // the timer will be called here. Surely, that violates how
        // a flutter widget build works
        expect(timerCalled, false);

        return Container();
      }));

      expect(binding.clock.now(), beforeTime.add(const Duration(seconds: 1)));
      binding.idle();
    });
```

As is discussed in the comments in the example, if we use `delayed`, timers will be fired when executing half of a build function, which is totally wrong.

*List which issues are fixed by this PR. You must list at least one issue.*
Close https://github.com/flutter/flutter/issues/112620

*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*

## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide], including [Features we expect every widget to implement].
- [x] I signed the [CLA].
- [x] I listed at least one issue that this PR fixes in the description above.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [x] I added new tests to check the change I am making, or this PR is [test-exempt].
- [x] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[test-exempt]: https://github.com/flutter/flutter/wiki/Tree-hygiene#tests
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[Features we expect every widget to implement]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#features-we-expect-every-widget-to-implement
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat


</DiscussionComment>

<DiscussionComment author="dnfield" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-09-30T18:11:41Z" retrieveTime="2022-10-17T11:46:06.192837">

Fizzling like that would be expensive, and we'd be giving developers a button to push that actually makes things slower. We should avoid that.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-09-30T22:42:21Z" retrieveTime="2022-10-17T11:46:06.192837">

@dnfield If speed is a concern, maybe the original PR is ok: For a normal usage, it only adds `if (!producer_continuation_)` (and that if will return false immediately). Given that `explicit operator bool() const { return continuation_ != nullptr; }`, this if will only check whether a pointer is nullptr, so I guess it is only a few CPU cycles (per 16667 microseconds, i.e. maybe 10000000 cycles). In addition, for a normal usage, the branch will always be false, so IMHO the cpu branch predictor will be quite correct about the prediction.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-09-30T22:51:53Z" retrieveTime="2022-10-17T11:46:06.192837">

> @dnfield giving developers a button to push that actually makes things slower

There seems to be another way that is not very slower:

Firstly, the `onlyRenderOncePerBeginFrame` should not be `window.render(onlyRenderOncePerBeginFrame: true)`, but be `window.onlyRenderOncePerBeginFrame = true; window.render()`. In other words, it should be a flag that is set once. Then the code is:

```c++
...
  if (!onlyRenderOncePerBeginFrame && !producer_continuation_) {
    producer_continuation_ = layer_tree_pipeline_->Produce();
  }
...

void SetOnlyRenderOncePerBeginFrame(bool value) { this->onlyRenderOncePerBeginFrame = value; }
class Animator { ... bool onlyRenderOncePerBeginFrame; ... }
```

(no need for locks, since all on UI thread.)

Then there comes the concern that `if (!onlyRenderOncePerBeginFrame && !producer_continuation_)` can cost CPU cycles, even when onlyRenderOncePerBeginFrame is always true (for a classical user). Firstly, for a classical user, we only pay extra cost of `if(boolean)` (because && is short-circuited), so only a few cycles.

Secondly, seems we can use the `[[likely]]` (c++20), or `LIKELY` (a lot of c++ library write their own version for that, e.g. see [how linux])(https://stackoverflow.com/questions/109710/how-do-the-likely-unlikely-macros-in-the-linux-kernel-work-and-what-is-their-ben) does that), to further hint compiler about this case to speed up.



</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-09-30T22:55:53Z" retrieveTime="2022-10-17T11:46:06.192837">

@dnfield And for *zero* speed decrease if you like:

The `Animator::PrepareExtraRender` proposal seems to cause zero speed loss for a classical user. Because a classical user never calls that function, and only call Animator::Render. But Animator::Render is not modified in this proposal. For a smooth user, there does exist overhead, because need to call one extra C++ function - the PrepareExtraRender.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-09-30T23:01:48Z" retrieveTime="2022-10-17T11:45:49.046468">

Quick update (still WIP, just provide some progress): I am working on the gesture system. Jonah Williams has thought that, it was bad that my old proposal did not let the pointer data packet go through Flutter's gesture system. Now, the new method just calls the classical `gestureBinding.handlePointerEvent` to dispatch `PointerMoveEvent`s.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112735" source="github" createTime="2022-10-01T01:18:23Z" retrieveTime="2022-10-17T11:45:55.629074">

### Fix logic error in `markNeedsPaint`

[wait a minute when I write down comments...]

The original code comment says:

> If we're the root of the render tree (probably a RenderView), then we have to paint ourselves, since nobody else can paint us. We don't add ourselves to _nodesNeedingPaint in this case, because the root is always told to paint regardless.

However, IMHO it is wrong in two aspects.

### Problem 1: RenderView does not come to this branch

Firstly, for a `RenderView`, it will not go into this branch, but instead go into the first branch (the `if (isRepaintBoundary && _wasRepaintBoundary)`). This is because RenderView.isRepaintBoundary is defined to be true, which can be seen in the code.

The experiment also confirms this. Click to expand below:

<details>

Add a few logs:

![image](https://user-images.githubusercontent.com/5236035/193377612-be3ab525-2819-401f-b68e-25c318e40dd8.png)

Code:

```
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  testWidgets('hello', (tester) async {
    debugPrintBeginFrameBanner = debugPrintEndFrameBanner = true;

    final dummy = ValueNotifier(0);
    await tester.pumpWidget(ValueListenableBuilder(
      valueListenable: dummy,
      builder: (_, dummy, __) => _DummyInner(dummy: dummy),
    ));

    dummy.value++;
    await tester.pump();

    debugPrintBeginFrameBanner = debugPrintEndFrameBanner = false;
  });
}

class _DummyInner extends SingleChildRenderObjectWidget {
  final int dummy;

  const _DummyInner({
    super.key,
    required this.dummy,
    super.child,
  });

  @override
  _RenderDummy createRenderObject(BuildContext context) =>
      _RenderDummy(dummy: dummy);

  @override
  void updateRenderObject(BuildContext context, _RenderDummy renderObject) {
    renderObject.dummy = dummy;
  }
}

class _RenderDummy extends RenderProxyBox {
  _RenderDummy({
    required int dummy,
    RenderBox? child,
  })  : _dummy = dummy,
        super(child);

  // not mark repaint yet
  int get dummy => _dummy;
  int _dummy;

  set dummy(int value) {
    if (_dummy == value) return;
    _dummy = value;
    print('hi ${describeIdentity(this)} set dummy thus markNeedsPaint START');
    markNeedsPaint();
    print('hi ${describeIdentity(this)} set dummy thus markNeedsPaint END');
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    print('hi ${describeIdentity(this)}.paint SUPPOSE THIS IS THE REAL PAINT');
    super.paint(context, offset);
  }
}
```

output

```
/Volumes/MyExternal/ExternalRefCode/flutter/bin/flutter --no-color test --machine --start-paused --plain-name hello --local-engine-src-path=/Volumes/MyExternal/ExternalRefCode/engine/src --local-engine=host_debug_unopt test/hello.dart
Testing started at 09:21 ...

hi RenderParagraph#d9227.markNeedsPaint start _needsPaint=true
hi RenderPositionedBox#d9bb5.markNeedsPaint start _needsPaint=true
hi RenderView#fab3a.markNeedsPaint start _needsPaint=true
hi flushPaint PipelineOwner#89028 node=RenderView#fab3a NEEDS-PAINT _needsPaint=true owner=PipelineOwner#89028 node._layerHandle.layer!.attached=true
hi TransformLayer#64092.buildScene
hi PictureLayer#149d1._addToSceneWithRetainedRendering _needsAddToScene=true
▄▄▄▄▄▄▄▄ Frame 2                        0ms ▄▄▄▄▄▄▄▄
hi _RenderDummy#a17bc.markNeedsPaint start _needsPaint=true
hi RenderView#fab3a.markNeedsPaint start _needsPaint=false
hi RenderView#fab3a.markNeedsPaint case-repaintboundary owner=PipelineOwner#89028
hi flushPaint PipelineOwner#89028 node=RenderView#fab3a NEEDS-PAINT _needsPaint=true owner=PipelineOwner#89028 node._layerHandle.layer!.attached=true
hi _RenderDummy#a17bc.paint SUPPOSE THIS IS THE REAL PAINT
hi TransformLayer#64092.buildScene
▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
▄▄▄▄▄▄▄▄ Frame 3                        0ms ▄▄▄▄▄▄▄▄
hi _RenderDummy#a17bc set dummy thus markNeedsPaint START
hi _RenderDummy#a17bc.markNeedsPaint start _needsPaint=false
hi _RenderDummy#a17bc.markNeedsPaint case-parent parent=RenderView#fab3a
hi RenderView#fab3a.markNeedsPaint start _needsPaint=false
hi RenderView#fab3a.markNeedsPaint case-repaintboundary owner=PipelineOwner#89028
hi _RenderDummy#a17bc set dummy thus markNeedsPaint END
hi flushPaint PipelineOwner#89028 node=RenderView#fab3a NEEDS-PAINT _needsPaint=true owner=PipelineOwner#89028 node._layerHandle.layer!.attached=true
hi _RenderDummy#a17bc.paint SUPPOSE THIS IS THE REAL PAINT
hi TransformLayer#64092.buildScene
▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
hi RenderParagraph#c63b7.markNeedsPaint start _needsPaint=true
hi RenderPositionedBox#2fb99.markNeedsPaint start _needsPaint=true
hi RenderView#fab3a.markNeedsPaint start _needsPaint=false
hi RenderView#fab3a.markNeedsPaint case-repaintboundary owner=PipelineOwner#89028
hi flushPaint PipelineOwner#89028 node=RenderView#fab3a NEEDS-PAINT _needsPaint=true owner=PipelineOwner#89028 node._layerHandle.layer!.attached=true
hi TransformLayer#64092.buildScene
hi PictureLayer#18f7f._addToSceneWithRetainedRendering _needsAddToScene=true
```

</details>

By looking at the experiment above, we see that, the `RenderView` goes to the `case-repaintboundary` which is the first branch, instead of the third branch, so the comments seem incorrect.

### Problem 2: Root is not always told to paint indeed

Theoretically, I do not find clues why "root is always told to paint" indeed. Experimentically, this is also confirmed as below.

We change the branching condition as follows, so RenderView is forced to go to the 3rd branch (the branch with comments), instead of the 1st branch.

```diff
-     if (isRepaintBoundary && _wasRepaintBoundary) {
+     if (isRepaintBoundary && _wasRepaintBoundary && /*HACK!!!*/(this is! RenderView)) {
```

Then we run the test code same as above (only with a few more logging), and get:

<details>

```
/Volumes/MyExternal/ExternalRefCode/flutter/bin/flutter --no-color test --machine --start-paused --plain-name hello --local-engine-src-path=/Volumes/MyExternal/ExternalRefCode/engine/src --local-engine=host_debug_unopt test/hello.dart
Testing started at 09:25 ...

hi RenderParagraph#c9872.markNeedsPaint start _needsPaint=true
hi RenderPositionedBox#f6896.markNeedsPaint start _needsPaint=true
hi RenderView#0fb85.markNeedsPaint start _needsPaint=true
hi flushPaint PipelineOwner#ce901 node=RenderView#0fb85 NEEDS-PAINT _needsPaint=true owner=PipelineOwner#ce901 node._layerHandle.layer!.attached=true
hi RenderView#0fb85.paint
hi TransformLayer#d7668.buildScene
hi PictureLayer#335b7._addToSceneWithRetainedRendering _needsAddToScene=true
▄▄▄▄▄▄▄▄ Frame 2                        0ms ▄▄▄▄▄▄▄▄
hi _RenderDummy#3427b.markNeedsPaint start _needsPaint=true
hi RenderView#0fb85.markNeedsPaint start _needsPaint=false
hi RenderView#0fb85.markNeedsPaint case-else owner=PipelineOwner#ce901
hi TransformLayer#d7668.buildScene
hi PictureLayer#335b7._addToSceneWithRetainedRendering _needsAddToScene=false
▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
▄▄▄▄▄▄▄▄ Frame 3                        0ms ▄▄▄▄▄▄▄▄
hi _RenderDummy#3427b set dummy thus markNeedsPaint START
hi _RenderDummy#3427b.markNeedsPaint start _needsPaint=true
hi _RenderDummy#3427b set dummy thus markNeedsPaint END
hi TransformLayer#d7668.buildScene
hi PictureLayer#335b7._addToSceneWithRetainedRendering _needsAddToScene=false
▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
hi RenderParagraph#66d6b.markNeedsPaint start _needsPaint=true
hi RenderPositionedBox#537a5.markNeedsPaint start _needsPaint=true
hi RenderView#0fb85.markNeedsPaint start _needsPaint=true
hi TransformLayer#d7668.buildScene
hi PictureLayer#335b7._addToSceneWithRetainedRendering _needsAddToScene=false
```

</details>

As we can see, RenderView.paint and RenderDummy.paint is only called once, even though we clearly call `RenderDummy.markNeedsPaint`. That is indeed a bug, and at least shows that the code comment is wrong - root is not always told to paint.

---

*Replace this paragraph with a description of what this PR is changing or adding, and why. Consider including before/after screenshots.*

*List which issues are fixed by this PR. You must list at least one issue.*
close #112736

*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*

## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide], including [Features we expect every widget to implement].
- [x] I signed the [CLA].
- [x] I listed at least one issue that this PR fixes in the description above.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [x] I added new tests to check the change I am making, or this PR is [test-exempt].
- [x] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[test-exempt]: https://github.com/flutter/flutter/wiki/Tree-hygiene#tests
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[Features we expect every widget to implement]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#features-we-expect-every-widget-to-implement
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112738" source="github" createTime="2022-10-01T02:05:20Z" retrieveTime="2022-10-17T11:45:54.448723">

### [WIP] [Do not merge this PR] Tentative experiment to see how to fix logic error about skippedPaintingOnLayer

*Replace this paragraph with a description of what this PR is changing or adding, and why. Consider including before/after screenshots.*

*List which issues are fixed by this PR. You must list at least one issue.*

*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*

## Pre-launch Checklist

- [ ] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [ ] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [ ] I read and followed the [Flutter Style Guide], including [Features we expect every widget to implement].
- [ ] I signed the [CLA].
- [ ] I listed at least one issue that this PR fixes in the description above.
- [ ] I updated/added relevant documentation (doc comments with `///`).
- [ ] I added new tests to check the change I am making, or this PR is [test-exempt].
- [ ] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[test-exempt]: https://github.com/flutter/flutter/wiki/Tree-hygiene#tests
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[Features we expect every widget to implement]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#features-we-expect-every-widget-to-implement
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112738" source="github" createTime="2022-10-01T02:21:09Z" retrieveTime="2022-10-17T11:45:54.448723">

All right, this should not be the fix

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112757" source="github" createTime="2022-10-02T01:11:34Z" retrieveTime="2022-10-17T11:45:53.143231">

### Add warning that `RenderRepaintBoundary.toImage` and `OffsetLayer.toImage` is slow

Scene.toImage has doc saying: "This is a slow operation that is performed on a background thread". However, people may use `RenderRepaintBoundary.toImage` and `OffsetLayer.toImage` and never read that comment, so they are unaware of the slowness. This PR simply adds the warning to them.

*List which issues are fixed by this PR. You must list at least one issue.*

*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*

## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide], including [Features we expect every widget to implement].
- [x] I signed the [CLA].
- [x] I listed at least one issue that this PR fixes in the description above.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [x] I added new tests to check the change I am making, or this PR is [test-exempt].
- [ ] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[test-exempt]: https://github.com/flutter/flutter/wiki/Tree-hygiene#tests
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[Features we expect every widget to implement]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#features-we-expect-every-widget-to-implement
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36556" source="github" createTime="2022-10-02T01:33:27Z" retrieveTime="2022-10-17T11:46:04.616331">

### Update comments that seem to contradict the code and may confuse the reader

Original comment:

> ... So we flatten the layer tree into a picture and use that as the thread transport mechanism.

However, looking at the whole code:

<details>

```c++
Dart_Handle Picture::RasterizeToImage(sk_sp<DisplayList> display_list,
                                      std::shared_ptr<LayerTree> layer_tree,
                                      uint32_t width,
                                      uint32_t height,
                                      Dart_Handle raw_image_callback) {
  if (Dart_IsNull(raw_image_callback) || !Dart_IsClosure(raw_image_callback)) {
    return tonic::ToDart("Image callback was invalid");
  }

  if (width == 0 || height == 0) {
    return tonic::ToDart("Image dimensions for scene were invalid.");
  }

  auto* dart_state = UIDartState::Current();
  auto image_callback = std::make_unique<tonic::DartPersistentValue>(
      dart_state, raw_image_callback);
  auto unref_queue = dart_state->GetSkiaUnrefQueue();
  auto ui_task_runner = dart_state->GetTaskRunners().GetUITaskRunner();
  auto raster_task_runner = dart_state->GetTaskRunners().GetRasterTaskRunner();
  auto snapshot_delegate = dart_state->GetSnapshotDelegate();

  // We can't create an image on this task runner because we don't have a
  // graphics context. Even if we did, it would be slow anyway. Also, this
  // thread owns the sole reference to the layer tree. So we flatten the layer
  // tree into a picture and use that as the thread transport mechanism.

  auto picture_bounds = SkISize::Make(width, height);

  auto ui_task =
      // The static leak checker gets confused by the use of fml::MakeCopyable.
      // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)
      fml::MakeCopyable([image_callback = std::move(image_callback),
                         unref_queue](sk_sp<DlImage> image) mutable {
        auto dart_state = image_callback->dart_state().lock();
        if (!dart_state) {
          // The root isolate could have died in the meantime.
          return;
        }
        tonic::DartState::Scope scope(dart_state);

        if (!image) {
          tonic::DartInvoke(image_callback->Get(), {Dart_Null()});
          return;
        }

        if (image->skia_image()) {
          image =
              DlImageGPU::Make({image->skia_image(), std::move(unref_queue)});
        }

        auto dart_image = CanvasImage::Create();
        dart_image->set_image(image);
        auto* raw_dart_image = tonic::ToDart(std::move(dart_image));

        // All done!
        tonic::DartInvoke(image_callback->Get(), {raw_dart_image});

        // image_callback is associated with the Dart isolate and must be
        // deleted on the UI thread.
        image_callback.reset();
      });

  // Kick things off on the raster rask runner.
  fml::TaskRunner::RunNowOrPostTask(
      raster_task_runner,
      [ui_task_runner, snapshot_delegate, display_list, picture_bounds, ui_task,
       layer_tree = std::move(layer_tree)] {
        sk_sp<DlImage> image;
        if (layer_tree) {
          auto display_list = layer_tree->Flatten(
              SkRect::MakeWH(picture_bounds.width(), picture_bounds.height()),
              snapshot_delegate->GetTextureRegistry(),
              snapshot_delegate->GetGrContext());

          image = snapshot_delegate->MakeRasterSnapshot(display_list,
                                                        picture_bounds);
        } else {
          image = snapshot_delegate->MakeRasterSnapshot(display_list,
                                                        picture_bounds);
        }

        fml::TaskRunner::RunNowOrPostTask(
            ui_task_runner, [ui_task, image]() { ui_task(image); });
      });

  return Dart_Null();
}
```

</details>

It seems that, the `layer_tree` is directly moved into `raster_task_runner` callbacks. Then, inside the raster thread, `layer_tree->Flatten` is called and it is converted to a DisplayList. In other words, the "thread transport mechanism" seems to be the `layer_tree` (ui -> raster thread) and `DlImage` (raster -> ui thread), instead of the "flatten the layer tree into a picture and use that" (the flattened layer tree, i.e. the picture).

*List which issues are fixed by this PR. You must list at least one issue.*

*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*

## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide] and the [C++, Objective-C, Java style guides].
- [ ] I listed at least one issue that this PR fixes in the description above.
- [x] I added new tests to check the change I am making or feature I am adding, or Hixie said the PR is test-exempt. See [testing the engine] for instructions on
writing and running engine tests.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [x] I signed the [CLA].
- [ ] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[C++, Objective-C, Java style guides]: https://github.com/flutter/engine/blob/main/CONTRIBUTING.md#style
[testing the engine]: https://github.com/flutter/flutter/wiki/Testing-the-engine
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat


</DiscussionComment>

<DiscussionComment author="flutter-dashboard" link="https://github.com/flutter/engine/issues/36556" source="github" createTime="2022-10-02T01:33:30Z" retrieveTime="2022-10-17T11:46:04.616331">

It looks like this pull request may not have tests. Please make sure to add tests before merging. If you need [an exemption](https://github.com/flutter/flutter/wiki/Tree-hygiene#tests) to this rule, contact Hixie on the #hackers channel in [Chat](https://github.com/flutter/flutter/wiki/Chat) (don't just cc him here, he won't see it! *He's on Discord!*).

If you are not sure if you need tests, consider this rule of thumb: the purpose of a test is to make sure someone doesn't accidentally revert the fix. Ask yourself, **is there anything in your PR that you feel it is important we not accidentally revert back to how it was before your fix?**

__Reviewers__: Read the [Tree Hygiene page](https://github.com/flutter/flutter/wiki/Tree-hygiene#how-to-review-code) and make sure this patch meets those guidelines before LGTMing.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36556" source="github" createTime="2022-10-02T01:34:31Z" retrieveTime="2022-10-17T11:46:04.616331">

This only updates comments so seems no need for tests

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112757" source="github" createTime="2022-10-02T01:46:48Z" retrieveTime="2022-10-17T11:45:53.143231">

@jonahwilliams Hi thanks for the reply.

* If it is slow, IMHO the users need to know it, otherwise users may abuse it because they may think it is just a normal function.
* If it is fast, then we need to remove the original comment (because it is outdated).
* As for impl specific, if it is slow but in the future it becomes fast (hopefully!), seems that we can update comments at that time.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112757" source="github" createTime="2022-10-02T01:50:25Z" retrieveTime="2022-10-17T11:45:53.143231">

Anyway this is just a small doc change and it does not matter whether it is changed or not for myself (since I already know it is slow and should be careful). I have spent some making this PR simply because I hope other users works correctly with the api :)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112778" source="github" createTime="2022-10-03T03:53:35Z" retrieveTime="2022-10-17T11:45:51.858561">

### Minor change type nullability

*Replace this paragraph with a description of what this PR is changing or adding, and why. Consider including before/after screenshots.*

*List which issues are fixed by this PR. You must list at least one issue.*

*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*

## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide], including [Features we expect every widget to implement].
- [x] I signed the [CLA].
- [ ] I listed at least one issue that this PR fixes in the description above.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [ ] I added new tests to check the change I am making, or this PR is [test-exempt].
- [ ] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[test-exempt]: https://github.com/flutter/flutter/wiki/Tree-hygiene#tests
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[Features we expect every widget to implement]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#features-we-expect-every-widget-to-implement
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat


</DiscussionComment>

<DiscussionComment author="dnfield" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-10-03T16:24:41Z" retrieveTime="2022-10-17T11:46:06.192837">

You're discounting the time it takes to actually make a native call from Dart.

On top of that, we should not expose an API that might or might not do something and developers have no good way to reason about whether they're really supposed to call it or not.

This proposal is fundamentally changing the invariants around `render`/`onBeginFrame`, but it's not providing any way for developers to know if they're using the new invariants correctly or not. Even if the new potentially useless API is relatively cheap, it adds up when developers (and packages they use) start doing it multiple times per frame. And those developers/packages will have no way to know whether they're doing it correctly or not, so it will definitely get misused.

Why, for example, shouldn't the framework just call render and schedule a new frame when its hit its potential limit?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-10-03T23:26:28Z" retrieveTime="2022-10-17T11:46:06.192837">

@dnfield Hi thanks for the reply.

> You're discounting the time it takes to actually make a native call from Dart.

Originally I thought that is small just like a normal function call... Ok now I learn it.

> On top of that, we should not expose an API that might or might not do something and developers have no good way to reason about whether they're really supposed to call it or not.

Indeed they have a way to reason: look at time or vsync info. They should not submit twice inside one vsync interval.

> This proposal is fundamentally changing the invariants around render/onBeginFrame, but it's not providing any way for developers to know if they're using the new invariants correctly or not.

I am not sure, if I expose the vsync info and ensure only one call is made per vsync interval (16.67ms), does this satisfy your requirement?

> Even if the new potentially useless API is relatively cheap, it adds up when developers (and packages they use) start doing it multiple times per frame. 

Again, as mentioned above, dev should not call it multiple times per frame. A naive dev may use `DateTime.now() - last_vsync_time > 15ms` etc to check, and a more sophisticated way may be read the vsync info (exposed from engine) to really ensure we never call twice per vsync interval. 

> And those developers/packages will have no way to know whether they're doing it correctly or not, so it will definitely get misused.

Then maybe we should return `bool` to indicate whether it is really scheduled. If they see a lot of `false` they are doing it wrong (call too many times that are useless).

> Why, for example, shouldn't the framework just call render and schedule a new frame when its hit its potential limit?

Because of the fundamental design of the preempt proposal (https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit), mainly "The flow chart" section.

Indeed, window.render is called per vsync interval (16.67ms). The main difference from classical code is that, it may be called multiple times per onBeginFrame (when onBeginFrame is super slow).

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-10-03T23:52:26Z" retrieveTime="2022-10-17T11:46:06.192837">

Devices do not always have 60fps vsync - sometimes it's 90 or 120 or more or less (at one point we had a customer looking at 240hz devices, and it's likely there are customers out there looking at 30hz use cases). There is no way currently in dart:ui to know what the current refresh rate is, and on some platforms it's not even possible to implement because the vendors don't provide an API for it (e.g. some Android vendors), and it can change from frame to frame.

In other words, a developer must not assume that 16.67ms is the right interval for a frame in all circumstances. And the query of `DateTime.now` is almost certain to _not_ match the actual vsync start time, so if you assume you have roughly 16ms from onBeginFrame you might actually overshoot vsync.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-10-03T23:57:18Z" retrieveTime="2022-10-17T11:46:06.192837">

> Devices do not always have 60fps vsync - sometimes it's 90 or 120 or more or less (at one point we had a customer looking at 240hz devices, and it's likely there are customers out there looking at 30hz use cases). There is no way currently in dart:ui to know what the current refresh rate is, and on some platforms it's not even possible to implement because the vendors don't provide an API for it (e.g. some Android vendors), and it can change from frame to frame.

Definitely! That's why I also propose to expose vsync-related information to the dev. Last week you asked me to describe it and it was at "Get last vsync time information" section of google doc.

> And the query of DateTime.now is almost certain to not match the actual vsync start time, so if you assume you have roughly 16ms from onBeginFrame you might actually overshoot vsync.

Totally agree. Indeed in my (previous) implementation, I let the C++ side expose the `timeStamp` (i.e. vsync target time we provide to dart tonBeginFrame) both a "Duration" and a "DateTime-compatible time". If you like I can add that back (deleted it b/c want to make PR small).

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-10-03T23:58:56Z" retrieveTime="2022-10-17T11:46:06.192837">

P.S. I am also considering relaxing when to start a onBeginFrame which seems to reduce unnecessary idle time and improve performance. That may be related to the big picture you are concerned - how vsync and code are interacted. I will add it to design doc and reply here maybe in an hour.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-10-04T00:34:41Z" retrieveTime="2022-10-17T11:46:06.192837">

@dnfield Here it goes: "Relax onBeginFrame starting criterion" section in https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit

</DiscussionComment>

<DiscussionComment author="dnfield" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-10-04T16:23:59Z" retrieveTime="2022-10-17T11:46:06.192837">

I think it would be easier to start with a patch that exposes more about vsync timings to the developer, because that will be critical to whether this one makes sense.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-10-04T23:05:16Z" retrieveTime="2022-10-17T11:46:06.192837">

Thanks, I will do that.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36607" source="github" createTime="2022-10-05T00:07:09Z" retrieveTime="2022-10-17T11:46:03.344849">

### Expose `vsync` information to developer

This PR tries to expose vsync information to the developer, so they can know when it is proper to call the more un-restricted `window.render` proposed in #36438.

Currently only the API is shown, because IMHO the implementation details is unrelated to thoughts about #36438, and the API (and therefore implementations) are subject to changes. I will continue working on it, once the API is approved.

For detailed design about this API and its implementation, please have a look at "Get last vsync time information" section of https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit.

Sample usage:

```dart
final info = SchedulerBinding.instance.lastVsyncInfo();
```

List of work:

- [x] code the (draft) Dart API
- [ ] discuss whether the API is acceptable
- [ ] implement the C++ part on SDK<=29 Android
- [ ] implement the C++ part on new android, ios, and other platforms
- [ ] create a wrapper function in `flutter/flutter` repo, probably in `SchedulerBinding`

*List which issues are fixed by this PR. You must list at least one issue.*

*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*

## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide] and the [C++, Objective-C, Java style guides].
- [ ] I listed at least one issue that this PR fixes in the description above.
- [ ] I added new tests to check the change I am making or feature I am adding, or Hixie said the PR is test-exempt. See [testing the engine] for instructions on
writing and running engine tests.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [x] I signed the [CLA].
- [ ] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[C++, Objective-C, Java style guides]: https://github.com/flutter/engine/blob/main/CONTRIBUTING.md#style
[testing the engine]: https://github.com/flutter/flutter/wiki/Testing-the-engine
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36438" source="github" createTime="2022-10-05T00:16:04Z" retrieveTime="2022-10-17T11:46:06.192837">

@dnfield Hi, PR is here: https://github.com/flutter/engine/pull/36607

Only the API is there currently, because IMHO the implementation details is unrelated to thoughts about this issue, and the API (and therefore implementations) are subject to changes.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-06T00:16:57Z" retrieveTime="2022-10-17T11:45:58.248267">

```
| 00:15 +36: /b/s/w/ir/x/t/flutter_customer_testing.flutter_packages.RNUBSQ/tests/packages/animations/test/open_container_test.dart: Container closes - Fade (by default)
| ══╡ EXCEPTION CAUGHT BY FLUTTER TEST FRAMEWORK ╞════════════════════════════════════════════════════
| The following TestFailure was thrown running a test:
| Expected: 1.0 (±1e-10)
|   Actual: <0.9999833333333332>
|    Which: 0.9999833333333332 is not in the range of 1.0 (±1e-10).
|
| When the exception was thrown, this was the stack:
| #4      main.<anonymous closure> (file:///b/s/w/ir/x/t/flutter_customer_testing.flutter_packages.RNUBSQ/tests/packages/animations/test/open_container_test.dart:273:7)
| <asynchronous suspension>
| <asynchronous suspension>
| (elided one frame from package:stack_trace)
|
| This was caught by the test expectation on the following line:
|   file:///b/s/w/ir/x/t/flutter_customer_testing.flutter_packages.RNUBSQ/tests/packages/animations/test/open_container_test.dart line 273
| The test description was:
|   Container closes - Fade (by default)
| ════════════════════════════════════════════════════════════════════════════════════════════════════
|
| 00:15 +37 -1: /b/s/w/ir/x/t/flutter_customer_testing.flutter_packages.RNUBSQ/tests/packages/animations/test/fade_scale_transition_test.dart: FadeScaleTransitionConfiguration builds a new route
| 00:15 +37 -1: /b/s/w/ir/x/t/flutter_customer_testing.flutter_packages.RNUBSQ/tests/packages/animations/test/open_container_test.dart: Container closes - Fade (by default) [E]
|   Test failed. See exception logs above.
|   The test description was: Container closes - Fade (by default)
```

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-06T00:17:28Z" retrieveTime="2022-10-17T11:45:58.248267">

@pdblasi-google I guess maybe need to update the custom testing configurations to point to the latest tests?

</DiscussionComment>

<DiscussionComment author="pdblasi-google" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-06T18:20:51Z" retrieveTime="2022-10-17T11:45:58.248267">

@fzyzcjy Yup, you called it. Apologies, I forgot to point the flutter/tests repo to the latest tests. PR is up for that now, I'll ping here when it goes through.

</DiscussionComment>

<DiscussionComment author="flutter-dashboard" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-06T20:44:21Z" retrieveTime="2022-10-17T11:45:58.248267">

Golden file changes have been found for this pull request. Click [here to view and triage](https://flutter-gold.skia.org/cl/github/112609) (e.g. because this is an intentional change).

If you are still iterating on this change and are not ready to resolve the images on the Flutter Gold dashboard, consider marking this PR as a draft pull request above. You will still be able to view image results on the dashboard, commenting will be silenced, and the check will not try to resolve itself until marked ready for review.



For more guidance, visit [Writing a golden file test for `package:flutter`](https://github.com/flutter/flutter/wiki/Writing-a-golden-file-test-for-package:flutter).

__Reviewers__: Read the [Tree Hygiene page](https://github.com/flutter/flutter/wiki/Tree-hygiene#how-to-review-code) and make sure this patch meets those guidelines before LGTMing.

_Changes reported for pull request #112609 at sha 02ebd54c3343d0c3aaabcba423b5db13b2bfaadb_



</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-06T23:22:52Z" retrieveTime="2022-10-17T11:45:58.248267">

Thanks and 🎉 !

</DiscussionComment>

<DiscussionComment author="goderbauer" link="https://github.com/flutter/flutter/issues/112778" source="github" createTime="2022-10-10T18:29:29Z" retrieveTime="2022-10-17T11:45:51.858561">

Any reason this is still marked as Draft?

This will need a testing exception.

</DiscussionComment>

<DiscussionComment author="goderbauer" link="https://github.com/flutter/flutter/issues/112757" source="github" createTime="2022-10-10T18:31:24Z" retrieveTime="2022-10-17T11:45:53.143231">

I agree that this comment alone is not particularly useful. To be useful it would need more context so developers can actually make an informed decision of whether they want to use this or not. Let's close this for now.

</DiscussionComment>

<DiscussionComment author="goderbauer" link="https://github.com/flutter/flutter/issues/112437" source="github" createTime="2022-10-10T18:35:45Z" retrieveTime="2022-10-17T11:45:59.560551">

This patch is missing a lot of context information. To quote Dan from the other patch:

> This patch needs a lot more context.
> What's the main goal you're trying to achieve with this particular change?
> Why is it doing it this way?
> Why can't we used existing mechanisms to achieve the same thing?
> Why do we need this mechanism to achieve the larger goal of having incremental/progressive layout?

Regardless, this doesn't seem like a great API to provide a single static callback that gets called on every layout. What if multiple implementations are trying to set this?
Also, this gets called for the layout of every single RenderObject. This doesn't sound great for performance. I know, the title claims it has no overhead, but I find that hard to believe. What's the basis for that claim?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112778" source="github" createTime="2022-10-10T23:08:38Z" retrieveTime="2022-10-17T11:45:51.858561">

> Any reason this is still marked as Draft?

No, I just forgot it :)

> This will need a testing exception.

I think so, thanks

</DiscussionComment>

<DiscussionComment author="Hixie" link="https://github.com/flutter/flutter/issues/112778" source="github" createTime="2022-10-10T23:11:41Z" retrieveTime="2022-10-17T11:45:51.858561">

test-exempt: API refactor

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112437" source="github" createTime="2022-10-10T23:18:30Z" retrieveTime="2022-10-17T11:45:59.560551">

Please ignore this PR for now, since in the https://github.com/fzyzcjy/flutter_smooth (i.e. impl of https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit#), I am trying to use manual widgets as a workaround. So skip it is you are busy :)

> This doesn't sound great for performance. I know, the title claims it has no overhead, but I find that hard to believe. What's the basis for that claim?

I mean zero overhead *when it is disabled* (which IIRC is what hixie(?) cares about a lot). 

Compiler explorer says it is zero overhead b/c the compiler just correctly understands it and eliminate the dead code: https://discord.com/channels/608014603317936148/608021234516754444/1024141725024923688

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1029371064066785340" source="discord" createTime="2022-10-11T12:33:06.463+00:00" retrieveTime="2022-10-17T11:35:17.849540">

I am still working on the "Preemption for 60FPS", i.e. flutter_smooth, currently. Just having this (very rough) idea and want to share it here  https://github.com/flutter/flutter/issues/113281

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1029372886147944539" source="discord" createTime="2022-10-11T12:40:20.881+00:00" retrieveTime="2022-10-17T11:35:17.849540">

(Spoiler: It tries to solve the `hot update` problem)

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/101227" source="github" createTime="2022-10-12T14:04:46Z" retrieveTime="2022-10-17T11:45:49.046468">

### Quick update: ListView scrolling at 60FPS with heavy build/layout

Highlights:

* It is 60FPS <small>(check via splitting video into frames, and by my script to examine timeline tracing data; not checked this demo video though; you can find the script in my repo)</small>
* The list shifting is (roughly) uniform speed (up to error from OS pointer events) <small>(check via script to examine timeline tracing data; again script is in my repo)</small>
* The system uses `gestureBinding.handlePointerEvent` to dispatch `PointerMoveEvent`s

Experiment setup: Slow build/layout when new item comes in. Full code can be seen in https://github.com/fzyzcjy/flutter_smooth.

May still contain (a lot of) bugs, since it is still WIP :)

Video (firstly raw case, then use-flutter_smooth case):

https://user-images.githubusercontent.com/5236035/195363841-240fa44c-c471-412e-9c3d-3314cf6ed8ea.mp4

Sample screenshots from tracing and my script:

![image](https://user-images.githubusercontent.com/5236035/195364264-b84063a8-9a62-416c-8684-424dbc14ed4c.png)
![image](https://user-images.githubusercontent.com/5236035/195364393-6ee2fa8c-697e-4298-92e6-c4a7a6cc7dd3.png)


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1029756897949138994" source="discord" createTime="2022-10-12T14:06:16.429+00:00" retrieveTime="2022-10-17T11:35:17.849540">

Hi guys, quick update:

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1029756943549607967" source="discord" createTime="2022-10-12T14:06:27.301+00:00" retrieveTime="2022-10-17T11:35:17.849540">

**ListView scrolling at 60FPS with heavy build/layout**

Highlights:

* It is 60FPS <small>(check via splitting video into frames, and by my script to examine timeline tracing data; not checked this demo video though; you can find the script in my repo)</small>
* The list shifting is (roughly) uniform speed (up to error from OS pointer events) <small>(check via script to examine timeline tracing data; again script is in my repo)</small>
* The system uses `gestureBinding.handlePointerEvent` to dispatch `PointerMoveEvent`s

Experiment setup: Slow build/layout when new item comes in. Full code can be seen in https://github.com/fzyzcjy/flutter_smooth.

May still contain (a lot of) bugs, since it is still WIP 🙂

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1029757309557157919" source="discord" createTime="2022-10-12T14:07:54.564+00:00" retrieveTime="2022-10-17T11:35:17.849540">

Video (click to see):

https://github.com/flutter/flutter/issues/101227#issuecomment-1276239303

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://discord.com/channels/608014603317936148/608021234516754444/1029757386598121502" source="discord" createTime="2022-10-12T14:08:12.932+00:00" retrieveTime="2022-10-17T11:35:17.849540">


![image](https://cdn.discordapp.com/attachments/608021234516754444/1029757386182901831/unknown.png)

</DiscussionComment>

<DiscussionComment author="CaseyHillers" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-14T01:40:05Z" retrieveTime="2022-10-17T11:45:58.248267">

@fzyzcjy @goderbauer this is a breaking change. Can a migration guide be written on how developers can migrate their code with this change? I'm not sure what's needed on my end as a developer, and my animation tests are now very flaky.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-14T01:44:06Z" retrieveTime="2022-10-17T11:45:58.248267">

@CaseyHillers Hi,

> Can a migration guide be written on how developers can migrate their code with this change? ...and my animation tests are now very flaky.

Could you please share some flaky test minimal reproducible samples? IMHO this should not make any problem so want to see reproductions in order to know what happens

</DiscussionComment>

<DiscussionComment author="CaseyHillers" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-14T01:57:31Z" retrieveTime="2022-10-17T11:45:58.248267">

Here's an example now that is flaky:

```dart
      await tester.pumpWidget(myAnimatedWidget);
      await tester.pumpAndSettle();

      await tester.sendSelectEvent();

      await tester.pumpFrames(scene, Duration(milliseconds: 100));
      await expectLater(
          find.byType(MyAnimatedWidget),
          matchesGoldenFile(
              'animated_widget'));
```

The resulting goldens are changing. When I change `pumpFrames` to microseconds, I am still seeing the same flakiness. I'm unsure if it's because the earlier clocks are still in millisecond mode.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-14T02:00:52Z" retrieveTime="2022-10-17T11:45:58.248267">

@CaseyHillers Weird. Some possible ideas:

1. Do you have anything that depends on e.g. a real clock? If so, it will be flaky. (I guess no)
2. Could you please change `MyAnimatedWidget` to something like `AnimatedBuilder(builder: (_, value) => Text('the value is: $value')`. Then, when the golden is changing, we can know what value indeed it is having.

> I'm unsure if it's because the earlier clocks are still in millisecond mode.

Do you mean the new golden (i.e. after the PR) are different from old golden, and the new golden is itself stable? If so, looks like it is possible. Indeed the animation controller is fed with a changed animation time.

</DiscussionComment>

<DiscussionComment author="CaseyHillers" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-14T02:22:06Z" retrieveTime="2022-10-17T11:45:58.248267">

My animated widgets are just an animated builder that has a custom animation controller. @goderbauer or @pdblasi-google can help with reproducing the issue here.

My understanding is I need to change every possible clock to be in microseconds instead of milliseconds. This seems to be a breaking change for any other customers, and I'm having a difficult time tracking all the various clocks in my codebase.

I haven't found the discord threads, but I wonder if this is something that should be in the framework. There could be a tester field added for high precision or this can be added directly to your package. I assume most Flutter tests aren't needing high precision, and this is going to cause a lot of pain once it's in beta/stable.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-14T02:24:29Z" retrieveTime="2022-10-17T11:45:58.248267">

@CaseyHillers 

> I need to change every possible clock to be in microseconds instead of milliseconds

Btw I am curious why a clock can in milliseconds in codebase - `clock` package, `Duration`, DateTime, etc are all in microseconds.

> I haven't found the discord threads, but I wonder if this is something that should be in the framework. There could be a tester field added for high precision or this can be added directly to your package. I assume most Flutter tests aren't needing high precision, and this is going to cause a lot of pain once it's in beta/stable.

I agree that an alternative solution is to use a bool flag to enable high-accuracy (I have done that indeed - https://github.com/flutter/flutter/pull/112609/commits/e0b5882b87bc8fe025d55d626ec663c8587522b7).

</DiscussionComment>

<DiscussionComment author="CaseyHillers" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-14T11:38:10Z" retrieveTime="2022-10-17T11:45:58.248267">

> I agree that an alternative solution is to use a bool flag to enable high-accuracy (I have done that indeed - https://github.com/flutter/flutter/commit/e0b5882b87bc8fe025d55d626ec663c8587522b7).

Thanks, that sounds like it would work for me! Are there plans to upstream that change?

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-14T11:39:13Z" retrieveTime="2022-10-17T11:45:58.248267">

@CaseyHillers I am ok with that, just not sure what other reviewers think? (Since that was my original design and later a reviewer suggests me to change to what is current merged.) If you guys are OK I will PR it.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/113433" source="github" createTime="2022-10-14T11:46:19Z" retrieveTime="2022-10-17T11:45:50.542788">

### Reland `AutomatedTestWidgetsFlutterBinding.pump` provides wrong pump time stamp, probably because of forgetting the precision, via optional flag

This relands https://github.com/flutter/flutter/pull/112609, but with a flag that is off by default. The reason why it is designed like this can be found in discussions around https://github.com/flutter/flutter/pull/112609#issuecomment-1278889389.

Close #112610

## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide], including [Features we expect every widget to implement].
- [x] I signed the [CLA].
- [x] I listed at least one issue that this PR fixes in the description above.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [x] I added new tests to check the change I am making, or this PR is [test-exempt].
- [ ] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[test-exempt]: https://github.com/flutter/flutter/wiki/Tree-hygiene#tests
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[Features we expect every widget to implement]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#features-we-expect-every-widget-to-implement
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat


</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/112609" source="github" createTime="2022-10-14T11:48:14Z" retrieveTime="2022-10-17T11:45:58.248267">

@CaseyHillers Here is the PR: https://github.com/flutter/flutter/pull/113433

</DiscussionComment>

<DiscussionComment author="pdblasi-google" link="https://github.com/flutter/flutter/issues/113433" source="github" createTime="2022-10-14T17:25:00Z" retrieveTime="2022-10-17T11:45:50.542788">

@fzyzcjy @CaseyHillers @goderbauer

I still think that this change should be made without the boolean flag. The underlying issue with the goldens is that `pumpFrames` defines `interval` with microsecond precision, but the `AutomatedTestWidgetsFlutterBinding` didn't support microsecond precision. @Piinks and I went over a couple of golden changes in the flutter repos test as well and accepted the changes to those goldens as they were a change to a correct state (which is why the goldens are current hanging for this PR).

The secondary issue that makes this difficult to break cleanly is that `LiveWidgetsFlutterBinding` _does_ support microsecond precision, so we can't just update `pumpFrames`' `interval` parameter to be a clean 16 milliseconds by default, as that would break _other tests_.

To start with, the first paragraph in the [breaking changes process](https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes) says:

> Sometimes, however, doing this is necessary for the greater good. We want our APIs to be intuitive; if being backwards-compatible requires making an API into something that we would never have designed that way unless forced to by circumstances, then we should instead break the API and make it good.

Adding a boolean to make the _correct_ behavior happen is not an API that we would have designed on purpose. It's also not a change that we can easily guide people to using, as there's no "new API" we can drive them towards with deprecations or data driven fixes. It'd be something we introduce for a period of time, hope people read the blog, then end up running into the same "breaking change" issues when we eventually remove the boolean or default it to true.

From there, digging into the process, the preferred process is the three step process:

1. Add new API and opt in to the new API
2. Remove the old API
3. Remove the opt in

I think the only way we can get that to happen is to introduce a new version of `pumpFrames` that would support the correct behavior, deprecate the current `pumpFrames`, then eventually remove `pumpFrames`. Here's what I'd propose:

* Fix `AutomatedTestWidgetsFlutterBinding` _without_ the flag
* Introduce a new method with the exact contents that `pumpFrames` currently has:

```
pumpFramesFor(
  Widget target,
  Duration duration, [
    Duration interval = const Duration(milliseconds: 16, microseconds: 683),
  ])
```
* Update `pumpFrames` to pass through to the new `pumpFramesFor` method:
    * Check `if (binding is AutomatedTestWidgetsFlutterBinding)`
    * If it is, then truncate the microseconds off of `interval` before passing through to maintain the current incorrect behavior

My biggest concern with this approach is that `pumpFramesFor` isn't as clean a name as just `pumpFrames`, but it's the best I can come up with. Names aside, introducing a new method and deprecating the old is the only way I can think of to keep the existing behavior and actually be able to drive users to the new api before landing the correct behavior.

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36556" source="github" createTime="2022-10-14T23:08:45Z" retrieveTime="2022-10-17T11:46:04.616331">

> This is an artifact of what the code used to do, but it has since been refactored to not do that :)

I guess so :) That is why I update it - otherwise it will mislead future readers

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/flutter/issues/113433" source="github" createTime="2022-10-14T23:13:36Z" retrieveTime="2022-10-17T11:45:50.542788">

@pdblasi-google @CaseyHillers @goderbauer I agree with both sides of the opinion, both looks very reasonable to me. So just ping me when googlers reach a conclusion that what I should do!

</DiscussionComment>

<DiscussionComment author="fzyzcjy" link="https://github.com/flutter/engine/issues/36775" source="github" createTime="2022-10-15T02:11:34Z" retrieveTime="2022-10-17T11:46:02.145776">

### Fix wrong `VSYNC` event

Firstly, we know `VSYNC` event in timeline is special - `chrome://tracing` tool will show "zebra" colors (gray and white) at every VSYNC. Therefore, it is critical to let this event have correct timing, otherwise every user is doing reasoning with the wrong vsync time.

In the image below, the "a" shows the new VSYNC with this PR, while the "b" shows the old VSYNC interval before this PR. As we can see, the left side of "a" and "b" does not coincide. In other words, before this PR (where we have "b" as the VSYNC and there is no "a"), we consider the wrong time as the vsync time.

The cause is quite simple: Before this PR, the left edge of "VSYNC" event is (for example) the call time of `VsyncWaiterAndroid::OnVsyncFromJava`. However, there exist "frame delay" (e.g. `frameDelayNanos` argument in `OnVsyncFromJava`), so the real vsync time should minus that delay.

As a side remark, in the image below the difference is not very much, but in real scenarios, I have seen once in a while it has large differences. Then you know, the visualization goes wild, and it took me some time before I realized, it is not a bug in code anywhere, but a bug of the VSYNC event time.

![image](https://user-images.githubusercontent.com/5236035/195964378-c509e647-7740-4e87-a19e-30fa4fee9221.png)


Close #113475

## Pre-launch Checklist

- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.
- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.
- [x] I read and followed the [Flutter Style Guide] and the [C++, Objective-C, Java style guides].
- [x] I listed at least one issue that this PR fixes in the description above.
- [ ] I added new tests to check the change I am making or feature I am adding, or Hixie said the PR is test-exempt. See [testing the engine] for instructions on
writing and running engine tests.
- [x] I updated/added relevant documentation (doc comments with `///`).
- [x] I signed the [CLA].
- [x] All existing and new tests are passing.

If you need help, consider asking for advice on the #hackers-new channel on [Discord].

<!-- Links -->
[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview
[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene
[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
[C++, Objective-C, Java style guides]: https://github.com/flutter/engine/blob/main/CONTRIBUTING.md#style
[testing the engine]: https://github.com/flutter/flutter/wiki/Testing-the-engine
[CLA]: https://cla.developers.google.com/
[flutter/tests]: https://github.com/flutter/tests
[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes
[Discord]: https://github.com/flutter/flutter/wiki/Chat


</DiscussionComment>

<DiscussionComment author="flutter-dashboard" link="https://github.com/flutter/engine/issues/36775" source="github" createTime="2022-10-15T02:26:29Z" retrieveTime="2022-10-17T11:46:02.145776">

It looks like this pull request may not have tests. Please make sure to add tests before merging. If you need [an exemption](https://github.com/flutter/flutter/wiki/Tree-hygiene#tests) to this rule, contact Hixie on the #hackers channel in [Chat](https://github.com/flutter/flutter/wiki/Chat) (don't just cc him here, he won't see it! *He's on Discord!*).

If you are not sure if you need tests, consider this rule of thumb: the purpose of a test is to make sure someone doesn't accidentally revert the fix. Ask yourself, **is there anything in your PR that you feel it is important we not accidentally revert back to how it was before your fix?**

__Reviewers__: Read the [Tree Hygiene page](https://github.com/flutter/flutter/wiki/Tree-hygiene#how-to-review-code) and make sure this patch meets those guidelines before LGTMing.

</DiscussionComment>